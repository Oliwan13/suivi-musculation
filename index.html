<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="manifest" href="manifest.json">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">

    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <noscript>
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    </noscript>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <meta name="robots" content="noindex, nofollow">
    <title>Lyftiv - Suivi Séance Musculation</title>
    
    <style>
/* CSS Cascade Layers - Base, Components, Utilities */
@layer base, components, utilities;

@layer base {
    :root {
        /* Color System - Improved with HSL base values and color-mix concept */
        /* Define base HSL values for primary colors */
        --color-blue-base: 220 60% 50%;
        --color-green-base: 140 50% 45%;
        --color-orange-base: 40 70% 50%;
        --color-red-base: 0 60% 50%;
        --color-cyan-base: 200 60% 50%;

        /* Backgrounds and Surfaces */
        --color-background-gradient-start: hsl(200, 60%, 95%);
        --color-background-gradient-end: hsl(220, 70%, 98%);
        --color-surface-default: hsla(0, 0%, 100%, 0.95);
        --color-surface-muted: hsla(210, 15%, 98%, 0.7);
        --color-surface-input: white;
        
        /* Text Colors */
        --color-text-default: hsl(220, 15%, 30%);
        --color-text-header: hsl(220, 20%, 20%);
        --color-text-subheader: hsl(220, 10%, 45%);
        --color-text-on-accent: hsl(0, 0%, 100%);

        /* Border Color */
        --color-border-default: hsl(210, 15%, 90%);

        /* Primary Colors */
        --color-primary-default: hsl(var(--color-blue-base));
        --color-primary-gradient-start: hsl(220, 60%, 70%); /* Specific gradient start */
        --color-primary-gradient-end: hsl(240, 70%, 75%);   /* Specific gradient end */

        /* Success Colors */
        --color-success-default: hsl(var(--color-green-base));
        --color-success-gradient-start: hsl(140, 60%, 70%);
        --color-success-gradient-end: hsl(160, 70%, 75%);

        /* Warning Colors */
        --color-warning-default: hsl(var(--color-orange-base));
        --color-warning-gradient-start: hsl(40, 80%, 75%);
        --color-warning-gradient-end: hsl(30, 90%, 80%);

        /* Danger Colors */
        --color-danger-default: hsl(var(--color-red-base));
        --color-danger-gradient-start: hsl(0, 60%, 75%);
        --color-danger-gradient-end: hsl(10, 70%, 80%);

        /* Info Colors */
        --color-info-default: hsl(var(--color-cyan-base));
        --color-info-gradient-start: hsl(200, 70%, 70%);
        --color-info-gradient-end: hsl(210, 80%, 75%);

        /* Shadow System - Consolidated */
        --shadow-xs: hsla(220, 20%, 20%, 0.02);
        --shadow-sm: hsla(220, 20%, 20%, 0.04);
        --shadow-md: hsla(220, 20%, 20%, 0.08);
        --shadow-lg: hsla(220, 20%, 20%, 0.15);
        --shadow-xl: hsla(220, 20%, 20%, 0.25);
        --shadow-strong: hsla(220, 20%, 20%, 0.4); /* Used in modal-content:focus-within */


        /* Radius System */
        --radius-xs: 6px;
        --radius-base: 12px;
        --radius-medium: 18px;
        --radius-large: 24px;
        --radius-button: 30px;
        
        /* Spacing System */
        --spacing-xxs: 0.125rem; /* 2px */
        --spacing-xs: 0.25rem;  /* 4px */
        --spacing-sm: 0.5rem;   /* 8px */
        --spacing-md: 1rem;     /* 16px */
        --spacing-lg: 1.5rem;   /* 24px */
        --spacing-xl: 2rem;     /* 32px */
        --spacing-xxl: 3rem;    /* 48px */
        --spacing-xxxl: 4rem;   /* 64px */

        /* Typography Scale */
        --font-size-sm: 0.85rem;
        --font-size-base: 1rem;
        --font-size-lg: 1.15rem;
        --font-size-xl: 1.25rem;
        --font-size-2xl: clamp(2rem, 1.5rem + 2.5vw, 2.75rem);

        color-scheme: light dark; /* Enables native dark mode support */

        /* Theme Toggle Button Colors */
        --theme-toggle-bg-light: hsl(var(--color-blue-base));
        --theme-toggle-color-light: var(--color-text-on-accent);

        /* Tâche 2.2: Refactorisation des gradients et ombres des boutons */
        --btn-primary-bg: linear-gradient(135deg, var(--color-primary-gradient-start), var(--color-primary-gradient-end)), radial-gradient(circle at 30% 30%, hsla(220, 60%, 80%, 0.3), transparent);
        --btn-secondary-bg: linear-gradient(135deg, var(--color-warning-gradient-start), var(--color-warning-gradient-end));
        --btn-danger-bg: linear-gradient(135deg, var(--color-danger-gradient-start), var(--color-danger-gradient-end));
        --btn-success-bg: linear-gradient(135deg, var(--color-success-gradient-start), var(--color-success-gradient-end));
        --btn-info-bg: linear-gradient(135deg, var(--color-info-gradient-start), var(--color-info-gradient-end));
        
        --btn-shadow-normal: 0 4px 10px var(--shadow-sm);
        --btn-shadow-hover: 0 7px 14px var(--shadow-md);
        --btn-shadow-active: 0 2px 5px var(--shadow-sm);
    }

    body.dark-mode {
        /* Dark Mode Colors - Using HSL base values for consistency */
        --color-background-gradient-start: hsl(230, 20%, 18%);
        --color-background-gradient-end: hsl(245, 25%, 22%);
        --color-surface-default: hsla(220, 20%, 25%, 0.95);
        --color-surface-muted: hsla(220, 20%, 20%, 0.7);
        --color-surface-input: hsl(220, 20%, 20%);
        
        --color-text-default: hsl(210, 15%, 80%);
        --color-text-header: hsl(210, 10%, 75%);
        --color-text-subheader: hsl(210, 10%, 60%);
        --color-text-on-accent: hsl(0, 0%, 90%);

        --color-border-default: hsl(220, 15%, 35%);

        --color-primary-default: hsl(220, 60%, 65%);
        --color-primary-gradient-start: hsl(220, 30%, 40%);
        --color-primary-gradient-end: hsl(240, 35%, 45%);

        --color-success-default: hsl(140, 50%, 60%);
        --color-success-gradient-start: hsl(140, 30%, 40%);
        --color-success-gradient-end: hsl(160, 35%, 45%);

        /* Warning Colors */
        --color-warning-default: hsl(40, 70%, 65%);
        --color-warning-gradient-start: hsl(40, 45%, 50%);
        --color-warning-gradient-end: hsl(30, 50%, 55%);
        
        --color-danger-default: hsl(0, 60%, 65%);
        --color-danger-gradient-start: hsl(0, 35%, 45%);
        --color-danger-gradient-end: hsl(10, 40%, 50%);
        
        --color-info-default: hsl(200, 60%, 65%);
        --color-info-gradient-start: hsl(200, 45%, 50%);
        --color-info-gradient-end: hsl(210, 50%, 55%);

        --shadow-xs: hsla(220, 20%, 10%, 0.1);
        --shadow-sm: hsla(220, 20%, 10%, 0.2);
        --shadow-md: hsla(220, 20%, 10%, 0.3);
        --shadow-lg: hsla(220, 20%, 10%, 0.4);
        --shadow-xl: hsla(220, 20%, 10%, 0.5);
        --shadow-strong: hsla(220, 20%, 10%, 0.6); /* Used in modal-content:focus-within */


        /* Theme Toggle Button Colors for Dark Mode */
        --theme-toggle-bg-dark: hsl(220, 20%, 30%); /* Darker background for dark mode button */
        --theme-toggle-color-dark: hsl(210, 15%, 80%); /* Lighter text for dark mode button */
    }

    /* Reduced Motion Support */
    @media (prefers-reduced-motion: reduce) {
        *, *::before, *::after {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
        }
    }

    @keyframes fade-in { from { opacity: 0; } }
    @keyframes fade-out { to { opacity: 0; } }
    @keyframes slide-from-right { from { transform: translateX(50px); opacity: 0; } }
    @keyframes slide-to-left { to { transform: translateX(-50px); opacity: 0; } }

    ::view-transition-old(root) {
        animation: 300ms cubic-bezier(0.4, 0, 0.2, 1) both fade-out,
                300ms cubic-bezier(0.4, 0, 0.2, 1) both slide-to-left;
    }
    ::view-transition-new(root) {
        animation: 300ms cubic-bezier(0.4, 0, 0.2, 1) both fade-in,
                300ms cubic-bezier(0.4, 0, 0.2, 1) both slide-from-right;
    }

    /* Enhanced Focus Management */
    :focus-visible {
        outline: 3px solid var(--color-info-default);
        outline-offset: 3px;
        border-radius: var(--radius-xs);
    }
    :focus:not(:focus-visible) {
        outline: none;
    }
    select:focus-visible, 
    input:focus-visible, 
    textarea:focus-visible {
        outline: none;
        border-color: var(--color-primary-default);
        box-shadow: 0 0 0 4px hsla(220, 60%, 75%, 0.3);
    }
    .modal-content:focus-within { /* Added focus-within for modal content */
        box-shadow: 0 0 0 3px var(--color-info-default), 0 20px 40px var(--shadow-xl); /* Adjusted to use var(--shadow-xl) for consistency */
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    .is-loading {
        position: relative;
        color: transparent !important;
        pointer-events: none;
    }
    .is-loading::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 20px;
        height: 20px;
        border: 3px solid hsla(0, 0%, 100%, 0.3);
        border-top-color: var(--color-text-on-accent);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    input.is-valid {
        border-color: var(--color-success-default);
        box-shadow: 0 0 0 4px hsla(140, 60%, 75%, 0.3);
    }
} /* End @layer base */

@layer components {
    * { box-sizing: border-box; }
    html { scroll-behavior: smooth; }
    body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;font-family: 'Inter', sans-serif;
        font-size: var(--font-size-base); 
        line-height: 1.6; 
        margin: 0;
        padding: var(--spacing-xxl);
        background: linear-gradient(135deg, var(--color-background-gradient-start) 0%, var(--color-background-gradient-end) 100%);
        min-height: 100vh;
        color: var(--color-text-default);
        transition: background 0.6s ease, color 0.6s ease;
    }
    .main-container {
        max-width: 1600px;
        margin: 0 auto;
        background: var(--color-surface-default);
        border-radius: var(--radius-large);
        padding: var(--spacing-xxl);
        box-shadow: 0 15px 30px var(--shadow-md); /* Using consolidated shadow variable */
        backdrop-filter: blur(10px);
        transition: background 0.5s ease;
        position: relative;
        container-type: inline-size;
        container-name: main;
    }
    h2 {
        text-align: center;
        color: var(--color-text-header);
        margin-bottom: var(--spacing-xxl);
        font-size: var(--font-size-2xl);
        font-weight: 800;
        letter-spacing: -0.03em;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-md);
    }
    .lyftiv-logo {
        width: clamp(40px, 32px + 2.5vw, 52px);
        height: clamp(40px, 32px + 2.5vw, 52px);
    }
    h3 {
        font-weight: 700;
        font-size: clamp(1.2rem, 1.1rem + 0.5vw, 1.4rem);
        color: var(--color-text-header);
        margin-bottom: var(--spacing-sm);
        letter-spacing: -0.01em;
        text-transform: capitalize; 
    }
    h4 {
        margin: 0 0 var(--spacing-xs) 0;
        font-size: var(--font-size-lg);
        color: var(--color-text-subheader);
    }
    .controls {
        display: flex;
        flex-wrap: wrap;
        gap: var(--spacing-lg);
        align-items: center;
        margin-bottom: var(--spacing-xl);
        padding: var(--spacing-lg);
        background: hsla(0, 0%, 100%, 0.1);
        border-radius: var(--radius-large);
        box-shadow: 0 3px 8px var(--shadow-sm); /* Using consolidated shadow variable */
        transition: background 0.5s ease;
    }
    select, input[type="number"], input[type="text"], textarea {
        padding: var(--spacing-sm) var(--spacing-md);
        border: 1px solid var(--color-border-default);
        border-radius: var(--radius-base);
        font-size: var(--font-size-base);
        background-color: var(--color-surface-input);
        color: var(--color-text-default);
        font-weight: 500;
        width: 100%;
        max-width: 300px;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
        font-family: 'Inter', sans-serif;
    }
    input.is-invalid {
        border-color: var(--color-danger-default);
        box-shadow: 0 0 0 4px hsla(0, 60%, 75%, 0.3);
    }
    .error-message {
        color: var(--color-danger-default);
        font-size: var(--font-size-sm);
        margin-top: var(--spacing-xxs);
        text-align: center;
        width: 100%;
    }

    textarea {
        resize: vertical;
        min-height: 110px;
        max-width: 100%;
    }
    .exercise-list-container {
        border-radius: var(--radius-large);
        background: var(--color-surface-input);
        margin-bottom: var(--spacing-xxl);
        box-shadow: 0 6px 15px var(--shadow-md); /* Using consolidated shadow variable */
        overflow: hidden;
    }

    .exercise-list-container .desktop-table {
        width: 100%;
        border-collapse: separate; 
        border-spacing: 0; 
        table-layout: auto; 
    }
    .exercise-list-container .desktop-table th, 
    .exercise-list-container .desktop-table td {
        padding: var(--spacing-md) var(--spacing-sm);
        text-align: center;
        border-bottom: 1px solid var(--color-border-default); 
        transition: background-color 0.3s ease;
        font-weight: 500;
    }
    .exercise-list-container .desktop-table th {
        background: linear-gradient(135deg, var(--color-primary-gradient-start), var(--color-primary-gradient-end));
        color: var(--color-text-on-accent);
        font-size: var(--font-size-sm); 
        letter-spacing: 1px; 
        position: sticky;
        top: 0;
        z-index: 10;
        font-weight: 700;
    }
    .exercise-list-container .desktop-table th:first-child { border-top-left-radius: var(--radius-large); }
    .exercise-list-container .desktop-table th:last-child { border-top-right-radius: var(--radius-large); }

    .exercise-list-container .desktop-table .exercise-row {
        transition: background-color 0.3s ease; 
    }
    .exercise-list-container .desktop-table .exercise-row:nth-child(even) {
        background-color: var(--color-surface-muted);
    }
    .exercise-list-container .desktop-table .exercise-row:hover {
        background-color: hsla(200, 70%, 95%, 0.3); 
    }
    body.dark-mode .exercise-list-container .desktop-table .exercise-row:hover {
        background-color: hsla(220, 20%, 28%, 0.5); 
    }

    .exercise-list-container .desktop-table .exercise-row.superset-group {
        border-inline-start: 4px solid var(--color-info-default); /* Logical property */
    }

    .exercise-list-container .desktop-table .actions-col { 
        width: max-content; 
        padding-inline-start: var(--spacing-sm); /* Logical property */
        padding-inline-end: var(--spacing-sm); /* Logical property */
    }
    .exercise-list-container .desktop-table .exercise-col {
        width: 0%; 
        max-width: 280px; 
        text-align: left; 
        padding-inline-start: var(--spacing-md); /* Logical property */
        white-space: normal;
        font-weight: 600; 
        font-size: 1.05rem; 
    }

    .exercise-list-container .desktop-table .serie-input input {
        text-align: center;
    }
    .modal-content .controls input[type="number"],
    .modal-content .controls input[type="text"] {
        text-align: center;
    }
    .modal-content .controls {
        justify-content: center;
    }

    .exercise-list-container .mobile-cards {
        display: none;
        flex-direction: column;
        gap: var(--spacing-lg);
        padding: var(--spacing-lg);
    }
    .exercise-card {
        background-color: var(--color-surface-input);
        border-radius: var(--radius-medium);
        padding: var(--spacing-md);
        box-shadow: 0 44px 10px var(--shadow-sm); /* Using consolidated shadow variable */
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .exercise-card.superset-group {
        border-inline-start: 4px solid var(--color-info-default); /* Logical property */
    }
    .exercise-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 14px var(--shadow-md); /* Using consolidated shadow variable */
    }
    .exercise-card h4 {
        font-size: var(--font-size-xl);
        font-weight: 700;
        color: var(--color-text-header);
        margin: 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    .exercise-card .series-group {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-xs);
        padding: var(--spacing-sm) 0;
        border-top: 1px solid var(--color-border-default);
        border-bottom: 1px solid var(--color-border-default);
    }
    .exercise-card .series-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.95rem;
        color: var(--color-text-default);
    }
    .exercise-card .series-row strong {
        font-weight: 600;
        color: var(--color-primary-default);
    }
    .exercise-card .series-input-group {
        display: flex;
        gap: var(--spacing-xs);
        align-items: center;
    }
    .exercise-card .series-input-group input {
        width: 65px;
        padding: var(--spacing-xs);
        font-size: 0.9rem;
        text-align: center;
    }
    .serie-input-delete {
        background: none;
        border: none;
        color: var(--color-danger-default);
        font-size: 1.1rem;
        cursor: pointer;
        margin-inline-start: var(--spacing-xxs); /* Logical property */
        opacity: 0.7;
        transition: opacity 0.2s ease;
        padding: var(--spacing-sm);
        min-width: 44px; /* Ensure minimum 44px touch target */
        min-height: 44px; /* Ensure minimum 44px touch target */
        display: flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
    }
    .serie-input-delete:hover {
        opacity: 1;
    }
    .exercise-card .series-input-group input.completed {
        background: linear-gradient(135deg, var(--color-success-gradient-start), var(--color-success-gradient-end));
        color: var(--color-text-on-accent);
        border-color: var(--color-success-default);
    }
    .exercise-card .card-stats {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: var(--spacing-sm);
        font-size: 0.9rem;
    }
    .exercise-card .card-stat-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--spacing-xxs);
    }
    .exercise-card .card-stat-label {
        color: var(--color-text-subheader);
        font-size: var(--font-size-sm);
    }
    .exercise-card .card-stat-value {
        font-weight: 700;
        color: var(--color-primary-default);
        font-size: var(--font-size-lg);
    }
    .exercise-card .card-actions {
        display: flex;
        justify-content: space-around;
        gap: var(--spacing-sm);
        margin-top: var(--spacing-md);
        align-items: center;
    }
    .exercise-card .card-actions .btn {
        flex-grow: 1;
        padding: var(--spacing-xs) var(--spacing-sm);
        font-size: 0.9rem;
        border-radius: var(--radius-base);
    }
    @media (max-width: 768px) {
        .exercise-card .card-actions .btn[data-action="quick-edit"] {
            background: none;
            color: var(--color-info-default);
            border: none;
            box-shadow: none;
            opacity: 0.8;
        }
        .exercise-card .card-actions .btn[data-action="quick-edit"]:hover {
            background-color: hsla(200, 70%, 95%, 0.3);
            color: var(--color-info-default);
        }
    }

    .serie-input {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-xs);
        align-items: center;
    }
    .serie-input input {
        width: 60px;
        padding: var(--spacing-xs);
        font-size: 0.95rem;
        text-align: center;
        font-weight: 500;
        border-radius: var(--radius-xs);
    }
    .serie-input input.completed {
        background: linear-gradient(135deg, var(--color-success-gradient-start), var(--color-success-gradient-end));
        color: var(--color-text-on-accent);
        border-color: var(--color-success-default);
    }
    .kg-rep-high, .onerm-high { /* Renamed from .tonnage-high */
        background: linear-gradient(135deg, var(--color-success-gradient-start), var(--color-success-gradient-end));
        color: var(--color-text-on-accent);
        border-radius: var(--radius-xs);
        padding: var(--spacing-xs) var(--spacing-sm);
        font-weight: 600;
        font-size: 0.9rem;
        opacity: 0.9;
        box-shadow: 0 2px 5px var(--shadow-sm); /* Using consolidated shadow variable */
    }
    .timer-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--spacing-xs);
    }
    .timer-btn {
        padding: var(--spacing-sm) var(--spacing-md);
        min-width: 44px; /* Ensure minimum 44px touch target */
        min-height: 44px; /* Ensure minimum 44px touch target */
        border: none;
        border-radius: var(--radius-button);
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 600;
        color: var(--color-text-on-accent);
        transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease; 
        box-shadow: 0 3px 8px var(--shadow-sm); /* Using consolidated shadow variable */
        will-change: transform, box-shadow, background-color; /* Optimize animation */
    }
    .timer-btn:hover { 
        transform: translateY(-2px);
        box-shadow: 0 4px 10px var(--shadow-md); /* Using consolidated shadow variable */
    }
    .timer-btn[data-timer-action="start"] { background: var(--btn-success-bg); }
    .timer-btn[data-timer-action="stop"] { background: var(--btn-danger-bg); }
    .timer-btn[data-timer-action="reset"] { background: var(--btn-secondary-bg); }
    .timer-display { 
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--color-text-default);
        transition: color 0.3s ease;
        will-change: color; /* Optimize animation */
    }
    .timer-display.timer-active { 
        color: var(--color-success-default);
        animation: pulse 1.2s infinite; 
        font-weight: 700;
    }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }

    .summary-section {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: var(--spacing-lg);
        margin-bottom: var(--spacing-xxl);
    }
    .summary-card { 
        padding: var(--spacing-xl);
        border-radius: var(--radius-large); /* Made more rounded */
        text-align: center; 
        background: var(--color-surface-input);
        border: 1px solid var(--color-border-default); 
        box-shadow: 0 4px 10px var(--shadow-md); /* Using consolidated shadow variable */
        transition: transform 0.2s ease, box-shadow 0.2s ease; 
        position: relative;
        overflow: hidden;
        will-change: transform, box-shadow; /* Optimize animation */
    }
    @container main (max-width: 600px) {
        .summary-card {
            padding: var(--spacing-lg);
        }
        .summary-card .value {
            font-size: clamp(2rem, 1.5rem + 2.5vw, 2.2rem);
        }
    }
    .summary-card:hover {
        transform: translateY(-4px); /* More noticeable lift on hover */
        box-shadow: 0 8px 20px var(--shadow-xl); /* Using consolidated shadow variable */
    }
    .summary-card h3 {
        font-size: 1.1rem;
        color: var(--color-text-subheader);
        margin-bottom: var(--spacing-sm);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-xs);
    }

    .summary-card .value {
        font-weight: 700;
        font-size: 1.8rem;
        color: var(--color-primary-default);
    }

    .summary-card .card-icon {
        font-size: 1.5rem;
        color: var(--color-primary-default);
        opacity: 0.2;
        position: absolute;
        top: var(--spacing-sm);
        right: var(--spacing-sm);
    }

    .action-buttons { 
        display: flex;
        flex-wrap: wrap; 
        gap: var(--spacing-lg);
        justify-content: center; 
        margin-top: var(--spacing-xxl); 
    }
    .btn, button { 
        padding: var(--spacing-md) var(--spacing-xl);
        min-height: 44px; /* Ensure minimum 44px touch target */
        min-width: 44px; /* Ensure minimum 44px touch target */
        border: none; 
        border-radius: var(--radius-button);
        cursor: pointer; 
        font-size: var(--font-size-base);
        font-weight: 600; 
        font-family: 'Inter', sans-serif;
        color: var(--color-text-on-accent);
        transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
        box-shadow: var(--btn-shadow-normal); /* Using refactored shadow variable */
        will-change: transform, box-shadow, background-color; /* Optimize animation */
        text-transform: none; /* Point 1: Ensure button text is not uppercased */
    }
    .btn:hover {
        transform: translateY(-3px);
        box-shadow: var(--btn-shadow-hover); /* Using refactored shadow variable */
    }
    .btn:not(:disabled):active {
        transform: translateY(-1px) scale(0.98);
        box-shadow: var(--btn-shadow-active); /* Using refactored shadow variable */
    }
    .btn:disabled, .btn.is-disabled {
        cursor: not-allowed;
        opacity: 0.6;
        background: var(--color-border-default);
        box-shadow: none;
        transform: none;
    }

    .btn-primary { 
        background: var(--btn-primary-bg); /* Using refactored gradient */
    }
    .btn-secondary { background: var(--btn-secondary-bg); } /* Using refactored gradient */
    .btn-danger { background: var(--btn-danger-bg); } /* Using refactored gradient */
    .btn-success { background: var(--btn-success-bg); } /* Using refactored gradient */
    .btn-info { background: var(--btn-info-bg); } /* Using refactored gradient */

    .btn-outline {
        background: none;
        color: var(--color-primary-default);
        border: 2px solid var(--color-primary-default);
        box-shadow: none;
    }
    .btn-outline:hover {
        background-color: hsla(220, 60%, 75%, 0.1);
        box-shadow: var(--shadow-sm); /* Using consolidated shadow variable */
    }
    .btn-ghost {
        background: none;
        color: var(--color-info-default);
        border: 1px solid transparent;
        box-shadow: none;
    }
    .btn-ghost:hover {
        background: hsla(200, 70%, 90%, 0.2);
        border-color: var(--color-info-default);
        color: var(--color-info-default);
    }
    body.dark-mode .btn-ghost:hover {
        background: hsla(200, 45%, 50%, 0.2);
    }


    .notification { 
        position: fixed;
        top: var(--spacing-xl); 
        right: var(--spacing-xl); 
        padding: var(--spacing-md) var(--spacing-lg);
        border-radius: var(--radius-base);
        color: var(--color-text-on-accent); 
        z-index: 1001; 
        transform: translateX(120%); 
        opacity: 0;
        transition: transform 0.3s ease, opacity 0.3s ease; /* Consolidated transition */
        box-shadow: 0 8px 20px var(--shadow-md); /* Using consolidated shadow variable */
        will-change: transform, opacity; /* Optimize animation */
    }
    .notification.show { 
        transform: translateX(0);
        opacity: 1;
    }
    .notification.success { background: var(--btn-success-bg); } /* Using refactored gradient */
    .notification.error { background: var(--btn-danger-bg); } /* Using refactored gradient */
    .notification.info { background: var(--btn-info-bg); } /* Using refactored gradient */

    .modal-overlay { 
        position: fixed;
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 100%; 
        background: hsla(220, 10%, 10%, 0.6);
        display: flex; 
        align-items: center; 
        justify-content: center;
        z-index: 1000; 
        backdrop-filter: blur(8px);
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    .modal-overlay.show {
        opacity: 1;
        visibility: visible;
    }
    .modal-content { 
        background: var(--color-surface-default);
        padding: var(--spacing-xxl);
        border-radius: var(--radius-large);
        max-width: 900px;
        max-height: 90vh; 
        overflow-y: auto; 
        position: relative; 
        box-shadow: 0 20px 40px var(--shadow-xl); /* Using consolidated shadow variable */
        transform: translateY(-20px);
        transition: transform 0.3s ease, opacity 0.3s ease;
        opacity: 0;
        will-change: transform, opacity; /* Optimize animation */
    }
    .modal-overlay.show .modal-content {
        transform: translateY(0);
        opacity: 1;
    }
    .modal-close-btn { 
        position: absolute;
        top: var(--spacing-md); 
        right: var(--spacing-md); 
        background: transparent; 
        color: var(--color-text-default); 
        border: none; 
        border-radius: 50%; 
        width: 44px;
        height: 44px; 
        font-size: 1.8rem;
        cursor: pointer;
        transition: background-color 0.3s ease, transform 0.3s ease;
    }
    .modal-close-btn:hover {
        background-color: var(--color-border-default);
        transform: rotate(90deg); 
    }

    #historyList { 
        display: flex; 
        flex-direction: column; 
        gap: var(--spacing-md);
        scroll-snap-type: y mandatory;
        overflow-y: auto;
        max-height: 70vh;
    }
    .history-item { 
        border: 1px solid var(--color-border-default);
        border-radius: var(--radius-base);
        padding: var(--spacing-md);
        display: flex; 
        justify-content: space-between; 
        align-items: center; 
        flex-wrap: wrap; 
        gap: var(--spacing-sm); 
        background: var(--color-surface-input);
        box-shadow: 0 3px 10px var(--shadow-sm); /* Using consolidated shadow variable */
        transition: box-shadow 0.3s ease, transform 0.2s ease;
        scroll-snap-align: start;
    }
    .history-item:hover { 
        box-shadow: 0 5px 15px var(--shadow-md); /* Using consolidated shadow variable */
        transform: translateY(-2px);
    }
    .history-item div:first-child {
        flex-grow: 1;
        font-size: 0.95rem;
    }
    .history-details { 
        width: 100%; 
        margin-top: var(--spacing-md);
        padding-top: var(--spacing-md); 
        border-top: 1px solid var(--color-border-default);
        max-height: 0;
        opacity: 0;
        overflow: hidden;
        transition: max-height 0.5s ease-in-out, opacity 0.5s ease-in-out, margin-top 0.5s ease-in-out;
    }
    .history-details.visible { 
        display: block; 
        max-height: 500px;
        opacity: 1;
    }
    .history-details ul {
        list-style: none;
        padding: 0;
        margin: var(--spacing-sm) 0 0 0;
    }
    .history-details li {
        padding: var(--spacing-xs) 0;
        border-bottom: 1px dashed var(--color-border-default);
    }
    .history-details li:last-child {
        border-bottom: none;
    }
    .progress-bar { 
        width: 100%;
        height: 10px;
        background: var(--color-border-default); 
        border-radius: 5px;
        overflow: hidden; 
        margin: var(--spacing-xl) 0;
    }
    .progress-fill { 
        height: 100%;
        background: var(--btn-success-bg); /* Using refactored gradient */
        border-radius: 5px; 
        transition: width 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    .hidden { display: none !important; }
    .show-notes-section {
        display: block !important;
    }
    .hide-notes-section {
        display: none !important;
    }

    .theme-switcher .btn {
        padding: var(--spacing-sm) var(--spacing-md);
        font-size: 1.5rem;
        border-radius: var(--radius-base);
        background: transparent; /* Arrière-plan transparent par défaut */
        color: var(--color-text-default); /* Couleur du texte par défaut */
        transition: background-color 0.3s ease, color 0.3s ease, box-shadow 0.2s ease;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        border: none;
        box-shadow: none; /* Aucune ombre par défaut */
    }

    body.dark-mode .theme-switcher .btn {
        background: var(--color-surface-muted); /* Fond subtil en mode sombre */
    }

    .theme-switcher .btn:hover {
        background-color: var(--color-border-default); /* Léger fond au survol */
        box-shadow: 0 2px 5px var(--shadow-sm); /* Ombre discrète au survol */
        transform: none; /* Suppression de l'effet de transformation */
    }

    .add-exercise-section {
        display: flex;
        justify-content: center; 
        gap: var(--spacing-md);
        margin-top: var(--spacing-xl); 
        padding: var(--spacing-lg); 
        background: hsla(0, 0%, 100%, 0.1); 
        border-radius: var(--radius-large); 
        position: relative; 
        align-items: center;
        box-shadow: 0 3px 8px var(--shadow-sm); /* Using consolidated shadow variable */
    }
    .add-exercise-section .input-group {
        display: flex;
        width: 100%;
        max-width: 500px;
        gap: var(--spacing-sm);
    }
    @media (max-width: 768px) {
        #autocompleteSuggestions {
            top: auto;
            bottom: 100%;
            left: 0;
            transform: translateX(0);
            width: 100%;
            max-width: 100%;
            margin-bottom: var(--spacing-xs);
            max-height: 150px;
            overflow-y: auto;
            border-radius: var(--radius-base);
            box-shadow: 0 -4px 10px var(--shadow-md); /* Using consolidated shadow variable */
        }
        .add-exercise-section {
            position: relative;
        }
        .add-exercise-section .input-group {
            position: relative;
            flex-direction: column-reverse;
        }
    }
    #autocompleteSuggestions.show {
        opacity: 1;
        visibility: visible;
    }
    #autocompleteSuggestions div {
        padding: var(--spacing-sm) var(--spacing-md);
        cursor: pointer;
        transition: background-color 0.2s ease;
    }
    #autocompleteSuggestions div:hover { 
        background-color: var(--color-border-default);
        color: var(--color-primary-default);
        font-weight: 600;
    }

    .btn-danger[data-action="remove"] {
        background: none;
        color: var(--color-danger-default);
        padding: var(--spacing-xs) var(--spacing-sm);
        border: none;
        font-size: 1.2rem; 
        opacity: 0.7;
        box-shadow: none;
    }
    .btn-danger[data-action="remove"]:hover {
        background: hsla(0, 60%, 80%, 0.15);
        color: var(--color-danger-default); 
        opacity: 1;
        transform: none;
        box-shadow: none;
    }
    .quick-edit-btn, .link-btn {
        background: none; border: none; font-size: 1rem; color: var(--color-info-default);
        cursor: pointer; padding: var(--spacing-xs); border-radius: var(--radius-xs); 
        transition: background-color 0.2s ease, opacity 0.2s ease;
        opacity: 0.8;
    }
    .quick-edit-btn:hover, .link-btn:hover { 
        background-color: hsla(200, 70%, 75%, 0.15);
        opacity: 1; 
        transform: none;
    }

    .link-btn.linking, 
    .link-btn.active-superset {
        background: var(--btn-info-bg); /* Using refactored gradient */
        color: var(--color-text-on-accent);
        opacity: 1;
    }
    .link-btn.active-superset:hover {
        background: linear-gradient(135deg, var(--color-info-gradient-end), var(--color-info-gradient-start));
    }

    .next-superset-exercise {
        animation: pulse-border 1.5s infinite;
        box-shadow: 0 0 10px 3px var(--color-info-default);
    }
    @keyframes pulse-border {
        0% { border-color: var(--color-info-default); }
        50% { border-color: transparent; }
        100% { border-color: var(--color-info-default); }
    }
    @keyframes pulse-row {
        0% {
            box-shadow: inset 0 2px 0 0 var(--color-success-default), inset 0 -2px 0 0 var(--color-success-default);
        }
        50% {
            box-shadow: inset 0 2px 0 0 transparent, inset 0 -2px 0 0 transparent;
        }
        100% {
            box-shadow: inset 0 2px 0 0 var(--color-success-default), inset 0 -2px 0 0 transparent;
        }
    }

    .modal-tabs {
        display: flex;
        border-bottom: 1px solid var(--color-border-default);
        margin-bottom: var(--spacing-lg);
    }
    .modal-tab-btn {
        padding: var(--spacing-sm) var(--spacing-lg);
        cursor: pointer;
        border: none;
        background-color: transparent;
        color: var(--color-text-default);
        font-weight: 600;
        border-bottom: 3px solid transparent;
        transition: color 0.3s ease, border-bottom-color 0.3s ease;
        flex-grow: 1;
    }
    .modal-tab-btn.active {
        color: var(--color-primary-default);
        border-bottom-color: var(--color-primary-default);
    }
    #goalResultsContainer {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: var(--spacing-lg);
        margin-top: var(--spacing-xl);
    }
    .goal-card {
        background-color: hsl(200, 80%, 95%);
        border: 1px solid hsl(200, 80%, 85%);
        border-radius: var(--radius-base);
        padding: var(--spacing-lg);
        text-align: center;
        box-shadow: 0 4px 10px var(--shadow-sm); /* Using consolidated shadow variable */
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        position: relative;
    }
    .goal-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 15px var(--shadow-md); /* Using consolidated shadow variable */
    }
    .goal-card h4 {
        margin: 0 0 var(--spacing-xs) 0;
        font-size: var(--font-size-lg);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-xs);
        color: var(--color-text-header);
    }
    .goal-card .icon {
        font-size: 1.6rem;
        color: var(--color-primary-default);
    }
    .goal-card .weight-range {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--color-success-default);
    }
    .goal-card .rep-range {
        font-size: 0.95rem;
        color: var(--color-text-subheader);
        opacity: 0.9;
        margin-top: var(--spacing-sm);
    }
    .goal-card.hypertrophy {
        background-color: hsl(200, 80%, 95%);
        border: 1px solid hsl(200, 80%, 85%);
    }
    .goal-card.strength {
        background-color: hsl(0, 70%, 95%);
        border: 1px solid hsl(0, 70%, 85%);
    }
    .goal-card.endurance {
        background-color: hsl(40, 90%, 95%);
        border: 1px solid hsl(40, 90%, 85%);
    }
    .goal-card.power {
        background-color: hsl(260, 70%, 95%);
        border: 1px solid hsl(260, 70%, 85%);
    }

    .plate-result-message {
        font-weight: bold;
        padding: var(--spacing-xs) var(--spacing-sm);
        border-radius: var(--radius-xs);
        display: inline-block;
        margin-top: var(--spacing-sm);
    }
    .plate-result-message.success {
        color: var(--color-text-on-accent);
        background: var(--btn-success-bg); /* Using refactored gradient */
    }
    .plate-result-message.danger {
        color: var(--color-text-on-accent);
        background: var(--btn-danger-bg); /* Using refactored gradient */
    }
    #platesResult h3 {
        font-size: var(--font-size-xl);
        margin-bottom: var(--spacing-sm);
        color: var(--color-text-header);
    }
    #platesResult p span {
        font-weight: 700;
        color: var(--color-primary-default);
    }
    #platesResult p span {
        background-color: var(--color-border-default);
        padding: 3px 6px;
        border-radius: 6px;
        font-weight: 600;
        font-size: 0.9em;
        color: var(--color-text-default);
        white-space: nowrap;
    }

    .tooltip {
        position: relative;
        display: inline-block;
    }
    .tooltip .tooltiptext {
        visibility: hidden;
        background-color: var(--color-text-header);
        color: var(--color-text-on-accent);
        text-align: center;
        border-radius: 6px;
        padding: 5px 10px;
        position: absolute;
        z-index: 1;
        bottom: 125%;
        left: 50%;
        margin-inline-start: -60px; /* Logical property */
        opacity: 0;
        transition: opacity 0.3s;
        font-size: 0.8rem;
        width: 120px;
    }
    .tooltip .tooltiptext::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        margin-inline-start: -5px; /* Logical property */
        border-width: 5px;
        border-style: solid;
        border-color: var(--color-text-header) transparent transparent transparent;
    }
    .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
    }

    #pwaInstallPrompt {
        position: fixed;
        bottom: var(--spacing-xxl);
        left: 50%;
        transform: translateX(-50%);
        background: var(--btn-primary-bg); /* Using refactored gradient */
        color: var(--color-text-on-accent);
        padding: var(--spacing-md) var(--spacing-lg);
        border-radius: var(--radius-button);
        box-shadow: 0 5px 15px var(--shadow-md); /* Using consolidated shadow variable */
        display: flex;
        align-items: center;
        gap: var(--spacing-md);
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    #pwaInstallPrompt.show {
        opacity: 1;
        visibility: visible;
    }
    #pwaInstallPrompt button {
        background: var(--color-text-on-accent);
        color: var(--color-primary-default);
        border: none;
        padding: var(--spacing-xs) var(--spacing-sm);
        border-radius: var(--radius-base);
        font-weight: 600;
        cursor: pointer;
        transition: opacity 0.2s ease;
    }
    #pwaInstallPrompt button:hover {
        opacity: 0.9;
    }
    #pwaInstallPrompt .close-btn {
        background: none;
        color: var(--color-text-on-accent);
        font-size: 1.2rem;
        opacity: 0.7;
    }
    #pwaInstallPrompt .close-btn:hover {
        opacity: 1;
    }


    .bottom-navigation {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        background: var(--color-surface-default);
        box-shadow: 0 -5px 15px var(--shadow-md); /* Using consolidated shadow variable */
        display: flex;
        justify-content: space-around;
        align-items: center;
        padding: var(--spacing-sm) var(--spacing-xs);
        z-index: 999;
        border-top-left-radius: var(--radius-large);
        border-top-right-radius: var(--radius-large);
        padding-bottom: env(safe-area-inset-bottom, var(--spacing-sm));
        height: 70px;
    }
    .bottom-navigation .btn {
        flex: 1;
        margin: 0 var(--spacing-xxs);
        padding: var(--spacing-sm);
        font-size: 0.9rem;
        border-radius: var(--radius-medium);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-xxs);
        color: var(--color-text-default);
        background: none;
        box-shadow: none;
        transition: background-color 0.2s ease, color 0.2s ease, transform 0.2s ease;
    }
    .bottom-navigation .btn i {
        font-size: 1.2rem;
        color: var(--color-text-subheader);
    }
    .bottom-navigation .btn span {
        font-size: 0.75rem;
        font-weight: 500;
    }
    .bottom-navigation .btn:hover {
        background-color: var(--color-border-default);
        transform: translateY(-2px);
    }
    .bottom-navigation .btn-active {
        color: var(--color-primary-default);
        background: hsla(220, 60%, 75%, 0.1);
    }
    .bottom-navigation .btn-active i {
        color: var(--color-primary-default);
    }

    @media (min-width: 769px) {
        .exercise-list-container .mobile-cards {
            display: none !important;
        }
        .bottom-navigation {
            display: none !important;
        }
        body {
            padding-bottom: var(--spacing-xxl);
        }
        .session-notes-section {
            display: block !important;
        }
    }

    @media (max-width: 768px) {
        body { 
            padding: var(--spacing-lg); 
            padding-bottom: calc(var(--spacing-lg) + 70px);
        }
        .main-container { 
            padding: var(--spacing-lg); 
            border-radius: var(--radius-base); 
        }
        h2 { 
            margin-bottom: var(--spacing-xl); 
        }
        .controls, .add-exercise-section { 
            flex-direction: column; 
            align-items: stretch; 
            gap: var(--spacing-md);
        }
        .controls label, .controls input, .controls select, .add-exercise-section .input-group, .add-exercise-section button {
            max-width: 100%;
            width: 100%;
        }
        .add-exercise-section .input-group { flex-direction: column; }
        .add-exercise-section .input-group input, .add-exercise-section .input-group button { width: 100%; }

        #autocompleteSuggestions {
            top: auto;
            bottom: 100%;
            left: 0;
            transform: translateX(0);
            width: 100%;
            max-width: 100%;
            margin-bottom: var(--spacing-xs);
            max-height: 150px;
            overflow-y: auto;
            border-radius: var(--radius-base);
            box-shadow: 0 -4px 10px var(--shadow-md); /* Using consolidated shadow variable */
        }
        .add-exercise-section {
            position: relative;
        }
        .add-exercise-section .input-group {
            position: relative;
            flex-direction: column-reverse;
        }

        .exercise-list-container .desktop-table {
            display: none; 
        }
        .exercise-list-container .mobile-cards {
            display: flex;
        }

        .action-buttons { 
            display: flex;
            margin-top: var(--spacing-xl);
            justify-content: center;
            flex-wrap: wrap;
            gap: var(--spacing-md);
        }
        .action-buttons .btn {
            width: calc(50% - var(--spacing-sm));
            padding: var(--spacing-sm) var(--spacing-md);
            font-size: 0.9rem;
        }
        .action-buttons .btn i {
            font-size: 1.1rem;
        }

        .notification { 
            width: calc(100% - var(--spacing-lg) * 2);
            left: var(--spacing-lg); 
            right: var(--spacing-lg); 
            top: var(--spacing-md); 
        }
        .modal-content { 
            width: calc(100% - var(--spacing-md) * 2);
            margin: var(--spacing-sm); 
            padding: var(--spacing-lg); 
            border-radius: var(--radius-base); 
        }
        .summary-section {
            grid-template-columns: 1fr;
            gap: var(--spacing-md);
        }
        .summary-card {
            /* Remove mobile-specific border styles for consistency */
            /* border-left: none; */
            /* border-bottom: 5px solid var(--color-primary-default); */
            padding: var(--spacing-md);
            /* Ensure it inherits or explicitly sets the standard border and shadow */
            border: 1px solid var(--color-border-default);
            box-shadow: 0 4px 10px var(--shadow-md); /* Using consolidated shadow variable */
        }
    }
    @media (max-width: 480px) {
        body {
            padding: var(--spacing-md);
            padding-bottom: calc(var(--spacing-md) + 70px);
        }
        .main-container {
            padding: var(--spacing-md);
        }
    }
} /* End @layer components */

@layer utilities {
    /* Utility Classes */
    .flex-center {
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
    }

    /* Tâche 2.3: Classes utilitaires pour icônes colorées */
    .icon-primary { color: var(--color-primary-default); }
    .icon-success { color: var(--color-success-default); }
    .icon-warning { color: var(--color-warning-default); }
    .icon-danger { color: var(--color-danger-default); }
    .icon-info { color: var(--color-info-default); }
} /* End @layer utilities */

/* Correction du contraste pour les boutons de la vue mobile */
.exercise-card .btn-outline {
    font-weight: 600; /* Rend le texte du contour plus gras et lisible */
}

.exercise-card .btn-info,
.exercise-card .btn-secondary {
    color: hsl(220, 25%, 25%); /* Assombrit le texte pour un meilleur contraste en mode clair */
}

/* Amélioration du contraste pour le mode sombre également */
body.dark-mode .exercise-card .btn-info,
body.dark-mode .exercise-card .btn-secondary {
     color: hsl(0, 0%, 95%);
}

    </style>
</head>
<body>
    <main class="main-container">
        <div class="theme-switcher">
            <button id="themeToggleBtn" aria-label="Changer de thème"></button>
        </div>
        <h2>
            <svg class="lyftiv-logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <linearGradient id="lyftivLogoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" stop-color="hsl(200, 80%, 85%)" />
                        <stop offset="100%" stop-color="hsl(260, 60%, 85%)" />
                    </linearGradient>
                </defs>
                <rect x="0" y="0" width="100" height="100" rx="20" ry="20" fill="url(#lyftivLogoGradient)"/>
                <path d="M 15 50 C 15 35 30 30 50 30 C 70 30 85 35 85 50 C 85 65 70 70 50 70 C 30 70 15 65 15 50 Z M 25 50 L 75 50 M 25 35 L 25 65 M 75 35 L 75 65" stroke="hsl(220, 60%, 55%)" stroke-width="3.5" fill="none" stroke-linecap="round"/>
                <circle cx="25" cy="50" r="14" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                <circle cx="25" cy="50" r="10" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                <circle cx="25" cy="50" r="6" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                <circle cx="75" cy="50" r="14" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                <circle cx="75" cy="50" r="10" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                <circle cx="75" cy="50" r="6" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                <rect x="35" y="48.5" width="30" height="3" rx="1.5" ry="1.5" fill="white"/>
            </svg>
            Lyftiv
        </h2>
        
        <div class="controls">
          <label for="sessionSelect"><strong>Séance:</strong></label>
          <select id="sessionSelect" aria-label="Sélectionner une séance d'entraînement">
            </select>
          <button class="btn btn-outline" id="createNewSessionTypeBtn" aria-label="Créer une nouvelle séance">Nouvelle séance</button>
          <button class="btn btn-danger" id="deleteCurrentSessionBtn" aria-label="Supprimer la séance actuelle" title="Supprimer la séance actuelle (personnalisée)">Supprimer la séance</button>
        </div>
        
        <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" id="progressBar" aria-label="Progression de la séance">
          <div class="progress-fill" id="progressFill"></div>
        </div>
        
        <div id="exerciseListContainer" class="exercise-list-container">
            </div>
        
        <section class="controls add-exercise-section" id="addExerciseSection" aria-labelledby="addExerciseTitle">
            <h2 id="addExerciseTitle" class="sr-only">Ajouter un exercice</h2>
            <div class="input-group">
                <input type="text" id="customExercise" placeholder="Ajouter un exercice" aria-label="Nom de l'exercice personnalisé">
                <button class="btn btn-success" id="addExerciseBtn" aria-label="Ajouter l'exercice"> Ajouter</button>
            </div>
        </section>

        <section class="summary-section" aria-labelledby="summarySectionTitle">
            <h2 id="summarySectionTitle" class="sr-only">Résumé de la séance</h2>
            <div class="summary-card">
                <span class="card-icon fas fa-dumbbell" aria-hidden="true"></span>
                <h3>Total kg/rép</h3> <div class="value" id="totalKgRep" aria-live="polite">0 kg/rep</div> </div>
            <div class="summary-card">
                <span class="card-icon fas fa-calendar-alt" aria-hidden="true"></span>
                <h3>Semaine précédente</h3>
                <input type="text" inputmode="decimal" id="previousWeek" placeholder="kg/rep" aria-label="Performance de la semaine précédente">
            </div>
            <div class="summary-card">
                <span class="card-icon fas fa-chart-line" aria-hidden="true"></span>
                <h3>Progression</h3>
                <div class="value" id="delta" aria-live="polite">0 kg</div>
            </div>
            <div class="summary-card">
                <span class="card-icon fas fa-clock" aria-hidden="true"></span>
                <h3>Temps total</h3>
                <div class="value" id="totalTime" aria-live="polite">00:00:00</div>
                <button id="toggleWorkoutTimerBtn" class="btn btn-secondary" aria-label="Mettre en pause ou reprendre le minuteur" style="margin-top: var(--spacing-sm);">
                    <span id="timerPlayPauseIcon" aria-hidden="true">⏯️</span>
                    <span id="timerPlayPauseText">Pause</span>
                </button>
            </div>
        </section>

        <section class="controls session-notes-section" id="sessionNotesSection" aria-labelledby="sessionNotesTitle">
            <h2 id="sessionNotesTitle" class="sr-only">Notes de séance</h2>
            <label for="sessionNotes"><strong>Notes de séance:</strong></label>
            <textarea id="sessionNotes" placeholder="Ajouter des notes sur la séance..." aria-label="Notes de séance"></textarea>
        </section>
        
        <section class="action-buttons" aria-labelledby="actionButtonsTitle">
            <h2 id="actionButtonsTitle" class="sr-only">Actions principales</h2>
            <button class="btn btn-success" id="finishSessionBtn" aria-label="Terminer et Sauvegarder la séance">Terminer & sauvegarder</button>
            <button class="btn btn-primary" id="viewHistoryBtn" aria-label="Voir l'historique">Historique</button>
            <button class="btn btn-primary" id="plateCalculatorBtn" aria-label="Ouvrir les calculateurs">Calculateurs</button>
        </section>

        <section class="action-buttons" style="margin-top: var(--spacing-md);" aria-labelledby="dataManagementTitle">
            <h2 id="dataManagementTitle" class="sr-only">Gestion des données</h2>
            <button class="btn btn-info" id="exportBtn" aria-label="Exporter les données">Exporter</button>
            <button class="btn btn-info" id="importBtn" aria-label="Importer les données">Importer</button>
        </section>
        <input type="file" id="importFile" class="hidden" accept=".json,.csv" aria-label="Fichier d'importation">
    </main> <div id="notification-container" aria-live="polite" aria-atomic="true"></div>
    
    <div id="pwaInstallPrompt" class="hidden" role="dialog" aria-modal="true" aria-labelledby="pwaInstallTitle">
        <span id="pwaInstallTitle" style="font-weight: 600;">Ajoutez Lyftiv à votre écran d'accueil !</span>
        <button id="installPwaBtn" aria-label="Installer l'application">Installer</button>
        <button id="closePwaPrompt" class="close-btn" aria-label="Fermer le message d'installation">&times;</button>
    </div>

    <div id="historyModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="historyModalTitle">
      <div class="modal-content">
          <button id="closeHistoryModal" class="modal-close-btn" aria-label="Fermer le modal historique">&times;</button>
          <h2 id="historyModalTitle">Historique des séances</h2>
          <div id="historyList" aria-live="polite"></div>
      </div>
    </div>

    <div id="newSessionModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="newSessionModalTitle">
        <div class="modal-content">
            <button id="closeNewSessionModal" class="modal-close-btn" aria-label="Fermer le modal de nouvelle séance">&times;</button>
            <h2 id="newSessionModalTitle">Créer une nouvelle séance</h2>
            <div class="input-group-modal">
                <input type="text" id="newSessionNameInput" placeholder="Nom de la nouvelle séance" aria-label="Nom de la nouvelle séance">
                <div id="newSessionNameError" class="error-message"></div>
            </div>
            <div style="display: flex; justify-content: center; gap: var(--spacing-md); margin-top: var(--spacing-lg);">
                <button class="btn btn-outline" id="cancelNewSessionBtn"> Annuler</button>
                <button class="btn btn-success" id="createNewSessionBtn"> Créer</button>
            </div>
        </div>
    </div>

    <div id="loadOptionsModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="loadOptionsModalTitle">
      <div class="modal-content">
          <button id="closeLoadOptionsModal" class="modal-close-btn" aria-label="Fermer le modal d'options de chargement">&times;</button>
          <h2 id="loadOptionsModalTitle">Options de chargement</h2>
          <p>Comment utiliser la séance "<strong id="loadSessionName"></strong>" ?</p>
          <div style="display: flex; justify-content: center; gap: var(--spacing-md); margin-top: var(--spacing-lg);">
              <button class="btn btn-primary" id="openNewSessionBtn">Ouvrir (remplace la séance actuelle)</button>
              <button class="btn btn-secondary" id="appendToCurrentSessionBtn">Ajouter à la séance actuelle</button>
          </div>
      </div>
    </div>

    <div id="plateCalculatorModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="plateCalcModalTitle">
        <div class="modal-content">
            <button id="closePlateCalculatorModal" class="modal-close-btn" aria-label="Fermer le modal du calculateur de plaques">&times;</button>
            <div class="modal-tabs" role="tablist">
                <button class="modal-tab-btn" id="plateCalcTab" aria-controls="plateCalcContent" role="tab" aria-selected="false">Calculateur de plaques</button>
                <button class="modal-tab-btn active" id="goalCalcTab" aria-controls="goalCalcContent" role="tab" aria-selected="true">Objectifs d'entraînement</button>
            </div>
            
            <div id="plateCalcContent" class="modal-tab-content hidden" role="tabpanel" aria-labelledby="plateCalcTab">
                <h2 id="plateCalcModalTitle">Calculateur de plaques</h2>
                <div class="controls">
                    <div class="input-group-modal">
                        <input type="text" inputmode="decimal" id="targetWeightInput" placeholder="Poids cible (kg)" aria-label="Poids cible">
                        <div id="targetWeightError" class="error-message"></div>
                    </div>
                    <div class="input-group-modal">
                        <input type="text" inputmode="decimal" id="barbellWeightInput" placeholder="Poids barre (kg)" aria-label="Poids de la barre">
                        <div id="barbellWeightError" class="error-message"></div>
                    </div>
                </div>
                <div id="platesResult" style="text-align: left; margin-top: var(--spacing-lg);"></div>
            </div>

            <div id="goalCalcContent" class="modal-tab-content" role="tabpanel" aria-labelledby="goalCalcTab">
                <h2>Objectifs d'entraînement</h2>
                <div class="controls">
                    <div style="display: flex; justify-content: center; gap: var(--spacing-md); margin-bottom: var(--spacing-md);">
                        <label>
                            <input type="radio" name="oneRmInputMode" value="manual" checked> Saisie Manuelle
                        </label>
                        <label>
                            <input type="radio" name="oneRmInputMode" value="select"> Sélection d'Exercice
                        </label>
                    </div>

                    <div id="oneRmManualInput" class="input-group-modal">
                        <input type="text" inputmode="decimal" id="oneRmInput" placeholder="Votre 1RM (kg)" aria-label="Votre 1RM">
                        <div id="oneRmError" class="error-message"></div>
                    </div>

                    <div id="oneRmSelectInput" class="input-group-modal hidden">
                        <select id="oneRmExerciseSelect" aria-label="Sélectionner un exercice pour le 1RM">
                            <option value="">-- Sélectionner un exercice --</option>
                        </select>
                    </div>
                </div>
                <div id="goalResultsContainer"></div>
            </div>
        </div>
    </div>
    
    <div id="quickEditModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="quickEditModalTitle">
      <div class="modal-content">
          <button id="closeQuickEditModal" class="modal-close-btn" aria-label="Fermer le modal d'édition rapide">&times;</button>
          <h2 id="quickEditModalTitle">Édition rapide</h2>
          <p>Appliquer à toutes les séries de : <strong id="quickEditExerciseName"></strong></p>
          <div class="controls">
              <div class="input-group-modal">
                  <input type="text" inputmode="decimal" id="quickEditWeight" placeholder="Poids (kg)" aria-label="Poids pour édition rapide">
                  <div id="quickEditWeightError" class="error-message"></div>
              </div>
              <div class="input-group-modal">
                  <input type="text" inputmode="decimal" id="quickEditReps" placeholder="Reps" aria-label="Répétitions pour édition rapide">
                  <div id="quickEditRepsError" class="error-message"></div>
              </div>
          </div>
          <button class="btn btn-success" id="applyQuickEditBtn" style="width: 100%; margin-top: var(--spacing-md);"> Appliquer</button>
      </div>
    </div>

    <nav class="bottom-navigation" aria-label="Navigation principale">
        <button class="btn btn-primary" id="bottomAddExerciseBtn" aria-label="Ajouter un exercice">
            <i class="fas fa-plus-circle"></i>
            <span>Exercice</span>
        </button>
        <button class="btn btn-primary" id="bottomNotesBtn" aria-label="Notes de séance">
            <i class="fas fa-clipboard"></i>
            <span>Notes</span>
        </button>
        <button class="btn btn-primary" id="bottomViewHistoryBtn" aria-label="Historique">
            <i class="fas fa-history"></i>
            <span>Historique</span>
        </button>
        <button class="btn btn-primary" id="bottomPlateCalculatorBtn" aria-label="Calculateurs">
            <i class="fas fa-calculator"></i>
            <span>Calculs</span>
        </button>
        <button class="btn btn-primary" id="bottomScrollBtn" aria-label="Faire défiler la page">
            <i class="fas fa-arrows-alt-v"></i>
            <span>Défiler</span>
        </button>
    </nav>

    <script>
    // Service Worker registration is commented out to prevent potential issues in some environments.
    // if ('serviceWorker' in navigator) {
    //   window.addEventListener('load', () => {
    //     navigator.serviceWorker.register('/service-worker.js')
    //       .then(registration => console.log('ServiceWorker registration successful'))
    //       .catch(err => console.log('ServiceWorker registration failed: ', err));
    //   });
    // }

    window.addEventListener('load', () => {
        
        function init() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                applyTheme(savedTheme);
            } else {
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');
                applyTheme(prefersDark.matches ? 'dark' : 'light');
                prefersDark.addEventListener('change', (e) => {
                    if (!localStorage.getItem('theme')) {
                        applyTheme(e.matches ? 'dark' : 'light');
                    }
                });
            }
            
            const inProgress = JSON.parse(localStorage.getItem('inProgressWorkout'));
            if (inProgress && inProgress.customSessions && inProgress.customSessions[inProgress.sessionIndex] && inProgress.customSessions[inProgress.sessionIndex].exercises.length > 0) {
                state.sessions = Array.isArray(inProgress.customSessions) ? inProgress.customSessions : JSON.parse(JSON.stringify(defaultSessions));
                state.currentSessionIndex = inProgress.sessionIndex || 0;
                if (state.currentSessionIndex >= state.sessions.length) {
                    state.currentSessionIndex = 0;
                }
                
                state.workoutStartTime = inProgress.workoutStartTime || null;
                state.isWorkoutTimerPaused = inProgress.isWorkoutTimerPaused;
                state.pausedTime = inProgress.pausedTime || 0;
                
                if (state.workoutStartTime && !state.isWorkoutTimerPaused) {
                    const elapsedSinceSave = (Date.now() - (inProgress.saveTimestamp || new Date(state.workoutStartTime).getTime())) / 1000;
                    state.pausedTime = (inProgress.pausedTime || 0) + elapsedSinceSave;
                    startTotalWorkoutTimer();
                } else if (state.workoutStartTime) {
                    dom.totalTimeEl.textContent = formatTime(state.pausedTime);
                    dom.timerPlayPauseIcon.textContent = '▶️';
                    dom.timerPlayPauseText.textContent = 'Play';
                }
            } else {
                 state.sessions = JSON.parse(JSON.stringify(defaultSessions));
                 localStorage.removeItem('inProgressWorkout');
            }
            
            if (state.isMobileView) {
                dom.sessionNotesSection.classList.add('hide-notes-section');
                state.isNotesSectionVisible = false;
            } else {
                dom.sessionNotesSection.classList.add('show-notes-section');
                state.isNotesSectionVisible = true;
            }

            updateSessionSelectOptions(); 
            dom.sessionSelect.value = state.currentSessionIndex;
            createTable();
            setupEventListeners();
            loadPersistentIndividualTimers();

            window.addEventListener('resize', () => {
                const newIsMobileView = window.matchMedia("(max-width: 768px)").matches;
                if (newIsMobileView !== state.isMobileView) {
                    state.isMobileView = newIsMobileView;
                    createTable();
                    if (state.isMobileView && !state.isNotesSectionVisible) {
                        dom.sessionNotesSection.classList.add('hide-notes-section');
                    } else {
                        dom.sessionNotesSection.classList.remove('hide-notes-section');
                        dom.sessionNotesSection.classList.add('show-notes-section');
                    }
                }
            });

            state.isInitialized = true;
        }

        const dom = {
            sessionSelect: document.getElementById('sessionSelect'),
            exerciseListContainer: document.getElementById('exerciseListContainer'),
            totalKgRepEl: document.getElementById('totalKgRep'),
            previousWeekInput: document.getElementById('previousWeek'),
            deltaEl: document.getElementById('delta'),
            totalTimeEl: document.getElementById('totalTime'),
            progressFill: document.getElementById('progressFill'),
            historyModal: document.getElementById('historyModal'),
            closeHistoryModal: document.getElementById('closeHistoryModal'),
            notificationContainer: document.getElementById('notification-container'),
            customExerciseInput: document.getElementById('customExercise'),
            addExerciseBtn: document.getElementById('addExerciseBtn'),
            historyList: document.getElementById('historyList'),
            importFileInput: document.getElementById('importFile'),
            themeToggleBtn: document.getElementById('themeToggleBtn'),
            body: document.body,
            toggleWorkoutTimerBtn: document.getElementById('toggleWorkoutTimerBtn'),
            newSessionModal: document.getElementById('newSessionModal'),
            closeNewSessionModal: document.getElementById('closeNewSessionModal'),
            newSessionNameInput: document.getElementById('newSessionNameInput'),
            cancelNewSessionBtn: document.getElementById('cancelNewSessionBtn'),
            createNewSessionBtn: document.getElementById('createNewSessionBtn'),
            createNewSessionTypeBtn: document.getElementById('createNewSessionTypeBtn'),
            deleteCurrentSessionBtn: document.getElementById('deleteCurrentSessionBtn'),
            loadOptionsModal: document.getElementById('loadOptionsModal'),
            closeLoadOptionsModal: document.getElementById('closeLoadOptionsModal'),
            loadSessionNameDisplay: document.getElementById('loadSessionName'),
            openNewSessionBtn: document.getElementById('openNewSessionBtn'),
            appendToCurrentSessionBtn: document.getElementById('appendToCurrentSessionBtn'),
            autocompleteSuggestions: document.getElementById('autocompleteSuggestions'),
            plateCalculatorModal: document.getElementById('plateCalculatorModal'),
            closePlateCalculatorModal: document.getElementById('closePlateCalculatorModal'),
            plateCalculatorBtn: document.getElementById('plateCalculatorBtn'),
            targetWeightInput: document.getElementById('targetWeightInput'),
            barbellWeightInput: document.getElementById('barbellWeightInput'),
            platesResult: document.getElementById('platesResult'),
            sessionNotesInput: document.getElementById('sessionNotes'),
            addExerciseSection: document.getElementById('addExerciseSection'),
            quickEditModal: document.getElementById('quickEditModal'),
            closeQuickEditModal: document.getElementById('closeQuickEditModal'),
            quickEditExerciseName: document.getElementById('quickEditExerciseName'),
            quickEditWeight: document.getElementById('quickEditWeight'),
            quickEditReps: document.getElementById('quickEditReps'),
            applyQuickEditBtn: document.getElementById('applyQuickEditBtn'),
            plateCalcTab: document.getElementById('plateCalcTab'),
            goalCalcTab: document.getElementById('goalCalcTab'),
            plateCalcContent: document.getElementById('plateCalcContent'),
            goalCalcContent: document.getElementById('goalCalcContent'),
            oneRmInput: document.getElementById('oneRmInput'),
            oneRmManualInput: document.getElementById('oneRmManualInput'),
            oneRmSelectInput: document.getElementById('oneRmSelectInput'),
            oneRmExerciseSelect: document.getElementById('oneRmExerciseSelect'),
            goalResultsContainer: document.getElementById('goalResultsContainer'),
            timerPlayPauseIcon: document.getElementById('timerPlayPauseIcon'),
            timerPlayPauseText: document.getElementById('timerPlayPauseText'),
            bottomAddExerciseBtn: document.getElementById('bottomAddExerciseBtn'),
            bottomScrollBtn: document.getElementById('bottomScrollBtn'),
            bottomViewHistoryBtn: document.getElementById('bottomViewHistoryBtn'),
            bottomPlateCalculatorBtn: document.getElementById('bottomPlateCalculatorBtn'),
            bottomNotesBtn: document.getElementById('bottomNotesBtn'),
            sessionNotesSection: document.getElementById('sessionNotesSection'),
            exportBtn: document.getElementById('exportBtn'),
            importBtn: document.getElementById('importBtn'),
            newSessionNameError: document.getElementById('newSessionNameError'),
            targetWeightError: document.getElementById('targetWeightError'),
            barbellWeightError: document.getElementById('barbellWeightError'),
            oneRmError: document.getElementById('oneRmError'),
            quickEditWeightError: document.getElementById('quickEditWeightError'),
            quickEditRepsError: document.getElementById('quickEditRepsError'),
            progressBar: document.getElementById('progressBar'),
            pwaInstallPrompt: document.getElementById('pwaInstallPrompt'),
            installPwaBtn: document.getElementById('installPwaBtn'),
            closePwaPrompt: document.getElementById('closePwaPrompt')
        };

        let state = {
            sessions: [], 
            currentSessionIndex: 0,
            timers: {},
            workoutStartTime: null,
            totalWorkoutTimeInterval: null,
            isWorkoutTimerPaused: false,
            pausedTime: 0,
            sessionToLoad: null,
            availableExercises: [],
            lastDeletedExercise: null,
            inactivityTimeout: null, 
            autoSaveInterval: null, 
            linkingState: { active: false, fromIndex: null }, 
            quickEditIndex: null,
            isMobileView: window.matchMedia("(max-width: 768px)").matches,
            isNotesSectionVisible: false,
            deferredPwaPrompt: null,
            isInitialized: false,
            pressTimer: null
        };
        
        // Point 2: Added isDefault property to default sessions
        const defaultSessions = [
          {
            name: "Haut du Corps (Force)", isDefault: true,
            exercises: [
              { name: "Tractions scapulaires", rest: "60s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Développé couché barre", rest: "120s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Machine élévations latérales debout", rest: "", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Tractions", rest: "90s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Développé incliné haltères", rest: "", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Rowing T-barre appuyé", rest: "90s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Pec Deck", rest: "", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Bayesian Cable Curl", rest: "75s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Extension triceps à la poulie haute", rest: "", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] }
            ]
          },
          {
            name: "Bas du Corps (Force)", isDefault: true,
            exercises: [
              { name: "Soulevé de terre roumain (RDL)", rest: "120s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Hip thrust", rest: "120s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Hack squat", rest: "180s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Fentes bulgares", rest: "90s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Mollets debout", rest: "60s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] }
            ]
          },
          {
            name: "Haut du Corps (Hypertrophie & Poigne)", isDefault: true,
            exercises: [
              { name: "Dips", rest: "90s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Tirage vertical prise large", rest: "", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Écarté incliné aux poulies", rest: "75s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Face Pull", rest: "", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Élévations latérales à la poulie", rest: "60s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Curl pupitre", rest: "75s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Extension triceps overhead", rest: "", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Flexions poignets supination", rest: "60s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Extensions de poignets pronation", rest: "", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Farmer’s Walk", rest: "90s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Planche", rest: "", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] }
            ]
          },
          {
            name: "Bas du Corps (Hypertrophie & Focus Ischios/Fessiers)", isDefault: true,
            exercises: [
              { name: "Pendulum Squat", rest: "90s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Hip thrust", rest: "90s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Leg curl assis", rest: "75s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Mollets assis", rest: "60s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Glute Ham Raise", rest: "", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Circuit abdos (relevé de jambe, crunches, planche)", rest: "90s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] }
            ]
          },
          {
            name: "Trapèzes & Mobilité ", isDefault: true,
            exercises: [
              { name: "Barbell Shrugs", rest: "60s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Face Pull", rest: "60s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Cable Y-Raise", rest: "60s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] },
              { name: "Dead Hang", rest: "60s", series: [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}] }
            ]
          },
          {
            name: "Routine Mobilité", isDefault: true,
            exercises: [
              { name: "Pass-throughs avec élastique", rest: "", series: ["2 x 15"] },
              { name: "Wall Slides (Glissements au mur)", rest: "", series: ["2 x 12"] },
              { name: "Cercles de tête lents", rest: "", series: ["1 x 5 dans chaque sens"] },
              { name: "Rétraction du menton", rest: "", series: ["2 x 10"] },
              { name: "90/90 Stretch", rest: "", series: ["2 x 30s par côté"] },
              { name: "Étirement du canapé (Couch Stretch)", rest: "", series: ["2 x 30s par côté"] },
              { name: "Maintien en Squat Profond", rest: "", series: ["2 x 45-60s"] }
            ]
          }
        ];
        
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            state.deferredPwaPrompt = e;
            if (localStorage.getItem('pwaPromptDismissed') !== 'true') {
                dom.pwaInstallPrompt.classList.remove('hidden');
                setTimeout(() => dom.pwaInstallPrompt.classList.add('show'), 10);
            }
        });

        dom.installPwaBtn.addEventListener('click', async () => {
            if (state.deferredPwaPrompt) {
                state.deferredPwaPrompt.prompt();
                const { outcome } = await state.deferredPwaPrompt.userChoice;
                if (outcome === 'accepted') {
                    showNotification('Lyftiv a été ajouté à votre écran d\'accueil!', 'success', 5000);
                }
                state.deferredPwaPrompt = null;
                dom.pwaInstallPrompt.classList.remove('show');
                dom.pwaInstallPrompt.addEventListener('transitionend', () => dom.pwaInstallPrompt.classList.add('hidden'), { once: true });
            }
        });

        dom.closePwaPrompt.addEventListener('click', () => {
            dom.pwaInstallPrompt.classList.remove('show');
            dom.pwaInstallPrompt.addEventListener('transitionend', () => dom.pwaInstallPrompt.classList.add('hidden'), { once: true });
            localStorage.setItem('pwaPromptDismissed', 'true');
        });
        
        function validateInputField(inputElement, errorDisplayElement, allowEmpty = false) {
            const value = inputElement.value.trim();
            if (allowEmpty && value === '') {
                inputElement.classList.remove('is-invalid');
                errorDisplayElement.textContent = '';
                return true;
            }
            const regex = /^\d+(\.\d{1,2})?$/;
            if (!regex.test(value) || parseFloat(value) < 0) {
                inputElement.classList.add('is-invalid');
                errorDisplayElement.textContent = 'Veuillez entrer un nombre positif valide.';
                return false;
            } else {
                inputElement.classList.remove('is-invalid');
                errorDisplayElement.textContent = '';
                return true;
            }
        }

        function handleNumericInput(e) {
            const input = e.target;
            let value = input.value.replace(/,/g, '.');
            const segments = value.split('+').map(s => s.trim());
            const validatedSegments = segments.filter(s => {
                if (s === '') return true;
                const num = parseFloat(s);
                return !isNaN(num) && num >= 0;
            });
            input.value = validatedSegments.join('+');
        }

        function getPlateCombinationOptimal(target, denominations) {
            let currentRemaining = target;
            const platesUsed = {};
            let loadedWeight = 0;
            for (const plateValue of denominations) {
                const numPlates = Math.floor(currentRemaining / plateValue);
                if (numPlates > 0) {
                    platesUsed[plateValue] = numPlates;
                    loadedWeight += numPlates * plateValue;
                    currentRemaining -= (numPlates * plateValue);
                    currentRemaining = parseFloat(currentRemaining.toFixed(2)); 
                }
            }
            return { plates: platesUsed, loadedWeight: loadedWeight, remaining: currentRemaining };
        }

        function getPlateCombinationAlternative(target, fullDenominations) {
            let currentRemaining = target;
            const platesUsed = {};
            const alternativeOrder = [20, 10, 5, 2.5, 1.25, 0.5, 0.25]; 
            const availableAlternativeOrder = fullDenominations.filter(p => alternativeOrder.includes(p));
            availableAlternativeOrder.sort((a, b) => b - a);

            for (const plateValue of availableAlternativeOrder) {
                if (currentRemaining <= 0) break; 
                const numPlates = Math.floor(currentRemaining / plateValue);
                if (numPlates > 0) {
                    platesUsed[plateValue] = (platesUsed[plateValue] || 0) + numPlates;
                    currentRemaining -= numPlates * plateValue;
                    currentRemaining = parseFloat(currentRemaining.toFixed(2)); 
                }
            }
            let loadedWeight = target - currentRemaining; 
            return { plates: platesUsed, loadedWeight: loadedWeight, remaining: currentRemaining };
        }


        function formatPlatesWithPlus(platesObject) {
            let formatted = [];
            const sortedPlateValues = Object.keys(platesObject).map(Number).sort((a, b) => b - a);
            for (const plateValue of sortedPlateValues) {
                if (platesObject[plateValue] > 0) {
                    formatted.push(`<span>${plateValue}kg x${platesObject[plateValue]}</span>`); 
                }
            }
            return formatted.length > 0 ? formatted.join(' + ') : 'Aucun';
        }
        
        function calculatePlates() {
            const targetValid = validateInputField(dom.targetWeightInput, dom.targetWeightError);
            const barbellValid = validateInputField(dom.barbellWeightInput, dom.barbellWeightError); 

            if (!targetValid || !barbellValid) {
                dom.platesResult.innerHTML = `<p class="plate-result-message danger">Veuillez corriger les erreurs dans les poids.</p>`;
                return;
            }

            const targetWeight = parseFloat(dom.targetWeightInput.value);
            const barbellWeight = parseFloat(dom.barbellWeightInput.value);
            
            if (barbellWeight > targetWeight) {
                dom.targetWeightInput.classList.add('is-invalid');
                dom.targetWeightError.textContent = 'Le poids cible doit être supérieur ou égal au poids de la barre.';
                dom.platesResult.innerHTML = `<p class="plate-result-message danger">Veuillez corriger les erreurs dans les poids.</p>`;
                return;
            } else {
                dom.targetWeightInput.classList.remove('is-invalid');
                dom.targetWeightError.textContent = '';
            }


            let weightPerSideTarget = (targetWeight - barbellWeight) / 2;
            
            const platesDenominations = [25, 20, 15, 10, 5, 2.5, 1.25, 0.5, 0.25].sort((a, b) => b - a);

            const combinationResult1 = getPlateCombinationOptimal(weightPerSideTarget, platesDenominations);
            const combinationResult2 = getPlateCombinationAlternative(weightPerSideTarget, platesDenominations);
            
            const totalPlates1 = {};
            for (const plate in combinationResult1.plates) {
                totalPlates1[plate] = combinationResult1.plates[plate] * 2;
            }
            const formattedTotalPlates1 = formatPlatesWithPlus(totalPlates1);
            
            const totalPlates2 = {};
            for (const plate in combinationResult2.plates) {
                totalPlates2[plate] = combinationResult2.plates[plate] * 2;
            }
            const formattedTotalPlates2 = formatPlatesWithPlus(totalPlates2);

            const loadedWeightPerSide = combinationResult1.loadedWeight;
            const totalLoadedWeight = loadedWeightPerSide * 2 + barbellWeight;
            const diff = targetWeight - totalLoadedWeight;

            let resultHtml = `<div class="result-summary">
                                <h3>Résultats :</h3>
                                <p>Poids chargé par côté: <span>${loadedWeightPerSide.toFixed(2)}kg</span> | Poids total chargé: <span>${totalLoadedWeight.toFixed(2)}kg</span></p>`;
            
            if (Math.abs(diff) < 0.01) {
                resultHtml += `<p class="plate-result-message success">Poids cible atteint !</p>`;
            } else {
                resultHtml += `<p class="plate-result-message danger">Différence par rapport à la cible: ${diff > 0 ? '+' : ''}${diff.toFixed(2)}kg</p>`;
            }
            resultHtml += `</div>`;
            resultHtml += `<h4>1. Total des plaques (2 côtés) - Minimisant le nombre:</h4><p>${formattedTotalPlates1}</p>`;
            if(formattedTotalPlates1 !== formattedTotalPlates2 && formattedTotalPlates2 !== 'Aucun') {
                resultHtml += `<h4>2. Total des plaques (2 côtés) - Autre décomposition:</h4><p>${formattedTotalPlates2}</p>`;
            }
            
            dom.platesResult.innerHTML = resultHtml;
        }

        function calculateTrainingGoals() {
            const oneRmValid = validateInputField(dom.oneRmInput, dom.oneRmError);
            if (!oneRmValid) {
                dom.goalResultsContainer.innerHTML = '';
                return;
            }

            const oneRm = parseFloat(dom.oneRmInput.value);

            const goals = [
                { name: 'Hypertrophie', icon: '<i class="fas fa-person"></i>', minPercent: 0.60, maxPercent: 0.80, a_class: 'hypertrophy', tooltip: '60-80% du 1RM', reps: '6-12 Répétitions' },
                { name: 'Force', icon: '<i class="fas fa-dumbbell"></i>', minPercent: 0.80, maxPercent: 1.00, a_class: 'strength', tooltip: '80-100% du 1RM', reps: '1-5 Répétitions' },
                { name: 'Endurance', icon: '<i class="fas fa-fire"></i>', minPercent: 0, maxPercent: 0.60, a_class: 'endurance', tooltip: '<60% du 1RM', reps: '15+ Répétitions' },
                { name: 'Power', icon: '<i class="fas fa-bolt"></i>', minPercent: 0.30, maxPercent: 0.70, a_class: 'power', tooltip: '30-70% du 1RM', reps: '3-6 Répétitions (explosif)' }
            ];

            let resultsHtml = '';
            goals.forEach(goal => {
                const minWeight = (oneRm * goal.minPercent).toFixed(1);
                const maxWeight = (oneRm * goal.maxPercent).toFixed(1);
                let rangeText;
                if (goal.minPercent === 0) {
                    rangeText = `< ${maxWeight} kg`;
                } else {
                    rangeText = `${minWeight} - ${maxWeight} kg`;
                }

                resultsHtml += `
                    <div class="goal-card ${goal.a_class}" title="${goal.tooltip}">
                        <h4><span class="icon">${goal.icon}</span> ${goal.name}</h4>
                        <div class="weight-range"><strong>${rangeText}</strong></div>
                        <p class="rep-range">${goal.reps}</p>
                    </div>
                `;
            });

            dom.goalResultsContainer.innerHTML = resultsHtml;
        }
        
        async function handleTableActions(e) {
            const button = e.target.closest('button');
            if (!button) return;
            const rowOrCard = button.closest('.exercise-row') || button.closest('.exercise-card');
            if (!rowOrCard) return;
            const idx = +rowOrCard.dataset.exerciseIndex;
            const timerAction = button.dataset.timerAction;
            const action = button.dataset.action;

            if (action === 'quick-edit') {
                state.quickEditIndex = idx;
                dom.quickEditExerciseName.textContent = state.sessions[state.currentSessionIndex].exercises[idx].name;
                dom.quickEditModal.classList.remove('hidden');
                dom.quickEditModal.classList.add('show');
                if (!state.isMobileView) dom.quickEditWeight.focus();
                dom.quickEditWeight.classList.remove('is-invalid');
                dom.quickEditWeightError.textContent = '';
                dom.quickEditReps.classList.remove('is-invalid');
                dom.quickEditRepsError.textContent = '';
            } else if (action === 'link-superset') {
                const scrollY = window.scrollY;
                const exercises = state.sessions[state.currentSessionIndex].exercises;
                const clickedExercise = exercises[idx];

                if (clickedExercise.supersetGroup) {
                    let partnerIndex = -1;
                    if (clickedExercise.supersetWith !== null && clickedExercise.supersetWith !== undefined) {
                        partnerIndex = clickedExercise.supersetWith;
                    } else {
                        const partner = exercises.find(e => e.supersetWith === idx);
                        if (partner) {
                            partnerIndex = exercises.indexOf(partner);
                            partner.supersetWith = null;
                        }
                    }
                    clickedExercise.supersetWith = null;
                    clickedExercise.supersetGroup = false;
                    if (partnerIndex !== -1) {
                        exercises[partnerIndex].supersetGroup = false;
                    }
                    showNotification("Superset délié.", "info");

                    if (state.linkingState.active) {
                        state.linkingState = { active: false, fromIndex: null };
                    }
                    createTable();
                    window.scrollTo(0, scrollY);
                }
                else {
                    if (!state.linkingState.active) {
                        state.linkingState.active = true;
                        state.linkingState.fromIndex = idx;
                        button.classList.add('linking');
                        showNotification(`Sélectionnez un autre exercice à lier avec "${clickedExercise.name}".`, "info");
                    }
                    else {
                        const fromIndex = state.linkingState.fromIndex;
                        if (fromIndex !== idx) {
                            exercises[fromIndex].supersetWith = idx;
                            exercises[fromIndex].supersetGroup = true;
                            clickedExercise.supersetGroup = true;

                            const oldLink = exercises.find((e, i) => e.supersetWith === idx && i !== fromIndex);
                            if (oldLink) {
                                oldLink.supersetWith = null;
                                oldLink.supersetGroup = false;
                            }

                            showNotification("Exercices liés en superset!", "success");
                        }
                        state.linkingState = { active: false, fromIndex: null };
                        createTable();
                        window.scrollTo(0, scrollY);
                    }
                }
            } else if (timerAction) {
                handleTimerActions(timerAction, idx, rowOrCard);
            } else if (action === 'remove') {
                const exerciseToRemove = state.sessions[state.currentSessionIndex].exercises[idx];
                const confirmed = await customConfirm(`Êtes-vous sûr de vouloir supprimer l'exercice "${exerciseToRemove.name}"?`);
                if (confirmed) {
                    const scrollY = window.scrollY;
                    state.sessions[state.currentSessionIndex].exercises.splice(idx, 1);
                    state.lastDeletedExercise = exerciseToRemove;
                    if (state.timers[idx]) {
                        clearInterval(state.timers[idx].interval);
                        delete state.timers[idx];
                    }
                    createTable();
                    window.scrollTo(0, scrollY);
                    showUndoableNotification(`Exercice "${exerciseToRemove.name}" supprimé.`, () => {
                        if (state.lastDeletedExercise) {
                            state.sessions[state.currentSessionIndex].exercises.splice(idx, 0, state.lastDeletedExercise);
                            createTable();
                            updateAllTotals();
                            state.lastDeletedExercise = null;
                            showNotification(`Suppression annulée. "${exerciseToRemove.name}" restauré.`, "info");
                        }
                    }, 7000);
                }
            } else if (action === 'add-series') {
                const scrollY = window.scrollY;
                const exercise = state.sessions[state.currentSessionIndex].exercises[idx];
                exercise.series.push({ weight: '', reps: '' });
                createTable();
                window.scrollTo(0, scrollY);
                showNotification(`Nouvelle série ajoutée à l'exercice "${exercise.name}".`, "info", 2000);
            }
        }
        
        function handleTimerActions(timerAction, idx, element) {
             const timerDisplay = element.querySelector('.timer-display');
             const startBtn = element.querySelector('[data-timer-action="start"]');
             const stopBtn = element.querySelector('[data-timer-action="stop"]');
             const exercise = state.sessions[state.currentSessionIndex].exercises[idx];
             const restString = exercise.rest;
             let restSeconds = parseInt(restString) * (restString.includes('min') ? 60 : 1) || 60;
             const duration = Math.max(restSeconds, 60); 

            if (timerAction === 'start') {
                if ('Notification' in window && Notification.permission === 'default') {
                    Notification.requestPermission();
                }

                localStorage.setItem(`timer-${idx}`, JSON.stringify({
                    endTime: Date.now() + duration * 1000,
                    name: exercise.name,
                    startTime: Date.now(),
                    duration: duration
                }));
                
                if (state.timers[idx] && state.timers[idx].interval) clearInterval(state.timers[idx].interval);
                state.timers[idx] = {
                    secondsElapsed: 0,
                    duration: duration,
                    interval: setInterval(() => {
                        state.timers[idx].secondsElapsed++;
                        const remaining = state.timers[idx].duration - state.timers[idx].secondsElapsed;
                        if (remaining <= 0) {
                            timerDisplay.textContent = formatTimerDisplay(0);
                            timerDisplay.classList.remove('timer-active');
                            clearInterval(state.timers[idx].interval);
                            localStorage.removeItem(`timer-${idx}`);
                            playBeep(); 
                            if(Notification.permission === "granted") {
                                new Notification('Lyftiv - Repos Terminé !', { body: `Le temps de repos pour ${exercise.name} est terminé.`});
                            }
                            startBtn.classList.remove('hidden'); 
                            stopBtn.classList.add('hidden'); 
                            
                            const exercises = state.sessions[state.currentSessionIndex].exercises;
                            const parentIndex = exercises.findIndex(ex => ex.supersetWith === idx);
                            if (parentIndex !== -1) {
                                const parentExercise = exercises[parentIndex];
                                const parentElement = document.querySelector(`[data-exercise-index="${parentIndex}"]`);
                                parentElement?.classList.add('next-superset-exercise');
                                showNotification(`Fin du repos ! Reprenez avec ${parentExercise.name}`, "info");
                            }

                        } else {
                            timerDisplay.textContent = formatTimerDisplay(remaining); 
                        }
                    }, 1000) 
                };
                timerDisplay.textContent = formatTimerDisplay(duration); 
                timerDisplay.classList.add('timer-active'); 
                startBtn.classList.add('hidden'); 
                stopBtn.classList.remove('hidden'); 
            }
        }

        async function handleHistoryActions(e) { 
            const button = e.target.closest('button');
            if (!button) return;
            const historyAction = button.dataset.historyAction;
            const historyId = +button.dataset.historyId;
            if (historyAction === 'details') showHistoryDetails(historyId);
            else if (historyAction === 'delete') await deleteHistoryItem(historyId);
            else if (historyAction === 'load') {
                const historicalSession = getHistory().find(s => s.id == historyId);
                if (historicalSession) {
                    showLoadOptionsModal(historicalSession); 
                } else {
                    showNotification("La séance historique demandée n'a pas été trouvée.", "error");
                }
            }
        }

        async function deleteHistoryItem(id) {
            const confirmed = await customConfirm("Êtes-vous sûr de vouloir supprimer définitivement cette séance de l'historique ?");
            if (confirmed) {
                let history = getHistory().filter(session => session.id != id);
                localStorage.setItem('workoutHistory', JSON.stringify(history));
                displayHistory(); 
                showNotification("Séance supprimée de l'historique avec succès.", "info");
            }
        }
        
        function updateStateFromTable() {
            if (!state.isInitialized) return;
            
            const currentSession = state.sessions[state.currentSessionIndex];
            if (!currentSession || !currentSession.exercises) return;

            currentSession.exercises.forEach((ex, idx) => {
                if (!Array.isArray(ex.series)) {
                    ex.series = [];
                }
                
                const currentInputs = Array.from(document.querySelectorAll(`[data-ex='${idx}'][data-serie]`));
                const newSeriesData = [];
                
                const seriesMap = new Map();
                currentInputs.forEach(input => {
                    const serieIndex = parseInt(input.dataset.serie, 10);
                    if (!seriesMap.has(serieIndex)) {
                        seriesMap.set(serieIndex, {});
                    }
                    if (input.classList.contains('weight')) {
                        seriesMap.get(serieIndex).weight = input.value;
                    } else if (input.classList.contains('reps')) {
                        seriesMap.get(serieIndex).reps = input.value;
                    }
                });

                Array.from(seriesMap.keys()).sort((a, b) => a - b).forEach(serieIndex => {
                    newSeriesData.push(seriesMap.get(serieIndex));
                });

                ex.series = newSeriesData;
            });
        }

        function resetAppStateToDefault() {
            state.sessions = JSON.parse(JSON.stringify(defaultSessions));
            state.currentSessionIndex = 0;
            localStorage.removeItem('inProgressWorkout');
            localStorage.removeItem('calculatorState');
            Object.values(state.timers).forEach(timer => {
                if (timer && timer.interval) clearInterval(timer.interval);
            });
            state.timers = {};
            state.workoutStartTime = null;
            state.isWorkoutTimerPaused = false;
            state.pausedTime = 0;
            dom.totalTimeEl.textContent = "00:00:00";
            dom.totalKgRepEl.textContent = "0 kg/rep";
            dom.deltaEl.textContent = "0 kg";
            dom.previousWeekInput.value = "";
            dom.sessionNotesInput.value = "";
            dom.timerPlayPauseIcon.textContent = '▶️';
            dom.timerPlayPauseText.textContent = 'Play';
            updateSessionSelectOptions();
            dom.sessionSelect.value = state.currentSessionIndex;
            updateDeleteSessionButtonState();
        }

        function isAppStateValid() {
            if (!Array.isArray(state.sessions)) {
                return false;
            }
            if (typeof state.currentSessionIndex !== 'number' || state.currentSessionIndex < 0 || state.currentSessionIndex >= state.sessions.length) {
                return false;
            }
            const currentSession = state.sessions[state.currentSessionIndex];
            if (!currentSession || typeof currentSession !== 'object' || !Array.isArray(currentSession.exercises)) {
                return false;
            }
            return true;
        }
        
        function createTable() {
            if (!state.isInitialized) return;

            dom.exerciseListContainer.innerHTML = "";
            if (!isAppStateValid()) {
                resetAppStateToDefault();
            }

            const currentSession = state.sessions[state.currentSessionIndex];
            const exercises = (currentSession && Array.isArray(currentSession.exercises)) ? currentSession.exercises : [];
            
            if (!state.isMobileView) {
                const table = document.createElement("table");
                table.id = "workoutTable";
                table.className = "desktop-table";
                table.setAttribute('role', 'table');
                table.setAttribute('aria-label', 'Liste des exercices de la séance');

                const thead = document.createElement("thead");
                thead.innerHTML = `
                    <tr role="row">
                        <th class="actions-col" scope="col">Actions</th>
                        <th scope="col">Exercice</th>
                        <th colspan="5" scope="colgroup">Séries</th>
                        <th scope="col">Tonnage</th>
                        <th scope="col">Kg/Rép</th> <th scope="col">1RM</th>
                        <th scope="col">Repos</th>
                        <th scope="col">Minuteur</th>
                        <th scope="col"></th> 
                    </tr>
                `;
                table.appendChild(thead);

                const tbody = document.createElement("tbody");
                tbody.id = "tbody";
                table.appendChild(tbody);
                dom.exerciseListContainer.appendChild(table);

                (exercises || []).forEach((ex, idx) => {
                    if (!ex || typeof ex !== 'object' || !Array.isArray(ex.series)) {
                        return;
                    }

                    const tr = document.createElement("tr");
                    tr.className = "exercise-row";
                    tr.dataset.exerciseIndex = idx;
                    tr.setAttribute('role', 'row');
            
                    if (ex.supersetGroup) {
                        tr.classList.add('superset-group');
                    }

                    let seriesContentHtml = "";
                    (ex.series || []).forEach((currentSeries, i) => {
                        seriesContentHtml += `<td role="cell"><div class="serie-input">
                            <input type="text" inputmode="text" data-ex="${idx}" data-serie="${i}" class="weight" placeholder="kg" aria-label="Poids pour l'exercice ${ex.name} série ${i+1}" value="${currentSeries.weight || ''}">
                            <input type="text" inputmode="text" data-ex="${idx}" data-serie="${i}" class="reps" placeholder="Reps" aria-label="Reps pour l'exercice ${ex.name} série ${i+1}" value="${currentSeries.reps || ''}">
                            <button class="serie-input-delete" data-ex="${idx}" data-serie="${i}" aria-label="Effacer cette série">&times;</button>
                        </div></td>`;
                    });

                    const remainingCols = 5 - (ex.series ? ex.series.length : 0);
                    for (let i = 0; i < remainingCols; i++) {
                        seriesContentHtml += `<td role="cell"></td>`;
                    }
                    
                    const restSeconds = parseInt(ex.rest) * (String(ex.rest).includes('min') ? 60 : 1) || 0;
                    const defaultTimerDisplay = formatTimerDisplay(restSeconds);

                    tr.innerHTML = `
                        <td class="actions-col" data-label="Actions" role="cell">
                            <button class="quick-edit-btn tooltip" data-action="quick-edit" aria-label="Édition rapide pour ${ex.name}">
                                <i class="fas fa-pencil-alt"></i>
                                <span class="tooltiptext">Édition rapide</span>
                            </button>
                            <button class="link-btn tooltip" data-action="link-superset" aria-label="Lier ${ex.name} pour superset">
                                <i class="fas fa-link"></i>
                                <span class="tooltiptext">Lier Superset</span>
                            </button>
                            <button class="btn-ghost" data-action="add-series" data-exercise-index="${idx}" aria-label="Ajouter une série à ${ex.name}">
                                <i class="fas fa-plus"></i>
                                <span class="tooltiptext">Ajouter série</span>
                            </button>
                        </td>
                        <td class="exercise-col" data-label="Exercice" title="${ex.name}" role="cell">
                            <span>${ex.name}</span>
                        </td>
                        ${seriesContentHtml}
                        <td data-label="Tonnage" id="tonnage-${idx}" role="cell">0</td>
                        <td data-label="Kg/Rép" id="kgrep-${idx}" role="cell">0</td> <td data-label="1RM" id="onerm-${idx}" role="cell">0</td> <td data-label="Repos" role="cell">${ex.rest || ''}</td>
                        <td role="cell"><div class="timer-container">
                                <div class="timer-display" id="timer-${idx}" aria-live="polite">${defaultTimerDisplay}</div>
                                <button class="timer-btn" data-timer-action="start" aria-label="Démarrer le minuteur pour ${ex.name}"><i class="fas fa-play"></i></button>
                                <button class="timer-btn hidden" data-timer-action="stop" aria-label="Arrêter le minuteur pour ${ex.name}"><i class="fas fa-stop"></i></button>
                                <button class="timer-btn" data-timer-action="reset" aria-label="Réinitialiser le minuteur pour ${ex.name}"><i class="fas fa-redo"></i></button>
                            </div>
                        </td>
                        <td role="cell"><button class="btn-ghost" data-action="remove" aria-label="Supprimer l'exercice ${ex.name}"><i class="fas fa-trash-alt"></i></button></td>`;
                    tbody.appendChild(tr);
                    
                    if (ex.supersetGroup) {
                        const linkBtn = tr.querySelector('.link-btn');
                        if (linkBtn) linkBtn.classList.add('active-superset');
                    }
                });
            } else {
                const mobileCardsContainer = document.createElement("div");
                mobileCardsContainer.className = "mobile-cards";
                mobileCardsContainer.setAttribute('role', 'list');
                dom.exerciseListContainer.appendChild(mobileCardsContainer);

                (exercises || []).forEach((ex, idx) => {
                    if (!ex || typeof ex !== 'object' || !Array.isArray(ex.series)) {
                        return;
                    }

                    const card = document.createElement("div");
                    card.className = "exercise-card";
                    card.dataset.exerciseIndex = idx;
                    card.setAttribute('role', 'listitem');
                    card.setAttribute('aria-label', `Exercice: ${ex.name}`);

                    if (ex.supersetGroup) {
                         card.classList.add('superset-group');
                    }

                    let seriesHtml = '';
                    (ex.series || []).forEach((currentSeries, i) => {
                        seriesHtml += `
                            <div class="series-row">
                                <span>Série ${i + 1}:</span>
                                <div class="series-input-group">
                                    <input type="text" inputmode="text" data-ex="${idx}" data-serie="${i}" class="weight" placeholder="kg" aria-label="Poids pour l'exercice ${ex.name} série ${i+1}" value="${currentSeries.weight || ''}">
                                    <input type="text" inputmode="text" data-ex="${idx}" data-serie="${i}" class="reps" placeholder="Reps" aria-label="Reps pour l'exercice ${ex.name} série ${i+1}" value="${currentSeries.reps || ''}">
                                    <button class="serie-input-delete" data-ex="${idx}" data-serie="${i}" aria-label="Effacer série ${i+1} pour ${ex.name}">&times;</button>
                                </div>
                            </div>
                        `;
                    });

                    const restSeconds = parseInt(ex.rest) * (String(ex.rest).includes('min') ? 60 : 1) || 0;
                    const defaultTimerDisplay = formatTimerDisplay(restSeconds);

                    card.innerHTML = `
                        <h3>
                            ${ex.name}
                        </h3>
                            <button class="btn-ghost" data-action="remove" aria-label="Supprimer l'exercice ${ex.name}"><i class="fas fa-trash-alt"></i></button>
                        </h4>
                        <div class="series-group">
                            ${seriesHtml}
                            <button class="btn btn-outline" data-action="add-series" data-exercise-index="${idx}" style="width: 100%; margin-top: var(--spacing-sm);">
                                <i class="fas fa-plus"></i> Ajouter une série
                            </button>
                        </div>
                        <div class="card-stats">
                            <div class="card-stat-item">
                                <span class="card-stat-label">Tonnage</span>
                                <span class="card-stat-value" id="tonnage-${idx}">0</span>
                            </div>
                            <div class="card-stat-item">
                                <span class="card-stat-label">Kg/Rép</span> <span class="card-stat-value" id="kgrep-${idx}">0</span> </div>
                            <div class="card-stat-item">
                                <span class="card-stat-label">1RM Moy</span> <span class="card-stat-value" id="onerm-${idx}">0</span>
                            </div>
                            <div class="card-stat-item">
                                <span class="card-stat-label">Repos</span>
                                <span class="card-stat-value">${ex.rest}</span>
                            </div>
                        </div>
                        <div class="card-actions">
                            <button class="btn btn-info" data-action="quick-edit" aria-label="Édition rapide pour ${ex.name}"><i class="fas fa-pencil-alt"></i> Éditer</button>
                            <button class="btn btn-secondary link-btn" data-action="link-superset" aria-label="Lier ${ex.name} pour superset"><i class="fas fa-link"></i> Superset</button>
                            <div class="timer-container">
                                <div class="timer-display" id="timer-${idx}" aria-live="polite">${defaultTimerDisplay}</div>
                                <button class="timer-btn" data-timer-action="start" aria-label="Démarrer le minuteur pour ${ex.name}"><i class="fas fa-play"></i></button>
                                <button class="timer-btn hidden" data-timer-action="stop" aria-label="Arrêter le minuteur pour ${ex.name}"><i class="fas fa-stop"></i></button>
                                <button class="timer-btn" data-timer-action="reset" aria-label="Réinitialiser le minuteur pour ${ex.name}"><i class="fas fa-redo"></i></button>
                            </div>
                        </div>
                    `;
                    mobileCardsContainer.appendChild(card);
                    
                    if (ex.supersetGroup) {
                        const linkBtn = card.querySelector('.link-btn');
                        if (linkBtn) linkBtn.classList.add('active-superset');
                    }
                });
            }

            loadCurrentState();
            updateAllTotals();
            updateDeleteSessionButtonState();
        }

        function calculate1RM(weight, reps) {
            if (reps <= 0 || weight <= 0) return 0;
            const brzycki1RM = weight / (1.0278 - (0.0278 * reps));
            const mayhew1RM = (100 * weight) / (52.2 + (41.9 * Math.exp(-0.055 * reps)));
            const epley1RM = weight * (1 + (reps / 30));
            const lander1RM = (100 * weight) / (101.3 - 2.67123 * reps);
            const lombardi1RM = weight * Math.pow(reps, 0.10);

            const validFormulas = [brzycki1RM, mayhew1RM, epley1RM, lander1RM, lombardi1RM].filter(val => !isNaN(val) && val > 0);

            if (validFormulas.length === 0) return 0;
            return validFormulas.reduce((sum, val) => sum + val, 0) / validFormulas.length;
        }

        function animateNumberChange(element, startValue, endValue, duration, suffix = '') {
            const range = endValue - startValue;
            const startTime = performance.now();

            function update() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const currentValue = startValue + range * progress;
                element.textContent = `${currentValue.toFixed(0)}${suffix}`;

                if (progress < 1) {
                    requestAnimationFrame(update);
                } else {
                    element.textContent = `${endValue.toFixed(0)}${suffix}`;
                }
            }
            requestAnimationFrame(update);
        }

        function updateAllTotals() {
            if (!state.isInitialized) return;
            
            let totalSessionTonnage = 0;
            let totalSessionReps = 0;
            let totalSessionKgRep = 0;
            let completedSeriesOverall = 0;

            if (!isAppStateValid()) {
                resetAppStateToDefault();
                updateAllTotals();
                return;
            }
            const currentSession = state.sessions[state.currentSessionIndex];
            const exercises = (currentSession && Array.isArray(currentSession.exercises)) ? currentSession.exercises : [];
            let totalPossibleSeries = 0;
            let exercisesWith1RM = [];

            (exercises || []).forEach((ex, idx) => {
                if (!ex || typeof ex !== 'object' || !Array.isArray(ex.series)) {
                    return;
                }

                let exerciseTonnage = 0;
                let exerciseTotalReps = 0;
                let exerciseKgRep = 0;
                let oneRMs = [];
                
                totalPossibleSeries += (ex.series || []).length;

                (ex.series || []).forEach((s, i) => {
                    const repsInput = document.querySelector(`[data-ex='${idx}'][data-serie='${i}'].reps`);
                    const weightInput = document.querySelector(`[data-ex='${idx}'][data-serie='${i}'].weight`);
                    
                    const repsValue = repsInput?.value.trim() || '';
                    const weightValue = weightInput?.value.trim() || '';

                    const repsSegments = repsValue.split('+').map(s => parseFloat(s.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0);
                    const weightSegments = weightValue.split('+').map(s => parseFloat(s.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0);

                    let currentSeriesTonnage = 0;
                    let currentSeriesReps = 0;
                    let currentSeriesValid = false;

                    const minLength = Math.min(repsSegments.length, weightSegments.length);
                    for (let k = 0; k < minLength; k++) {
                        const reps = repsSegments[k];
                        const weight = weightSegments[k];
                        
                        currentSeriesTonnage += reps * weight;
                        currentSeriesReps += reps;
                        if (reps > 0 && weight > 0) {
                            oneRMs.push(calculate1RM(weight, reps));
                            currentSeriesValid = true;
                        }
                    }

                    if (weightInput) {
                        if (!isValidAndCompleteNumber(weightInput.value) && weightInput.value.trim() !== '') {
                             weightInput.classList.add('is-invalid');
                        } else {
                            weightInput.classList.remove('is-invalid');
                        }
                    }
                    if (repsInput) {
                         if (!isValidAndCompleteNumber(repsInput.value) && repsInput.value.trim() !== '') {
                            repsInput.classList.add('is-invalid');
                        } else {
                            repsInput.classList.remove('is-invalid');
                        }
                    }

                    if (currentSeriesValid) {
                        repsInput.classList.add('completed');
                        weightInput.classList.add('completed');
                        completedSeriesOverall++;
                    } else {
                        repsInput?.classList.remove('completed');
                        weightInput?.classList.remove('completed');
                    }
                    
                    exerciseTonnage += currentSeriesTonnage;
                    exerciseTotalReps += currentSeriesReps;
                });

                if (exerciseTotalReps > 0) {
                    exerciseKgRep = exerciseTonnage / exerciseTotalReps;
                }

                let weightedAverage1RM = 0;
                if (oneRMs.length > 0) {
                    let totalWeighted1RM = 0;
                    let totalWeightSum = 0;
                    for (let j = 0; j < oneRMs.length; j++) {
                        const positionFromEnd = oneRMs.length - 1 - j;
                        const weightFactor = 1 / (1 + positionFromEnd * 0.2);
                        totalWeighted1RM += oneRMs[j] * weightFactor;
                        totalWeightSum += weightFactor;
                    }
                    weightedAverage1RM = totalWeighted1RM / totalWeightSum;
                }

                const tonnageEl = document.getElementById(`tonnage-${idx}`);
                if(tonnageEl) {
                    tonnageEl.textContent = exerciseTonnage.toFixed(0);
                    tonnageEl.classList.toggle('tonnage-high', exerciseTonnage > 0);
                }
                const kgRepEl = document.getElementById(`kgrep-${idx}`);
                if (kgRepEl) {
                    kgRepEl.textContent = exerciseKgRep.toFixed(2);
                    kgRepEl.classList.toggle('kg-rep-high', exerciseKgRep > 0);
                }
                const onermEl = document.getElementById(`onerm-${idx}`);
                if (onermEl) {
                    onermEl.textContent = weightedAverage1RM > 0 ? weightedAverage1RM.toFixed(1) : '0';
                    onermEl.classList.toggle('onerm-high', weightedAverage1RM > 0);
                    if (weightedAverage1RM > 0) {
                        exercisesWith1RM.push({ name: ex.name, oneRm: weightedAverage1RM.toFixed(1) });
                    }
                }
                totalSessionTonnage += exerciseTonnage;
                totalSessionReps += exerciseTotalReps;
            });

            if (totalSessionReps > 0) {
                totalSessionKgRep = totalSessionTonnage / totalSessionReps;
            }

            const currentKgRep = parseFloat(dom.totalKgRepEl.textContent.replace(' kg/rep', '')) || 0;
            const newKgRep = totalSessionKgRep;
            animateNumberChange(dom.totalKgRepEl, currentKgRep, newKgRep, 500, ' kg/rep');

            dom.progressBar.setAttribute('aria-valuenow', (totalPossibleSeries > 0 ? (completedSeriesOverall / totalPossibleSeries) * 100 : 0).toFixed(0));

            const previous = parseFloat(dom.previousWeekInput.value) || 0;
            const delta = newKgRep - previous;
            const startDelta = parseFloat(dom.deltaEl.textContent.replace(' kg', '').replace('+', '')) || 0;
            
            const deltaDuration = 500;
            const deltaStartTime = performance.now();

            function updateDeltaAnimation() {
                const elapsed = performance.now() - deltaStartTime;
                const progress = Math.min(elapsed / deltaDuration, 1);
                const currentValue = startDelta + (delta - startDelta) * progress;
                const displayValue = Math.round(currentValue);

                const displaySign = displayValue > 0 ? '+' : '';
                dom.deltaEl.textContent = `${displaySign}${displayValue} kg`;
                dom.deltaEl.style.color = displayValue > 0 ? 'var(--color-success-default)' : displayValue < 0 ? 'var(--color-danger-default)' : 'inherit';

                if (progress < 1) {
                    requestAnimationFrame(updateDeltaAnimation);
                } else {
                     dom.deltaEl.textContent = `${delta > 0 ? '+' : ''}${delta.toFixed(0)} kg`;
                     dom.deltaEl.style.color = delta > 0 ? 'var(--color-success-default)' : delta < 0 ? 'var(--color-danger-default)' : 'inherit';
                }
            }
            requestAnimationFrame(updateDeltaAnimation);

            dom.progressFill.style.width = `${totalPossibleSeries > 0 ? (completedSeriesOverall / totalPossibleSeries) * 100 : 0}%`;
            saveCurrentState();
            populateOneRMDropdown(exercisesWith1RM);
        }

        function populateOneRMDropdown(exercisesWith1RM) {
            dom.oneRmExerciseSelect.innerHTML = '<option value="">-- Sélectionner un exercice --</option>';
            if (exercisesWith1RM.length > 0) {
                exercisesWith1RM.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.oneRm;
                    option.textContent = `${item.name} (${item.oneRm} kg)`;
                    dom.oneRmExerciseSelect.appendChild(option);
                });
                dom.oneRmExerciseSelect.disabled = false;
            } else {
                dom.oneRmExerciseSelect.disabled = true;
            }
        }

        function saveCurrentState() {
            const currentSession = state.sessions[state.currentSessionIndex];
            if (!currentSession) return;
            currentSession.exercises.forEach((ex, idx) => {
                ex.series = Array.from(document.querySelectorAll(`[data-ex='${idx}'][data-serie]`)).reduce((acc, input) => {
                    const serieIndex = parseInt(input.dataset.serie, 10);
                    if (!acc[serieIndex]) {
                        acc[serieIndex] = {};
                    }
                    if (input.classList.contains('weight')) {
                        acc[serieIndex].weight = input.value;
                    } else if (input.classList.contains('reps')) {
                        acc[serieIndex].reps = input.value;
                    }
                    return acc;
                }, []).filter(s => s.weight !== undefined || s.reps !== undefined);
            });
            const calculatorState = {
                targetWeight: dom.targetWeightInput.value,
                barbellWeight: dom.barbellWeightInput.value,
                oneRm: dom.oneRmInput.value
            };
            try {
                localStorage.setItem('calculatorState', JSON.stringify(calculatorState));
            } catch (e) {
                console.error("Erreur lors de la sauvegarde de l'état du calculateur :", e);
            }

            const data = {
                previousWeek: dom.previousWeekInput.value,
                sessionIndex: state.currentSessionIndex,
                customSessions: state.sessions,
                workoutStartTime: state.workoutStartTime,
                isWorkoutTimerPaused: state.isWorkoutTimerPaused,
                pausedTime: state.isWorkoutTimerPaused ? state.pausedTime : (state.workoutStartTime ? (Date.now() - new Date(state.workoutStartTime).getTime()) / 1000 : 0),
                saveTimestamp: Date.now(),
                sessionNotes: dom.sessionNotesInput.value
            };
            try {
                localStorage.setItem('inProgressWorkout', JSON.stringify(data));
            } catch (e) {
                console.error("Erreur lors de la sauvegarde de la séance en cours :", e);
            }
        }

        function loadCurrentState() {
            const data = JSON.parse(localStorage.getItem('inProgressWorkout'));
            if (!data) return;
            const currentSession = state.sessions[state.currentSessionIndex];
            const currentExercises = (currentSession && Array.isArray(currentSession.exercises)) ? currentSession.exercises : [];

            currentExercises.forEach((ex, idx) => {
                if (!Array.isArray(ex.series)) {
                    ex.series = [];
                }
                ex.series.forEach((s, i) => {
                    const repsInput = document.querySelector(`[data-ex='${idx}'][data-serie='${i}'].reps`);
                    const weightInput = document.querySelector(`[data-ex='${idx}'][data-serie='${i}'].weight`);
                    if (repsInput) repsInput.value = s.reps || '';
                    if (weightInput) weightInput.value = s.weight || '';
                });
            });
            dom.previousWeekInput.value = data.previousWeek || "";
            dom.sessionNotesInput.value = data.sessionNotes || "";

            const calculatorState = JSON.parse(localStorage.getItem('calculatorState'));
            if (calculatorState) {
                dom.targetWeightInput.value = calculatorState.targetWeight || '';
                dom.barbellWeightInput.value = calculatorState.barbellWeight || '';
                dom.oneRmInput.value = calculatorState.oneRm || '';
                calculatePlates();
                calculateTrainingGoals();
            }
        }

        function customConfirm(message) {
            return new Promise(resolve => {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.setAttribute('role', 'dialog');
                modal.setAttribute('aria-modal', 'true');
                modal.setAttribute('aria-labelledby', 'confirmModalTitle');
                modal.innerHTML = `
                    <div class="modal-content" style="text-align: center;">
                        <h2 id="confirmModalTitle" style="font-size: 1.5rem; margin-bottom: var(--spacing-md);">Confirmation</h2>
                        <p style="margin-bottom: var(--spacing-lg);">${message}</p>
                        <div style="display: flex; justify-content: center; gap: var(--spacing-md);">
                            <button class="btn btn-outline confirm-no"> Non</button>
                            <button class="btn btn-success confirm-yes"> Oui</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);

                const confirmYesBtn = modal.querySelector('.confirm-yes');
                const confirmNoBtn = modal.querySelector('.confirm-no');
                const triggeringElement = document.activeElement;

                const cleanup = () => {
                    modal.classList.remove('show');
                    const fallbackTimeout = setTimeout(() => {
                        if (document.body.contains(modal)) {
                            modal.remove();
                            if (triggeringElement && typeof triggeringElement.focus === 'function') {
                                triggeringElement.focus();
                            }
                        }
                    }, 500);
                    modal.addEventListener('transitionend', () => {
                        clearTimeout(fallbackTimeout);
                        if (document.body.contains(modal)) {
                           modal.remove();
                           if (triggeringElement && typeof triggeringElement.focus === 'function') {
                                triggeringElement.focus();
                            }
                        }
                    }, { once : true });
                };

                confirmYesBtn.onclick = () => { 
                    cleanup();
                    resolve(true); 
                };

                confirmNoBtn.onclick = () => { 
                    cleanup();
                    resolve(false); 
                };
                
                setTimeout(() => {
                    modal.classList.add('show');
                    confirmNoBtn.focus();
                }, 10);
            });
        }
        
        function autoSaveSession() {
            if (!state.workoutStartTime || state.isWorkoutTimerPaused) {
                return;
            }
            let currentSessionTonnage = 0;
            let currentSessionReps = 0;

            const exercisesData = (state.sessions[state.currentSessionIndex]?.exercises || []).flatMap((ex, idx) => {
                const exerciseSeries = [];
                let exerciseTonnage = 0;
                let exerciseReps = 0;

                ex.series.forEach(s => {
                    const repsValues = String(s.reps).split('+').map(val => parseFloat(val.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0) || [];
                    const weightValues = String(s.weight).split('+').map(val => parseFloat(val.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0) || [];
                    
                    const minLength = Math.min(repsValues.length, weightValues.length);
                    
                    if (minLength > 0) {
                        for (let k = 0; k < minLength; k++) {
                            exerciseSeries.push({ reps: repsValues[k], weight: weightValues[k] });
                            exerciseTonnage += repsValues[k] * weightValues[k];
                            exerciseReps += repsValues[k];
                        }
                    } else if (repsValues.length > 0) {
                        repsValues.forEach(r => {
                            exerciseSeries.push({ reps: r, weight: 0 });
                            exerciseReps += r;
                        });
                    } else if (weightValues.length > 0) {
                        weightValues.forEach(w => {
                            exerciseSeries.push({ reps: 0, weight: w });
                        });
                    }
                });

                if (exerciseSeries.length > 0) {
                    currentSessionTonnage += exerciseTonnage;
                    currentSessionReps += exerciseReps;
                    return [{
                        name: ex.name,
                        rest: ex.rest || "1 min",
                        series: exerciseSeries.filter(s => s.reps > 0 || s.weight > 0),
                        exerciseTonnage: exerciseTonnage,
                        exerciseReps: exerciseReps
                    }];
                }
                return [];
            });

            const workoutData = {
                id: state.workoutStartTime, 
                date: new Date().toISOString(),
                sessionName: dom.sessionSelect.selectedOptions[0].text,
                totalTonnage: currentSessionTonnage,
                totalReps: currentSessionReps,
                totalKgRep: currentSessionReps > 0 ? (currentSessionTonnage / currentSessionReps).toFixed(2) : 0,
                duration: dom.totalTimeEl.textContent,
                notes: dom.sessionNotesInput.value,
                exercises: exercisesData
            };
            let history = getHistory();
            history = history.filter(session => !(session.isAutoSave && session.id === state.workoutStartTime));
            history.push(workoutData);
            try {
                localStorage.setItem('workoutHistory', JSON.stringify(history));
            } catch (e) {
                console.error("Erreur lors de la sauvegarde de l'historique :", e);
            }
            showNotification("Progression de la séance sauvegardée automatiquement.", "info", 3000);
        }
        
        function finishAndSaveSession() {
            let currentSessionTonnage = 0;
            let currentSessionReps = 0;

            const exercisesData = (state.sessions[state.currentSessionIndex]?.exercises || []).flatMap((ex, idx) => {
                const exerciseSeries = [];
                let exerciseTonnage = 0;
                let exerciseReps = 0;

                ex.series.forEach(s => {
                    const repsValues = String(s.reps).split('+').map(val => parseFloat(val.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0) || [];
                    const weightValues = String(s.weight).split('+').map(val => parseFloat(val.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0) || [];
                    
                    const minLength = Math.min(repsValues.length, weightValues.length);
                    
                    if (minLength > 0) {
                        for (let k = 0; k < minLength; k++) {
                            exerciseSeries.push({ reps: repsValues[k], weight: weightValues[k] });
                            exerciseTonnage += repsValues[k] * weightValues[k];
                            exerciseReps += repsValues[k];
                        }
                    } else if (repsValues.length > 0) {
                        repsValues.forEach(r => {
                            exerciseSeries.push({ reps: r, weight: 0 });
                            exerciseReps += r;
                        });
                    } else if (weightValues.length > 0) {
                        weightValues.forEach(w => {
                            exerciseSeries.push({ reps: 0, weight: w });
                        });
                    }
                });

                if (exerciseSeries.length > 0) {
                    currentSessionTonnage += exerciseTonnage;
                    currentSessionReps += exerciseReps;
                    return [{
                        name: ex.name,
                        rest: ex.rest || "1 min",
                        series: exerciseSeries.filter(s => s.reps > 0 || s.weight > 0),
                        exerciseTonnage: exerciseTonnage,
                        exerciseReps: exerciseReps
                    }];
                }
                return [];
            });

            if (currentSessionTonnage === 0) {
                showNotification("Aucune donnée à sauvegarder. La séance n'a pas été enregistrée car le tonnage total est de 0 kg.", "info");
                return; 
            }
            pauseTotalWorkoutTimer(); 

            const workoutData = {
                id: Date.now(),
                date: new Date().toISOString(),
                sessionName: dom.sessionSelect.selectedOptions[0].text,
                totalTonnage: currentSessionTonnage,
                totalReps: currentSessionReps,
                totalKgRep: currentSessionReps > 0 ? (currentSessionTonnage / currentSessionReps).toFixed(2) : 0,
                duration: dom.totalTimeEl.textContent,
                notes: dom.sessionNotesInput.value,
                exercises: exercisesData
            };
            let history = getHistory();
            history = history.filter(session => !(session.isAutoSave && session.id === state.workoutStartTime));
            history.push(workoutData);
            localStorage.setItem('workoutHistory', JSON.stringify(history));
            showNotification("Séance sauvegardée dans l'historique avec succès !", "success");
            
            Object.values(state.timers).forEach(timer => {
                if (timer && timer.interval) clearInterval(timer.interval);
            });
            state.timers = {};
            state.workoutStartTime = null;
            state.isWorkoutTimerPaused = false;
            state.pausedTime = 0;
            dom.timerPlayPauseIcon.textContent = '▶️';
            dom.timerPlayPauseText.textContent = 'Play';
            localStorage.removeItem('inProgressWorkout');
            createTable();
            dom.totalTimeEl.textContent = "00:00:00";
            dom.totalKgRepEl.textContent = "0 kg/rep";
            dom.deltaEl.textContent = "0 kg";
            dom.previousWeekInput.value = "";
            dom.sessionNotesInput.value = "";
        }

        function getHistory() { return JSON.parse(localStorage.getItem('workoutHistory')) || []; }
        
        function displayHistory() {
            dom.historyList.innerHTML = '';
            const sortedHistory = getHistory().sort((a, b) => new Date(b.date) - new Date(a.date));

            if (sortedHistory.length === 0) {
                dom.historyList.innerHTML = '<p style="text-align: center; color: var(--sub-header-color);">Aucune séance enregistrée dans l\'historique.</p>';
                return;
            }

            sortedHistory.forEach(session => {
                const item = document.createElement('div');
                item.className = 'history-item';
                item.setAttribute('role', 'listitem');
                item.innerHTML = `
                    <div>
                        ${new Date(session.date).toLocaleDateString('fr-FR')} - 
                        <strong>${session.sessionName}</strong> (${session.totalKgRep || session.totalTonnage} kg/rep) ${session.duration ? ` - ⏱️ ${session.duration}` : ''}
                    </div>
                    <div style="display: flex; gap: var(--spacing-xs);">
                        <button class="btn btn-ghost" data-history-action="details" data-history-id="${session.id}" title="Voir les détails de ${session.sessionName}"><i class="fas fa-eye"></i></button>
                        <button class="btn btn-ghost" data-history-action="load" data-history-id="${session.id}" title="Utiliser cette séance comme modèle"><i class="fas fa-download"></i></button>
                        <button class="btn btn-ghost" data-history-action="delete" data-history-id="${session.id}" title="Supprimer ${session.sessionName} de l'historique"><i class="fas fa-trash-alt"></i></button>
                    </div>
                    <div class="history-details" id="details-${session.id}" role="region" aria-live="polite"></div>`;
                dom.historyList.appendChild(item);
            });
        }
        
        function showHistoryDetails(id) {
            const detailsDiv = document.getElementById(`details-${id}`);
            const button = detailsDiv.previousElementSibling.querySelector('[data-history-action="details"]');
            
            if (detailsDiv.classList.contains('visible')) {
                detailsDiv.classList.remove('visible');
                detailsDiv.innerHTML = '';
                button.setAttribute('aria-expanded', 'false');
            } else {
                const session = getHistory().find(s => s.id == id);
                if (session) {
                    let detailsHtml = `<h4>Détails de la Séance :</h4>
                                       <p><strong>Tonnage Total :</strong> ${session.totalTonnage || 0} kg</p>
                                       <p><strong>Total Kg/Rép :</strong> ${session.totalKgRep || 0} kg/rep</p>`;
                    if (session.notes) {
                        detailsHtml += `<p><strong>Notes :</strong> ${session.notes}</p>`;
                    }
                    detailsHtml += `<ul>`;
                    session.exercises.forEach(ex => {
                        let exerciseOneRMs = [];
                        if (ex.series && ex.series.length > 0) {
                            ex.series.forEach(s => {
                                const reps = parseFloat(String(s.reps).replace(',', '.')) || 0;
                                const weight = parseFloat(String(s.weight).replace(',', '.')) || 0;
                                if (reps > 0 && weight > 0) {
                                    exerciseOneRMs.push(calculate1RM(weight, reps));
                                }
                            });
                        }
                        let weightedAverage1RM = 0;
                        if (exerciseOneRMs.length > 0) {
                            let totalWeighted1RM = 0;
                            let totalWeightSum = 0;
                            for (let j = 0; j < exerciseOneRMs.length; j++) {
                                const positionFromEnd = exerciseOneRMs.length - 1 - j;
                                const weightFactor = 1 / (1 + positionFromEnd * 0.2);
                                totalWeighted1RM += exerciseOneRMs[j] * weightFactor;
                                totalWeightSum += weightFactor;
                            }
                            weightedAverage1RM = totalWeighted1RM / totalWeightSum;
                        }
                        const exerciseKgRep = (ex.exerciseReps > 0) ? (ex.exerciseTonnage / ex.exerciseReps).toFixed(2) : 0;

                        detailsHtml += `<li><strong>${ex.name}</strong> - Tonnage: ${ex.exerciseTonnage || 0} kg, Kg/Rép: ${exerciseKgRep} kg/rep, 1RM Moy: ${weightedAverage1RM.toFixed(1)} kg</li>`;
                    });
                    detailsHtml += '</ul>';
                    detailsDiv.innerHTML = detailsHtml;
                    detailsDiv.classList.add('visible');
                    button.setAttribute('aria-expanded', 'true');
                }
            } 
        }
        
        const escapeCsv = (str) => {
            const s = String(str || '');
            if (s.includes(';') || s.includes('"') || s.includes('\n')) {
                return `"${s.replace(/"/g, '""')}"`;
            }
            return s;
        };

        function exportCSV() {
            const history = getHistory();
            if (history.length === 0) {
                showNotification("Aucune donnée historique à exporter. Le fichier CSV est vide.", "info");
                return;
            }

            const headers = [
                "Type", "Date/ID", "Nom", "Duree", "Serie", "Reps", "Poids", "Notes"
            ];
            let csvContent = headers.join(';') + '\n';

            history.forEach((session) => {
                const sessionDate = new Date(session.date).toLocaleString('fr-FR', {
                    year: 'numeric', month: '2-digit', day: '2-digit',
                    hour: '2-digit', minute: '2-digit'
                });

                const sessionRow = [
                    "Session",
                    escapeCsv(sessionDate),
                    escapeCsv(session.sessionName),
                    escapeCsv(session.duration),
                    "", "", "",
                    escapeCsv(session.notes)
                ];
                csvContent += sessionRow.join(';') + '\n';

                session.exercises.forEach(ex => {
                    const exerciseRow = ["Exercice", "", escapeCsv(ex.name), "", "", "", "", ""];
                    csvContent += exerciseRow.join(';') + '\n';

                    if (ex.series && ex.series.length > 0) {
                        ex.series.forEach((serie, i) => {
                            const serieRow = [
                                "Serie", "", "", "", `Série ${i + 1}`,
                                escapeCsv(String(serie.reps).replace('.', ',')),
                                escapeCsv(String(serie.weight).replace('.', ',')),
                                ""
                            ];
                            csvContent += serieRow.join(';') + '\n';
                        });
                    }
                });
            });
            
            const currentSessionName = dom.sessionSelect.selectedOptions[0].text;
            const sanitizedName = currentSessionName.replace(/[\s/\\?%*:|"<>]/g, '_');
            const dateStr = new Date().toISOString().split('T')[0];
            
            const blob = new Blob([new Uint8Array([0xEF, 0xBB, 0xBF]), csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = `${sanitizedName}_${dateStr}.csv`;
            link.click();
            URL.revokeObjectURL(link.href);
            showNotification("Exportation de l'historique CSV réussie !", "success");
        }

        function parseCsvToHistory(csvContent) {
            const lines = csvContent.replace(/\r/g, '').split('\n').filter(line => line.trim() && !line.startsWith('---'));
            if (lines.length < 2) {
                showNotification("Le fichier CSV est vide ou invalide.", "error");
                return [];
            }

            const history = [];
            let currentSession = null;
            let currentExercise = null;

            for (let i = 1; i < lines.length; i++) {
                const cols = lines[i].split(';').map(c => c.trim().replace(/^"|"$/g, ''));
                const type = (cols[0] || '').toLowerCase();

                if (type === 'session') {
                    const dateString = cols[1] || '';
                    const dateParts = dateString.match(/(\d{2})\/(\d{2})\/(\d{4})\s*(\d{2}):(\d{2})/);
                    let parsedDate = dateParts ? new Date(`${dateParts[3]}-${dateParts[2]}-${dateParts[1]}T${dateParts[4]}:${dateParts[5]}:00`) : new Date(dateString);

                    if (isNaN(parsedDate.getTime())) continue;

                    currentSession = {
                        id: parsedDate.getTime() + Math.random(),
                        date: parsedDate.toISOString(),
                        sessionName: cols[2] || 'Séance importée',
                        duration: cols[3] || '00:00:00',
                        notes: cols[7] || '',
                        exercises: [],
                        totalTonnage: 0,
                        totalReps: 0,
                        totalKgRep: 0
                    };
                    history.push(currentSession);
                    currentExercise = null;
                } else if (type === 'exercice' && currentSession) {
                    currentExercise = {
                        name: cols[2] || 'Exercice inconnu',
                        rest: '1 min',
                        series: [],
                        exerciseTonnage: 0,
                        exerciseReps: 0
                    };
                    currentSession.exercises.push(currentExercise);
                } else if (type === 'serie' && currentExercise) {
                    const reps = (cols[5] || '0').replace(',', '.');
                    const weight = (cols[6] || '0').replace(',', '.');
                    if (parseFloat(reps) > 0 || parseFloat(weight) > 0) {
                        currentExercise.series.push({ reps, weight });
                    }
                }
            }

            history.forEach(session => {
                session.exercises.forEach(ex => {
                    ex.series.forEach(serie => {
                        const reps = parseFloat(serie.reps) || 0;
                        const weight = parseFloat(serie.weight) || 0;
                        ex.exerciseTonnage += reps * weight;
                        ex.exerciseReps += reps;
                    });
                    session.totalTonnage += ex.exerciseTonnage;
                    session.totalReps += ex.exerciseReps;
                });
                if (session.totalReps > 0) {
                    session.totalKgRep = (session.totalTonnage / session.totalReps).toFixed(2);
                }
            });

            return history;
        }
        
        function showNotification(message, type = 'info', duration = 5000) { 
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `<span>${message}</span>`;
            dom.notificationContainer.appendChild(notification);
            void notification.offsetWidth;
            notification.classList.add('show');
            setTimeout(() => {
                notification.classList.remove('show');
                notification.addEventListener('transitionend', () => notification.remove(), { once : true });
            }, duration);
        }

        function showUndoableNotification(message, onUndoCallback, duration = 7000) {
            const notification = document.createElement('div');
            notification.className = `notification info`; 
            notification.innerHTML = `
                <span>${message}</span>
                <button class="btn btn-secondary" id="undoBtn" style="margin-inline-start: 1rem; padding: 0.5rem 1rem; border-radius: 15px;">Annuler</button>
            `;
            dom.notificationContainer.appendChild(notification);
            void notification.offsetWidth; 
            notification.classList.add('show');
            let timer; 
            const closeNotification = () => {
                notification.classList.remove('show');
                notification.addEventListener('transitionend', () => notification.remove(), { once : true });
            };
            const undoButton = notification.querySelector('#undoBtn');
            if (undoButton) {
                undoButton.addEventListener('click', () => {
                    clearTimeout(timer); 
                    onUndoCallback(); 
                    closeNotification(); 
                });
            }
            timer = setTimeout(closeNotification, duration);
        }

        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
        }
        
        function formatTimerDisplay(seconds) {
             const m = Math.floor(seconds / 60);
             const s = Math.floor(seconds % 60);
             return `${m}:${String(s).padStart(2, '0')}`;
        }

        function updateTotalTimeDisplay() {
            if (!state.workoutStartTime) {
                dom.totalTimeEl.textContent = "00:00:00";
                return;
            }
            const elapsedSeconds = state.isWorkoutTimerPaused ? state.pausedTime : (Date.now() - new Date(state.workoutStartTime).getTime()) / 1000;
            dom.totalTimeEl.textContent = formatTime(elapsedSeconds);
        }
        
        function resetInactivityTimer() {
            clearTimeout(state.inactivityTimeout);
            if (state.workoutStartTime && !state.isWorkoutTimerPaused) {
                state.inactivityTimeout = setTimeout(() => {
                    pauseTotalWorkoutTimer();
                    showNotification("Minuteur mis en pause pour inactivité.", "info");
                }, 600000);
            }
        }

        function startInactivityAndAutoSaveTimers() {
            resetInactivityTimer();
            if (state.autoSaveInterval) clearInterval(state.autoSaveInterval);
            state.autoSaveInterval = setInterval(autoSaveSession, 2400000);
            document.addEventListener('mousemove', resetInactivityTimer);
            document.addEventListener('keydown', resetInactivityTimer);
            document.addEventListener('click', resetInactivityTimer);
            document.addEventListener('visibilitychange', handleVisibilityChange);
        }

        function stopInactivityAndAutoSaveTimers() {
            clearTimeout(state.inactivityTimeout);
            clearInterval(state.autoSaveInterval);
            state.autoSaveInterval = null;
            document.removeEventListener('mousemove', resetInactivityTimer);
            document.removeEventListener('keydown', resetInactivityTimer);
            document.removeEventListener('click', resetInactivityTimer);
            document.removeEventListener('visibilitychange', handleVisibilityChange);
        }

        function startTotalWorkoutTimer() {
            if (state.totalWorkoutTimeInterval) clearInterval(state.totalWorkoutTimeInterval);

            if (!state.workoutStartTime) {
                 state.workoutStartTime = new Date().toISOString();
                 state.pausedTime = 0; 
            } else if (state.isWorkoutTimerPaused) {
                state.workoutStartTime = new Date(Date.now() - state.pausedTime * 1000).toISOString();
            }
            
            state.isWorkoutTimerPaused = false;
            state.totalWorkoutTimeInterval = setInterval(updateTotalTimeDisplay, 1000);
            startInactivityAndAutoSaveTimers();
            updateTotalTimeDisplay(); 
            dom.timerPlayPauseIcon.textContent = '⏸️';
            dom.timerPlayPauseText.textContent = 'Pause';
            saveCurrentState();
        }

        function pauseTotalWorkoutTimer() {
            if (state.totalWorkoutTimeInterval) {
                clearInterval(state.totalWorkoutTimeInterval);
                state.totalWorkoutTimeInterval = null;
            }
            if (state.workoutStartTime) {
                state.pausedTime = (Date.now() - new Date(state.workoutStartTime).getTime()) / 1000;
            }
            state.isWorkoutTimerPaused = true;
            stopInactivityAndAutoSaveTimers();
            dom.timerPlayPauseIcon.textContent = '▶️';
            dom.timerPlayPauseText.textContent = 'Play';
            updateTotalTimeDisplay(); 
            saveCurrentState();
        }

        function handleVisibilityChange() {
            if (document.hidden) {
                if (state.workoutStartTime && !state.isWorkoutTimerPaused) {
                    pauseTotalWorkoutTimer();
                    saveCurrentState();
                }
                for (const idx in state.timers) {
                    if (state.timers[idx] && state.timers[idx].interval) {
                        clearInterval(state.timers[idx].interval);
                    }
                }
            } else {
                const inProgress = JSON.parse(localStorage.getItem('inProgressWorkout'));
                if (inProgress && inProgress.workoutStartTime) {
                    state.workoutStartTime = inProgress.workoutStartTime;
                    state.isWorkoutTimerPaused = inProgress.isWorkoutTimerPaused;
                    state.pausedTime = inProgress.pausedTime;

                    if (!state.isWorkoutTimerPaused) {
                        const elapsedSinceSave = (Date.now() - (inProgress.saveTimestamp || new Date(state.workoutStartTime).getTime())) / 1000;
                        state.pausedTime = (inProgress.pausedTime || 0) + elapsedSinceSave;
                        startTotalWorkoutTimer();
                    } else {
                        dom.totalTimeEl.textContent = formatTime(state.pausedTime);
                        dom.timerPlayPauseIcon.textContent = '▶️';
                        dom.timerPlayPauseText.textContent = 'Play';
                    }
                }
                loadPersistentIndividualTimers();
            }
        }

        function applyTheme(theme) {
            if (theme === 'dark') {
                dom.body.classList.add('dark-mode');
                dom.themeToggleBtn.innerHTML = '☀️';
                dom.themeToggleBtn.setAttribute('title', 'Passer au thème clair');
            } else {
                dom.body.classList.remove('dark-mode');
                dom.themeToggleBtn.innerHTML = '🌒';
                dom.themeToggleBtn.setAttribute('title', 'Passer au thème sombre');
            }
        }

        function updateSessionSelectOptions() {
            dom.sessionSelect.innerHTML = '';
            state.sessions.forEach((session, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = session.name; 
                dom.sessionSelect.appendChild(option);
            });
        }

        function showNewSessionModal() {
            dom.newSessionModal.classList.remove('hidden');
            dom.newSessionModal.classList.add('show');
            dom.newSessionNameInput.value = ''; 
            if (!state.isMobileView) dom.newSessionNameInput.focus(); 
            dom.newSessionNameInput.classList.remove('is-invalid');
            dom.newSessionNameError.textContent = '';
        }

        function hideNewSessionModal() {
            dom.newSessionModal.classList.remove('show');
            const triggeringElement = document.activeElement;
            dom.newSessionModal.addEventListener('transitionend', () => {
                dom.newSessionModal.classList.add('hidden');
                if (triggeringElement && typeof triggeringElement.focus === 'function') {
                    triggeringElement.focus();
                }
            }, { once : true });
        }

        async function createNewSession() {
            const newName = dom.newSessionNameInput.value.trim();
            if (!newName) {
                dom.newSessionNameInput.classList.add('is-invalid');
                dom.newSessionNameError.textContent = 'Le nom de la séance ne peut pas être vide.';
                return;
            }
            const isDuplicate = state.sessions.some(s => s.name.toLowerCase() === newName.toLowerCase());
            if (isDuplicate) {
                dom.newSessionNameInput.classList.add('is-invalid');
                dom.newSessionNameError.textContent = `Une séance nommée "${newName}" existe déjà. Veuillez choisir un nom différent.`;
                return;
            }
            dom.newSessionNameInput.classList.remove('is-invalid');
            dom.newSessionNameError.textContent = '';

            const fourSeries = [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}];
            // Point 2: New sessions are not default
            const newSession = { name: newName, isDefault: false, exercises: [{ name: "Nouvel Exercice", rest: "60s", series: fourSeries }] };
            state.sessions.push(newSession);
            updateSessionSelectOptions(); 
            state.currentSessionIndex = state.sessions.length - 1; 
            dom.sessionSelect.value = state.currentSessionIndex;
            localStorage.removeItem('inProgressWorkout');
            state.workoutStartTime = null;
            state.isWorkoutTimerPaused = false;
            state.pausedTime = 0;
            dom.totalTimeEl.textContent = "00:00:00";
            dom.timerPlayPauseIcon.textContent = '▶️';
            dom.timerPlayPauseText.textContent = 'Play';
            createTable(); 
            updateAllTotals(); 
            showNotification(`Séance "${newName}" créée avec succès !`, "success");
            hideNewSessionModal();
        }

        function updateDeleteSessionButtonState() {
            const currentSession = state.sessions[state.currentSessionIndex];
            if (currentSession) {
                dom.deleteCurrentSessionBtn.removeAttribute('disabled');
                dom.deleteCurrentSessionBtn.classList.remove('btn-outline');
                dom.deleteCurrentSessionBtn.classList.add('btn-danger');
                if (currentSession.isDefault) {
                    dom.deleteCurrentSessionBtn.setAttribute('title', 'Réinitialiser les données de cette séance par défaut');
                } else {
                    dom.deleteCurrentSessionBtn.setAttribute('title', 'Supprimer définitivement cette séance personnalisée');
                }
            } else {
                 dom.deleteCurrentSessionBtn.setAttribute('disabled', 'true');
                 dom.deleteCurrentSessionBtn.classList.remove('btn-danger');
                 dom.deleteCurrentSessionBtn.classList.add('btn-outline');
            }
        }

        // Point 2: Updated logic for deleting/resetting a session
        async function deleteCurrentSession() {
            const currentSession = state.sessions[state.currentSessionIndex];
            if (!currentSession) return;

            if (currentSession.isDefault) {
                const confirmed = await customConfirm(`Voulez-vous vraiment réinitialiser toutes les données (poids et reps) pour la séance par défaut "${currentSession.name}" ?`);
                if (confirmed) {
                    currentSession.exercises.forEach(ex => {
                        ex.series.forEach(s => {
                            s.weight = '';
                            s.reps = '';
                        });
                    });
                    createTable();
                    updateAllTotals();
                    showNotification(`Séance par défaut "${currentSession.name}" réinitialisée.`, "info");
                }
            } else {
                const confirmed = await customConfirm(`Êtes-vous sûr de vouloir supprimer définitivement la séance personnalisée "${currentSession.name}"? Cette action est irréversible.`);
                if (confirmed) {
                    state.sessions.splice(state.currentSessionIndex, 1);
                    state.currentSessionIndex = 0;
                    updateSessionSelectOptions();
                    dom.sessionSelect.value = state.currentSessionIndex;
                    localStorage.removeItem('inProgressWorkout');
                    state.workoutStartTime = null;
                    state.isWorkoutTimerPaused = false;
                    state.pausedTime = 0;
                    dom.totalTimeEl.textContent = "00:00:00";
                    dom.timerPlayPauseIcon.textContent = '▶️';
                    dom.timerPlayPauseText.textContent = 'Play';
                    createTable();
                    updateAllTotals();
                    showNotification(`Séance "${currentSession.name}" supprimée avec succès.`, "info");
                }
            }
        }


        async function openNewSessionLogic(historicalSession) {
            const confirmed = await customConfirm("Ouvrir cette séance ? La séance en cours sera remplacée et toutes les données non sauvegardées seront perdues.");
            if (!confirmed) return;
            Object.values(state.timers).forEach(timer => {
                if (timer && timer.interval) clearInterval(timer.interval);
            });
            state.timers = {};
            if (state.totalWorkoutTimeInterval) {
                clearInterval(state.totalWorkoutTimeInterval);
                state.totalWorkoutTimeInterval = null;
            }
            state.workoutStartTime = null;
            state.isWorkoutTimerPaused = false;
            state.pausedTime = 0;
            dom.timerPlayPauseIcon.textContent = '▶️';
            dom.timerPlayPauseText.textContent = 'Play';
            localStorage.removeItem('inProgressWorkout');
            dom.totalTimeEl.textContent = "00:00:00";
            dom.totalKgRepEl.textContent = "0 kg/rep";
            dom.deltaEl.textContent = "0 kg";
            dom.previousWeekInput.value = "";
            dom.sessionNotesInput.value = ""; 
            let sessionIndexToLoad = state.sessions.findIndex(s => s.name === historicalSession.sessionName);
            if (sessionIndexToLoad === -1) {
                const newTemplateExercises = historicalSession.exercises.map(ex => ({
                    name: ex.name,
                    rest: ex.rest || "1 min",
                    series: ex.series.map(s => ({weight: s.weight, reps: s.reps})) || []
                }));
                const newTemplate = { name: historicalSession.sessionName, exercises: newTemplateExercises };
                state.sessions.push(newTemplate);
                sessionIndexToLoad = state.sessions.length - 1;
                updateSessionSelectOptions(); 
            } else {
                state.sessions[sessionIndexToLoad].exercises = historicalSession.exercises.map(ex => ({
                    name: ex.name,
                    rest: ex.rest || "1 min",
                    series: ex.series.map(s => ({weight: s.weight, reps: s.reps})) || []
                }));
            }
            state.currentSessionIndex = sessionIndexToLoad;
            dom.sessionSelect.value = state.currentSessionIndex; 
            createTable();
            dom.previousWeekInput.value = historicalSession.totalKgRep || historicalSession.totalTonnage || "";
            dom.sessionNotesInput.value = historicalSession.notes || ""; 
            showNotification(`Séance "${historicalSession.sessionName}" ouverte et chargée avec succès.`, "success", 3000);
            dom.loadOptionsModal.classList.remove('show');
            const triggeringElement = document.activeElement;
            dom.loadOptionsModal.addEventListener('transitionend', () => {
                dom.loadOptionsModal.classList.add('hidden');
                if (triggeringElement && typeof triggeringElement.focus === 'function') {
                    triggeringElement.focus();
                }
            }, { once : true });
            dom.historyModal.classList.remove('show');
            dom.historyModal.addEventListener('transitionend', () => dom.historyModal.classList.add('hidden'), { once: true });
        }

        async function appendToCurrentSessionLogic(historicalSession) {
            const confirmed = await customConfirm("Ajouter/mettre à jour les exercices de cette séance à la séance en cours ? Cela écrasera les séries existantes pour les exercices ayant le même nom.");
            if (!confirmed) return;
            const currentSession = state.sessions[state.currentSessionIndex];
            if (!currentSession.exercises) {
                currentSession.exercises = []; 
            }
            let exercisesAdded = 0;
            let exercisesUpdated = 0;
            historicalSession.exercises.forEach(historicalEx => {
                const existingExIndex = currentSession.exercises.findIndex(ex => ex.name === historicalEx.name);
                if (existingExIndex !== -1) {
                    const currentEx = currentSession.exercises[existingExIndex];
                    currentEx.series = historicalEx.series.map(s => ({weight: s.weight, reps: s.reps}));
                    currentEx.exerciseTonnage = historicalEx.exerciseTonnage;
                    currentEx.exerciseReps = historicalEx.exerciseReps;
                    exercisesUpdated++;
                } else {
                    currentSession.exercises.push({
                        name: historicalEx.name,
                        rest: historicalEx.rest || "1 min",
                        series: historicalEx.series.map(s => ({weight: s.weight, reps: s.reps})),
                        exerciseTonnage: historicalEx.exerciseTonnage,
                        exerciseReps: historicalEx.exerciseReps
                    });
                    exercisesAdded++;
                }
            });
            createTable(); 
            dom.previousWeekInput.value = historicalSession.totalKgRep || historicalSession.totalTonnage || "";
            dom.sessionNotesInput.value = historicalSession.notes || ""; 
            showNotification(`${exercisesAdded} exercices ajoutés et ${exercisesUpdated} mis à jour dans la séance en cours.`, "success", 5000);
            dom.loadOptionsModal.classList.remove('show');
            const triggeringElement = document.activeElement;
            dom.loadOptionsModal.addEventListener('transitionend', () => {
                dom.loadOptionsModal.classList.add('hidden');
                if (triggeringElement && typeof triggeringElement.focus === 'function') {
                    triggeringElement.focus();
                }
            }, { once : true });
            dom.historyModal.classList.remove('show');
            dom.historyModal.addEventListener('transitionend', () => dom.historyModal.classList.add('hidden'), { once: true });
        }

        function showLoadOptionsModal(session) {
            state.sessionToLoad = session; 
            dom.loadSessionNameDisplay.textContent = session.sessionName;
            dom.loadOptionsModal.classList.remove('hidden');
            dom.loadOptionsModal.classList.add('show');
            const firstButton = dom.loadOptionsModal.querySelector('button');
            if (firstButton) firstButton.focus();
        }

        function hideLoadOptionsModal() {
            dom.loadOptionsModal.classList.remove('show');
            const triggeringElement = document.activeElement;
            dom.loadOptionsModal.addEventListener('transitionend', () => {
                dom.loadOptionsModal.classList.add('hidden');
                state.sessionToLoad = null; 
                if (triggeringElement && typeof triggeringElement.focus === 'function') {
                    triggeringElement.focus();
                }
            }, { once : true });
        }
           

        function playBeep() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.type = 'sine'; 
                oscillator.frequency.setValueAtTime(500, audioContext.currentTime); 
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.01); 
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5); 
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5); 
            } catch (error) {
                console.warn("Could not play sound.", error);
            }
        }

        function isValidAndCompleteNumber(value) {
            if (value === null || value.trim() === '') return false;
            const segments = value.trim().split('+');
            const regex = /^\d+(\.\d{1,2})?$/;

            for (const segment of segments) {
                if (segment.trim() === '' || !regex.test(segment.trim()) || parseFloat(segment.trim()) < 0) {
                    return false;
                }
            }
            return true;
        }

        function loadPersistentIndividualTimers() {
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('timer-')) {
                    const idx = parseInt(key.replace('timer-', ''), 10);
                    try {
                        const storedTimer = JSON.parse(localStorage.getItem(key));
                        if (storedTimer && storedTimer.endTime > Date.now()) {
                            const remainingSeconds = (storedTimer.endTime - Date.now()) / 1000;
                            if (remainingSeconds > 0) {
                                const element = document.querySelector(`[data-exercise-index="${idx}"]`);
                                if (element) {
                                    const timerDisplay = element.querySelector('.timer-display');
                                    const startBtn = element.querySelector('[data-timer-action="start"]');
                                    const stopBtn = element.querySelector('[data-timer-action="stop"]');

                                    if (state.timers[idx] && state.timers[idx].interval) {
                                        clearInterval(state.timers[idx].interval);
                                    }

                                    state.timers[idx] = {
                                        secondsElapsed: storedTimer.duration - remainingSeconds,
                                        duration: storedTimer.duration,
                                        interval: setInterval(() => {
                                            state.timers[idx].secondsElapsed++;
                                            const currentRemaining = state.timers[idx].duration - state.timers[idx].secondsElapsed;
                                            if (currentRemaining <= 0) {
                                                timerDisplay.textContent = formatTimerDisplay(0);
                                                timerDisplay.classList.remove('timer-active');
                                                clearInterval(state.timers[idx].interval);
                                                localStorage.removeItem(`timer-${idx}`);
                                                playBeep(); 
                                                if(Notification.permission === "granted") {
                                                    new Notification('Lyftiv - Repos Terminé !', { body: `Le temps de repos pour ${storedTimer.name} est terminé.`});
                                                }
                                                startBtn.classList.remove('hidden'); 
                                                stopBtn.classList.add('hidden'); 
                                                timerDisplay.textContent = formatTimerDisplay(storedTimer.duration); 
                                            } else {
                                                timerDisplay.textContent = formatTimerDisplay(currentRemaining); 
                                            }
                                        }, 1000)
                                    };
                                    timerDisplay.textContent = formatTimerDisplay(remainingSeconds);
                                    timerDisplay.classList.add('timer-active');
                                    startBtn.classList.add('hidden');
                                    stopBtn.classList.remove('hidden');
                                } else {
                                    localStorage.removeItem(key);
                                }
                            } else {
                                localStorage.removeItem(key);
                            }
                        } else {
                            localStorage.removeItem(key);
                        }
                    } catch (e) {
                        console.error(`Error parsing stored timer data for key ${key}:`, e);
                        localStorage.removeItem(key);
                    }
                }
            }
        }
        
        // Point 3: Function for weight auto-completion
        function handleSeriesUpdate(exerciseIndex, seriesIndex) {
            const exercise = state.sessions[state.currentSessionIndex].exercises[exerciseIndex];
            if (!exercise) return;

            const currentSeries = exercise.series[seriesIndex];
            const nextSeries = exercise.series[seriesIndex + 1];

            const currentWeight = currentSeries.weight?.trim();
            const currentReps = currentSeries.reps?.trim();

            // Check if current series is filled and there is a next series
            if (currentWeight && currentReps && nextSeries) {
                const nextSeriesWeight = nextSeries.weight?.trim();
                // If the next series weight is empty, pre-fill it
                if (!nextSeriesWeight) {
                    nextSeries.weight = currentWeight;
                    const scrollY = window.scrollY;
                    createTable(); // Redraw table to show the new value
                    window.scrollTo(0, scrollY);
                    showNotification(`Poids pré-rempli pour la série suivante.`, "info", 1500);
                }
            }
        }

        function setupEventListeners() {
            dom.sessionSelect.addEventListener('change', async () => {
                const lastSavedIndex = state.currentSessionIndex;
                if (localStorage.getItem('inProgressWorkout')) {
                    const confirmed = await customConfirm("Changer de séance annulera la séance en cours. Toutes les données non sauvegardées seront perdues. Continuer ?");
                    if (!confirmed) {
                        dom.sessionSelect.value = lastSavedIndex;
                        return;
                    }
                    for (const timerKey in state.timers) {
                        if (state.timers[timerKey] && state.timers[timerKey].interval) {
                            clearInterval(state.timers[timerKey].interval);
                            localStorage.removeItem(`timer-${timerKey}`);
                        }
                    }
                    state.timers = {};
                    if (state.totalWorkoutTimeInterval) {
                        clearInterval(state.totalWorkoutTimeInterval);
                        state.totalWorkoutTimeInterval = null;
                    }
                    state.workoutStartTime = null;
                    state.isWorkoutTimerPaused = false;
                    state.pausedTime = 0;
                    dom.timerPlayPauseIcon.textContent = '▶️';
                    dom.timerPlayPauseText.textContent = 'Play';
                    localStorage.removeItem('inProgressWorkout');
                    dom.totalTimeEl.textContent = "00:00:00";
                    dom.totalKgRepEl.textContent = "0 kg/rep";
                    dom.deltaEl.textContent = "0 kg"; 
                    dom.previousWeekInput.value = "";
                    dom.sessionNotesInput.value = ""; 
                }
                state.currentSessionIndex = +dom.sessionSelect.value;
                createTable();
                updateDeleteSessionButtonState();
            });
            
            dom.addExerciseBtn.addEventListener('click', () => {
                const name = dom.customExerciseInput.value.trim();
                if (name) {
                    const scrollY = window.scrollY;
                    updateStateFromTable();
                    if (!state.sessions[state.currentSessionIndex].exercises) {
                        state.sessions[state.currentSessionIndex].exercises = [];
                    }
                    const fourSeries = [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}];
                    state.sessions[state.currentSessionIndex].exercises.push({ name, rest: "1 min", series: fourSeries, isDefault: false });
                    createTable(); 
                    window.scrollTo(0, scrollY);
                    dom.customExerciseInput.value = '';
                    showNotification(`Exercice "${name}" ajouté avec succès.`, "info");
                    dom.autocompleteSuggestions.classList.remove('show');
                    dom.autocompleteSuggestions.addEventListener('transitionend', () => {
                        dom.autocompleteSuggestions.classList.add('hidden');
                        dom.autocompleteSuggestions.innerHTML = ''; 
                    }, { once: true });
                } else {
                    showNotification("Veuillez entrer un nom d'exercice à ajouter.", "error");
                }
            });

            dom.exerciseListContainer.addEventListener('blur', (e) => {
                if (e.target.classList.contains('reps') || e.target.classList.contains('weight')) {
                    handleNumericInput(e);
                    // Point 3: Trigger auto-completion on blur
                    const exIndex = +e.target.dataset.ex;
                    const serieIndex = +e.target.dataset.serie;
                    updateStateFromTable(); // First, save the current input value to the state
                    handleSeriesUpdate(exIndex, serieIndex); // Then, check for auto-completion
                }
            }, true);


            dom.exerciseListContainer.addEventListener('input', e => { 
                if (e.target.classList.contains('reps') || e.target.classList.contains('weight')) {
                    if (!state.workoutStartTime) {
                        startTotalWorkoutTimer();
                    }
                    updateAllTotals(); 
                }
            });

            dom.exerciseListContainer.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    const target = e.target;
                    if (target.classList.contains('weight') || target.classList.contains('reps')) {
                        e.preventDefault();
                        target.blur();
                    }
                }
            });

            // MODIFICATION POINT 4: Event listeners for double-click and long-press
            
            // --- Long Press Logic (to delete the entire series) ---
            const pressHandler = (e) => {
                const button = e.target.closest('.serie-input-delete');
                if (!button) return;

                // Set a timer. If it fires, it's a long press.
                state.pressTimer = setTimeout(() => {
                    if (navigator.vibrate) navigator.vibrate(50); // Haptic feedback

                    const scrollY = window.scrollY;
                    const exIndex = +button.dataset.ex;
                    const serieIndex = +button.dataset.serie;
                    const exercise = state.sessions[state.currentSessionIndex].exercises[exIndex];

                    if (exercise.series.length > 1) {
                        exercise.series.splice(serieIndex, 1);
                        createTable();
                        window.scrollTo(0, scrollY);
                        updateAllTotals();
                        showNotification(`Série ${serieIndex + 1} supprimée.`, "info", 2000);
                    } else {
                        showNotification("Un exercice doit avoir au moins une série.", "error", 3000);
                    }
                }, 500); // 500ms for a long press
            };

            // This handler simply clears the timer if the press is released too early.
            const releaseHandler = (e) => {
                clearTimeout(state.pressTimer);
            };

            // Add listeners for long press
            dom.exerciseListContainer.addEventListener('mousedown', pressHandler);
            dom.exerciseListContainer.addEventListener('mouseup', releaseHandler);
            dom.exerciseListContainer.addEventListener('mouseleave', releaseHandler, true);
            dom.exerciseListContainer.addEventListener('touchstart', pressHandler);
            dom.exerciseListContainer.addEventListener('touchend', releaseHandler);
            dom.exerciseListContainer.addEventListener('touchcancel', releaseHandler, true);


            // --- Double Click Logic (to clear the series data) ---
            dom.exerciseListContainer.addEventListener('dblclick', (e) => {
                const button = e.target.closest('.serie-input-delete');
                if (!button) return;

                // A dblclick event will also fire mousedown/mouseup.
                // We clear the long-press timer to prevent it from firing.
                clearTimeout(state.pressTimer);

                const scrollY = window.scrollY;
                const exIndex = +button.dataset.ex;
                const serieIndex = +button.dataset.serie;
                const exercise = state.sessions[state.currentSessionIndex].exercises[exIndex];

                if (exercise && exercise.series[serieIndex]) {
                    exercise.series[serieIndex].weight = '';
                    exercise.series[serieIndex].reps = '';
                    createTable();
                    window.scrollTo(0, scrollY);
                    updateAllTotals();
                    showNotification(`Données de la série ${serieIndex + 1} effacées.`, "info", 2000);
                }
            });


            dom.previousWeekInput.addEventListener('input', updateAllTotals); 
            dom.exerciseListContainer.addEventListener('click', handleTableActions); 
            document.getElementById('finishSessionBtn').addEventListener('click', finishAndSaveSession);
            document.getElementById('viewHistoryBtn').addEventListener('click', () => {
                const triggeringElement = document.activeElement;
                displayHistory(); 
                dom.historyModal.classList.remove('hidden'); 
                dom.historyModal.classList.add('show');
                dom.closeHistoryModal.focus(); 
                dom.historyModal.addEventListener('transitionend', () => {
                    if (dom.historyModal.classList.contains('hidden') && triggeringElement && typeof triggeringElement.focus === 'function') {
                        triggeringElement.focus();
                    }
                }, { once : true });
            });
            dom.historyModal.addEventListener('click', handleHistoryActions);
            dom.exportBtn.addEventListener('click', exportCSV); 
            dom.importBtn.addEventListener('click', () => dom.importFileInput.click());

            dom.importFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) {
                    showNotification("Aucun fichier sélectionné pour l'importation.", "info");
                    return;
                }

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const content = e.target.result;
                        let importedData;

                        if (file.name.endsWith('.json')) {
                            importedData = JSON.parse(content);
                        } else if (file.name.endsWith('.csv')) {
                            importedData = parseCsvToHistory(content);
                        } else {
                            showNotification("Format de fichier non pris en charge. Veuillez utiliser un fichier .json ou .csv.", "error");
                            return;
                        }

                        let currentHistory = getHistory();
                        let newEntriesCount = 0;
                        let updatedEntriesCount = 0;
                        
                        importedData.forEach(importedSession => {
                            const existingIndex = currentHistory.findIndex(s => s.id === importedSession.id);
                            if (existingIndex !== -1) {
                                currentHistory[existingIndex] = importedSession;
                                updatedEntriesCount++;
                            } else {
                                currentHistory.push(importedSession);
                                newEntriesCount++;
                            }
                        });

                        localStorage.setItem('workoutHistory', JSON.stringify(currentHistory));
                        displayHistory();
                        showNotification(`${newEntriesCount} séances importées et ${updatedEntriesCount} mises à jour avec succès.`, "success");

                    } catch (error) {
                        console.error("Erreur lors de l'importation du fichier:", error);
                        showNotification("Une erreur est survenue lors du traitement du fichier. Veuillez vérifier son format.", "error");
                    } finally {
                        event.target.value = '';
                    }
                };
                reader.readAsText(file, 'UTF-8');
            });

            document.getElementById('closeHistoryModal').addEventListener('click', () => {
                dom.historyModal.classList.remove('show');
                const triggeringElement = document.activeElement;
                dom.historyModal.addEventListener('transitionend', () => {
                    dom.historyModal.classList.add('hidden');
                    if (triggeringElement && typeof triggeringElement.focus === 'function') {
                        triggeringElement.focus();
                    }
                }, { once : true });
            });
            dom.themeToggleBtn.addEventListener('click', () => {
                const newTheme = dom.body.classList.contains('dark-mode') ? 'light' : 'dark';
                applyTheme(newTheme);
                localStorage.setItem('theme', newTheme);
            });
            dom.toggleWorkoutTimerBtn.addEventListener('click', () => {
                if (state.isWorkoutTimerPaused) {
                    startTotalWorkoutTimer();
                } else {
                    pauseTotalWorkoutTimer();
                }
            });
            dom.createNewSessionTypeBtn.addEventListener('click', showNewSessionModal);
            dom.deleteCurrentSessionBtn.addEventListener('click', deleteCurrentSession);
            dom.closeNewSessionModal.addEventListener('click', hideNewSessionModal);
            dom.cancelNewSessionBtn.addEventListener('click', hideNewSessionModal);
            dom.createNewSessionBtn.addEventListener('click', createNewSession);
            dom.closeLoadOptionsModal.addEventListener('click', hideLoadOptionsModal);
            dom.openNewSessionBtn.addEventListener('click', async () => { 
                if (state.sessionToLoad) await openNewSessionLogic(state.sessionToLoad);
            });
            dom.appendToCurrentSessionBtn.addEventListener('click', async () => { 
                if (state.sessionToLoad) await appendToCurrentSessionLogic(state.sessionToLoad);
            });

            if (dom.plateCalculatorBtn) {
                dom.plateCalculatorBtn.addEventListener('click', () => {
                    const triggeringElement = document.activeElement;
                    dom.plateCalculatorModal.classList.remove('hidden');
                    dom.plateCalculatorModal.classList.add('show');
                    const firstInput = dom.plateCalculatorModal.querySelector('input, button');
                    if (firstInput) firstInput.focus();
                    dom.plateCalculatorModal.addEventListener('transitionend', () => {
                        if (dom.plateCalculatorModal.classList.contains('hidden') && triggeringElement && typeof triggeringElement.focus === 'function') {
                            triggeringElement.focus();
                        }
                    }, { once : true });
                });
            }

            dom.closePlateCalculatorModal.addEventListener('click', () => {
                dom.plateCalculatorModal.classList.remove('show');
                const triggeringElement = document.activeElement;
                dom.plateCalculatorModal.addEventListener('transitionend', () => {
                    dom.plateCalculatorModal.classList.add('hidden');
                    if (triggeringElement && typeof triggeringElement.focus === 'function') {
                        triggeringElement.focus();
                    }
                }, { once : true });
            });
            if (dom.targetWeightInput) {
                dom.targetWeightInput.addEventListener('input', calculatePlates);
            }
            if (dom.barbellWeightInput) {
                dom.barbellWeightInput.addEventListener('input', calculatePlates);
            }
            
            document.querySelectorAll('input[name="oneRmInputMode"]').forEach(radio => {
                radio.addEventListener('change', (event) => {
                    if (event.target.value === 'manual') {
                        dom.oneRmManualInput.classList.remove('hidden');
                        dom.oneRmSelectInput.classList.add('hidden');
                        dom.oneRmInput.focus();
                        dom.oneRmExerciseSelect.value = '';
                    } else {
                        dom.oneRmManualInput.classList.add('hidden');
                        dom.oneRmSelectInput.classList.remove('hidden');
                        dom.oneRmExerciseSelect.focus();
                        dom.oneRmInput.value = '';
                        calculateTrainingGoals();
                    }
                });
            });

            if (dom.oneRmExerciseSelect) {
                dom.oneRmExerciseSelect.addEventListener('change', () => {
                    dom.oneRmInput.value = dom.oneRmExerciseSelect.value;
                    calculateTrainingGoals();
                });
            }

            if (dom.oneRmInput) {
                dom.oneRmInput.addEventListener('input', calculateTrainingGoals);
            }

            if (dom.plateCalcTab) {
                dom.plateCalcTab.addEventListener('click', () => {
                    dom.plateCalcTab.classList.add('active');
                    dom.plateCalcTab.setAttribute('aria-selected', 'true');
                    dom.goalCalcTab.classList.remove('active');
                    dom.goalCalcTab.setAttribute('aria-selected', 'false');
                    dom.plateCalcContent.classList.remove('hidden');
                    dom.goalCalcContent.classList.add('hidden');
                    const firstInput = dom.plateCalcContent.querySelector('input, button');
                    if (firstInput) firstInput.focus();
                });
            }

            if (dom.goalCalcTab) {
                dom.goalCalcTab.addEventListener('click', () => {
                    dom.goalCalcTab.classList.add('active');
                    dom.goalCalcTab.setAttribute('aria-selected', 'true');
                    dom.plateCalcTab.classList.remove('active');
                    dom.plateCalcTab.setAttribute('aria-selected', 'false');
                    dom.goalCalcContent.classList.remove('hidden');
                    dom.plateCalcContent.classList.add('hidden');
                    const firstInput = dom.goalCalcContent.querySelector('input, button');
                    if (firstInput) firstInput.focus();
                });
            }

            dom.closeQuickEditModal.addEventListener('click', () => {
                dom.quickEditModal.classList.remove('show');
                const triggeringElement = document.activeElement;
                dom.quickEditModal.addEventListener('transitionend', () => {
                    dom.quickEditModal.classList.add('hidden');
                    if (triggeringElement && typeof triggeringElement.focus === 'function') {
                        triggeringElement.focus();
                    }
                }, { once : true });
            });
            dom.applyQuickEditBtn.addEventListener('click', () => {
                const weightValid = validateInputField(dom.quickEditWeight, dom.quickEditWeightError, true);
                const repsValid = validateInputField(dom.quickEditReps, dom.quickEditRepsError, true);

                if (!weightValid || !repsValid) {
                    showNotification("Veuillez corriger les erreurs pour appliquer l'édition rapide.", "error");
                    return;
                }

                if (state.quickEditIndex !== null) {
                    const weight = dom.quickEditWeight.value;
                    const reps = dom.quickEditReps.value;
                    const exerciseToUpdate = state.sessions[state.currentSessionIndex].exercises[state.quickEditIndex];
                    exerciseToUpdate.series.forEach((s, i) => {
                        exerciseToUpdate.series[i].weight = weight;
                        exerciseToUpdate.series[i].reps = reps;
                    });
                    
                    createTable();
                    updateAllTotals();
                    dom.quickEditModal.classList.remove('show');
                    const triggeringElement = document.activeElement;
                    dom.quickEditModal.addEventListener('transitionend', () => {
                        dom.quickEditModal.classList.add('hidden');
                        if (triggeringElement && typeof triggeringElement.focus === 'function') {
                            triggeringElement.focus();
                        }
                    }, { once : true });
                    showNotification("Séries mises à jour rapidement !", "success");
                }
            });

            document.addEventListener('keydown', e => {
                if (e.ctrlKey || e.metaKey) { 
                    if (e.key === 's') { e.preventDefault(); finishAndSaveSession(); } 
                    if (e.key === 'e') { e.preventDefault(); exportCSV(); } 
                }
                if (e.key === 'Escape') { 
                    if (dom.historyModal.classList.contains('show')) {
                        dom.historyModal.classList.remove('show');
                        dom.historyModal.addEventListener('transitionend', () => dom.historyModal.classList.add('hidden'), { once : true });
                    }
                    if (dom.newSessionModal.classList.contains('show')) {
                        dom.newSessionModal.classList.remove('show');
                        dom.newSessionModal.addEventListener('transitionend', () => dom.newSessionModal.classList.add('hidden'), { once : true });
                    }
                    if (dom.loadOptionsModal.classList.contains('show')) {
                        hideLoadOptionsModal();
                    }
                    if (dom.plateCalculatorModal.classList.contains('show')) {
                        dom.plateCalculatorModal.classList.remove('show');
                        dom.plateCalculatorModal.addEventListener('transitionend', () => dom.plateCalculatorModal.classList.add('hidden'), { once : true });
                    }
                    if (dom.quickEditModal.classList.contains('show')) {
                        dom.quickEditModal.classList.remove('show');
                        dom.quickEditModal.addEventListener('transitionend', () => dom.quickEditModal.classList.add('hidden'), { once: true });
                    }
                    if (dom.pwaInstallPrompt.classList.contains('show')) {
                        dom.pwaInstallPrompt.classList.remove('show');
                        dom.pwaInstallPrompt.addEventListener('transitionend', () => dom.pwaInstallPrompt.classList.add('hidden'), { once: true });
                        localStorage.setItem('pwaPromptDismissed', 'true');
                    }
                }
            });

            dom.bottomAddExerciseBtn.addEventListener('click', () => {
                dom.addExerciseSection.scrollIntoView({ behavior: 'smooth' });
                if (!state.isMobileView) {
                    setTimeout(() => {
                        dom.customExerciseInput.focus();
                    }, 300);
                }
            });
            dom.bottomNotesBtn.addEventListener('click', () => {
                state.isNotesSectionVisible = !state.isNotesSectionVisible;
                if (state.isNotesSectionVisible) {
                    dom.sessionNotesSection.classList.add('show-notes-section');
                    dom.sessionNotesSection.classList.remove('hide-notes-section');
                    if (!state.isMobileView) dom.sessionNotesInput.focus();
                    dom.sessionNotesSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                } else {
                    dom.sessionNotesSection.classList.remove('show-notes-section');
                    dom.sessionNotesSection.classList.add('hide-notes-section');
                }
            });
            dom.bottomScrollBtn.addEventListener('click', () => {
                const currentScrollY = window.scrollY;
                const windowHeight = window.innerHeight;
                const documentHeight = document.documentElement.scrollHeight;
            
                const distanceToTop = currentScrollY;
                const distanceToBottom = documentHeight - windowHeight - currentScrollY;
            
                if (distanceToBottom > distanceToTop) {
                    window.scrollTo({ top: documentHeight, behavior: 'smooth' });
                } else {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            });
            dom.bottomViewHistoryBtn.addEventListener('click', () => {
                displayHistory(); 
                dom.historyModal.classList.remove('hidden'); 
                dom.historyModal.classList.add('show');
                dom.closeHistoryModal.focus();
            });
            dom.bottomPlateCalculatorBtn.addEventListener('click', () => {
                dom.plateCalculatorModal.classList.remove('hidden');
                dom.plateCalculatorModal.classList.add('show');
                dom.closePlateCalculatorModal.focus();
            });
        }

        init();
    });
    </script>
    <script type="application/json" id="manifest-json">
    {
      "name": "Lyftiv",
      "short_name": "Lyftiv",
      "description": "Suivi de Séance Musculation",
      "start_url": "./index.html",
      "display": "standalone",
      "background_color": "#eff6ff",
      "theme_color": "#6a90ff",
      "icons": [
        {
          "src": "/icons/icon-192x192.png",
          "sizes": "192x192",
          "type": "image/png"
        },
        {
          "src": "/icons/icon-512x512.png",
          "sizes": "512x512",
          "type": "image/png"
        }
      ]
    }
    </script>
</body>
</html>
