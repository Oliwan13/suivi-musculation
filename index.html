<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <script>
      // Prevents "Flash of Incorrect Theme" (FOIT)
      (function() {
        function getInitialTheme() {
          const persistedTheme = window.localStorage.getItem('theme');
          if (persistedTheme) {
            return persistedTheme;
          }
          const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
          return systemPrefersDark ? 'dark' : 'light';
        }

        const theme = getInitialTheme();
        if (theme === 'dark') {
          // Use a class on <html> to apply styles before the body exists.
          document.documentElement.classList.add('dark-mode-preload');
        }
      })();
    </script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self'; 
        script-src 'self' 'unsafe-inline'; 
        style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://cdnjs.cloudflare.com; 
        font-src 'self' https://fonts.gstatic.com https://cdnjs.cloudflare.com;
        connect-src 'self';
        img-src 'self' data:;
        object-src 'none';
        base-uri 'self';
        form-action 'self';
    ">
    <meta name="theme-color" content="#e9f2ff" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#2a2d38" media="(prefers-color-scheme: dark)">
    <link rel="manifest" href="manifest.json">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">

    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="app.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <noscript>
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
      <link rel="stylesheet" href="app.css">
    </noscript>
    <meta name="robots" content="noindex, nofollow">
    <title>Lyftiv - Suivi S√©ance Musculation</title>
    
    <style>
/* CSS Cascade Layers - Base, Components, Utilities */
@layer base, components, utilities;

@layer base {
    :root {
        /* Color System */
        --color-blue-base: 220 60% 50%;
        --color-green-base: 140 50% 45%;
        --color-orange-base: 40 70% 50%;
        --color-red-base: 0 60% 50%;
        --color-cyan-base: 200 60% 50%;

        /* Backgrounds and Surfaces */
        --color-background-gradient-start: hsl(200, 60%, 95%);
        --color-background-gradient-end: hsl(220, 70%, 98%);
        --color-surface-default: hsla(0, 0%, 100%, 0.95);
        --color-surface-muted: hsla(210, 15%, 98%, 0.7);
        --color-surface-input: white;
        
        /* Text Colors */
        --color-text-default: hsl(220, 15%, 30%);
        --color-text-header: hsl(220, 20%, 20%);
        --color-text-subheader: hsl(220, 10%, 45%);
        --color-text-on-accent: hsl(0, 0%, 100%);

        /* Border Color */
        --color-border-default: hsl(210, 15%, 90%);

        /* Primary Colors */
        --color-primary-default: hsl(var(--color-blue-base));
        --color-primary-gradient-start: hsl(220, 60%, 70%);
        --color-primary-gradient-end: hsl(240, 70%, 75%);

        /* Success Colors */
        --color-success-default: hsl(var(--color-green-base));
        --color-success-gradient-start: hsl(140, 60%, 70%);
        --color-success-gradient-end: hsl(160, 70%, 75%);

        /* Warning Colors */
        --color-warning-default: hsl(var(--color-orange-base));
        --color-warning-gradient-start: hsl(40, 80%, 75%);
        --color-warning-gradient-end: hsl(30, 90%, 80%);

        /* Danger Colors */
        --color-danger-default: hsl(var(--color-red-base));
        --color-danger-gradient-start: hsl(0, 60%, 75%);
        --color-danger-gradient-end: hsl(10, 70%, 80%);

        /* Info Colors */
        --color-info-default: hsl(var(--color-cyan-base));
        --color-info-gradient-start: hsl(200, 70%, 70%);
        --color-info-gradient-end: hsl(210, 80%, 75%);

        /* Shadow System */
        --shadow-xs: hsla(220, 20%, 20%, 0.02);
        --shadow-sm: hsla(220, 20%, 20%, 0.04);
        --shadow-md: hsla(220, 20%, 20%, 0.08);
        --shadow-lg: hsla(220, 20%, 20%, 0.15);
        --shadow-xl: hsla(220, 20%, 20%, 0.25);
        --shadow-strong: hsla(220, 20%, 20%, 0.4);

        /* Radius System */
        --radius-xs: 6px;
        --radius-base: 12px;
        --radius-medium: 18px;
        --radius-large: 24px;
        --radius-button: 30px;
        
        /* Spacing System */
        --spacing-xxs: 0.125rem; /* 2px */
        --spacing-xs: 0.25rem;  /* 4px */
        --spacing-sm: 0.5rem;   /* 8px */
        --spacing-md: 1rem;     /* 16px */
        --spacing-lg: 1.5rem;   /* 24px */
        --spacing-xl: 2rem;     /* 32px */
        --spacing-xxl: 3rem;    /* 48px */
        --spacing-xxxl: 4rem;   /* 64px */

        /* Typography Scale */
        --font-size-sm: 0.85rem;
        --font-size-base: 1rem;
        --font-size-lg: 1.15rem;
        --font-size-xl: 1.25rem;
        --font-size-2xl: clamp(2rem, 1.5rem + 2.5vw, 2.75rem);

        color-scheme: light dark;

        /* Button Gradients & Shadows */
        --btn-primary-bg: linear-gradient(135deg, var(--color-primary-gradient-start), var(--color-primary-gradient-end)), radial-gradient(circle at 30% 30%, hsla(220, 60%, 80%, 0.3), transparent);
        --btn-secondary-bg: linear-gradient(135deg, var(--color-warning-gradient-start), var(--color-warning-gradient-end));
        --btn-danger-bg: linear-gradient(135deg, var(--color-danger-gradient-start), var(--color-danger-gradient-end));
        --btn-success-bg: linear-gradient(135deg, var(--color-success-gradient-start), var(--color-success-gradient-end));
        --btn-info-bg: linear-gradient(135deg, var(--color-info-gradient-start), var(--color-info-gradient-end));
        
        --btn-shadow-normal: 0 4px 10px var(--shadow-sm);
        --btn-shadow-hover: 0 7px 14px var(--shadow-md);
        --btn-shadow-active: 0 2px 5px var(--shadow-sm);
    }

    /* MODIFIED: Added html.dark-mode-preload to prevent flash of incorrect theme */
    body.dark-mode,
    html.dark-mode-preload body {
        /* Dark Mode Colors */
        --color-background-gradient-start: hsl(230, 20%, 18%);
        --color-background-gradient-end: hsl(245, 25%, 22%);
        --color-surface-default: hsla(220, 20%, 25%, 0.95);
        --color-surface-muted: hsla(220, 20%, 20%, 0.7);
        --color-surface-input: hsl(220, 20%, 20%);
        
        --color-text-default: hsl(210, 15%, 80%);
        --color-text-header: hsl(210, 10%, 75%);
        --color-text-subheader: hsl(210, 10%, 60%);
        --color-text-on-accent: hsl(0, 0%, 90%);

        --color-border-default: hsl(220, 15%, 35%);

        --color-primary-default: hsl(220, 60%, 65%);
        --color-primary-gradient-start: hsl(220, 30%, 40%);
        --color-primary-gradient-end: hsl(240, 35%, 45%);

        --color-success-default: hsl(140, 50%, 60%);
        --color-success-gradient-start: hsl(140, 30%, 40%);
        --color-success-gradient-end: hsl(160, 35%, 45%);

        --color-warning-default: hsl(40, 70%, 65%);
        --color-warning-gradient-start: hsl(40, 45%, 50%);
        --color-warning-gradient-end: hsl(30, 50%, 55%);
        
        --color-danger-default: hsl(0, 60%, 65%);
        --color-danger-gradient-start: hsl(0, 35%, 45%);
        --color-danger-gradient-end: hsl(10, 40%, 50%);
        
        --color-info-default: hsl(200, 60%, 65%);
        --color-info-gradient-start: hsl(200, 45%, 50%);
        --color-info-gradient-end: hsl(210, 50%, 55%);

        --shadow-xs: hsla(220, 20%, 10%, 0.1);
        --shadow-sm: hsla(220, 20%, 10%, 0.2);
        --shadow-md: hsla(220, 20%, 10%, 0.3);
        --shadow-lg: hsla(220, 20%, 10%, 0.4);
        --shadow-xl: hsla(220, 20%, 10%, 0.5);
        --shadow-strong: hsla(220, 20%, 10%, 0.6);
    }
    html.dark-mode-preload body .exercise-card .btn-info,
    html.dark-mode-preload body .exercise-card .btn-secondary {
         color: hsl(0, 0%, 95%);
    }

    /* Reduced Motion Support */
    @media (prefers-reduced-motion: reduce) {
        *, *::before, *::after {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
        }
    }

    /* Enhanced Focus Management */
    :focus-visible {
        outline: 3px solid var(--color-info-default);
        outline-offset: 3px;
        border-radius: var(--radius-xs);
    }
    :focus:not(:focus-visible) {
        outline: none;
    }
    select:focus-visible, 
    input:focus-visible, 
    textarea:focus-visible {
        outline: none;
        border-color: var(--color-primary-default);
        box-shadow: 0 0 0 4px hsla(220, 60%, 75%, 0.3);
    }
    .modal-content:focus-within {
        box-shadow: 0 0 0 3px var(--color-info-default), 0 20px 40px var(--shadow-xl);
    }

} /* End @layer base */

@layer components {
    /* Critical styles required for initial paint */
    * { box-sizing: border-box; }
    html { scroll-behavior: smooth; }
    body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        font-size: var(--font-size-base); 
        line-height: 1.6; 
        margin: 0;
        padding: var(--spacing-xxl);
        background: linear-gradient(135deg, var(--color-background-gradient-start) 0%, var(--color-background-gradient-end) 100%);
        min-height: 100vh;
        color: var(--color-text-default);
        transition: background 0.6s ease, color 0.6s ease;
    }

    /* Dashboard is part of the initial view */
    .dashboard-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: flex-start;
        justify-content: center;
        background: linear-gradient(135deg, var(--color-background-gradient-start) 0%, var(--color-background-gradient-end) 100%);
        z-index: 2000;
        opacity: 1;
        visibility: visible;
        transition: opacity 0.5s ease-out, visibility 0.5s ease-out;
        padding: var(--spacing-lg);
        overflow-y: auto;
    }

    .dashboard-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        max-width: 900px;
        width: 100%;
        padding: var(--spacing-xl) 0;
    }

    .dashboard-header {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-md);
        margin-bottom: var(--spacing-lg);
    }

    .dashboard-header .lyftiv-logo {
        width: clamp(40px, 32px + 2.5vw, 52px);
        height: clamp(40px, 32px + 2.5vw, 52px);
    }

    .dashboard-header .app-name {
        font-size: clamp(2rem, 1.5rem + 2.5vw, 2.75rem);
        font-weight: 800;
        color: var(--color-text-header);
        letter-spacing: -0.03em;
    }

    .dashboard-content h1 {
        font-size: clamp(1.8rem, 1.5rem + 1.5vw, 2.5rem);
        color: var(--color-text-header);
        margin-bottom: var(--spacing-md);
        font-weight: 700;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-md);
    }
    
    .dashboard-intro {
        max-width: 60ch;
        margin-bottom: var(--spacing-xxl);
        font-size: var(--font-size-lg);
        color: var(--color-text-subheader);
        line-height: 1.7;
    }

    .session-selector {
        width: 100%;
        margin-bottom: var(--spacing-xxxl);
    }
    
    .session-selector-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: var(--spacing-lg);
    }
    
    .session-card {
        background: var(--color-surface-default);
        border-radius: var(--radius-large);
        padding: var(--spacing-lg);
        text-align: center;
        border: 1px solid var(--color-border-default);
        box-shadow: 0 5px 15px var(--shadow-sm);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-sm);
        color: var(--color-text-default);
    }
    
    .session-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 10px 25px var(--shadow-md);
    }

    .session-card-icon {
        font-size: 2.5rem;
        margin-bottom: var(--spacing-sm);
        line-height: 1;
    }
    
    .session-card h3 {
        font-size: var(--font-size-lg);
        font-weight: 600;
        color: var(--color-text-header);
        margin: 0;
    }
    
    .session-card p {
        font-size: var(--font-size-sm);
        color: var(--color-text-subheader);
        margin: 0;
    }
    
    .session-card.create-new {
        border-style: dashed;
        border-width: 2px;
        background: transparent;
    }
    
    .session-card.create-new h3 {
        color: var(--color-primary-default);
    }
    
    .app-guide {
        width: 100%;
        text-align: left;
    }
    
    .app-guide h2 {
        text-align: center;
        font-size: var(--font-size-xl);
        color: var(--color-text-header);
        margin-bottom: var(--spacing-lg);
    }

    .app-guide-accordion {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-md);
    }
    
    .app-guide-accordion details {
        background: var(--color-surface-default);
        border: 1px solid var(--color-border-default);
        border-radius: var(--radius-base);
        padding: var(--spacing-md);
    }
    
    .app-guide-accordion summary {
        cursor: pointer;
        font-weight: 600;
        color: var(--color-text-header);
        list-style: none;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .app-guide-accordion summary::after {
        content: '‚ñº';
        transition: transform 0.2s ease;
    }
    
    .app-guide-accordion details[open] summary::after {
        transform: rotate(180deg);
    }

    .app-guide-accordion details > div {
        padding-top: var(--spacing-md);
        color: var(--color-text-subheader);
    }
    
    .app-guide-accordion details p {
        margin: 0 0 var(--spacing-sm) 0;
    }
    
    .app-guide-accordion details i {
        color: var(--color-info-default);
        margin-right: var(--spacing-xs);
    }


    #app-container.hidden, .dashboard-container.hidden {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
    }
    
    h2 {
        text-align: center;
        color: var(--color-text-header);
        margin-bottom: var(--spacing-xxl);
        font-size: var(--font-size-2xl);
        font-weight: 800;
        letter-spacing: -0.03em;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-md);
    }
    .lyftiv-logo {
        width: clamp(40px, 32px + 2.5vw, 52px);
        height: clamp(40px, 32px + 2.5vw, 52px);
    }
    
    .timer-btn {
        padding: var(--spacing-sm) var(--spacing-md);
        min-width: 44px;
        min-height: 44px;
        border: none;
        border-radius: var(--radius-button);
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 600;
        color: var(--color-text-on-accent);
        transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease; 
        box-shadow: 0 3px 8px var(--shadow-sm);
        will-change: transform, box-shadow, background-color;
    }
    .timer-btn:hover { 
        transform: translateY(-2px);
        box-shadow: 0 4px 10px var(--shadow-md);
    }
    .timer-btn[data-timer-action="start"] { background: var(--btn-success-bg); }
    .timer-btn[data-timer-action="stop"] { background: var(--btn-danger-bg); }
    .timer-btn[data-timer-action="reset"] { background: var(--btn-secondary-bg); }
    .timer-display { 
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--color-text-default);
        transition: color 0.3s ease;
        will-change: color;
    }
    .timer-display.timer-active { 
        color: var(--color-success-default);
        animation: pulse 1.2s infinite; 
        font-weight: 700;
    }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
    
    .btn, button { 
        padding: var(--spacing-md) var(--spacing-xl);
        min-height: 44px;
        min-width: 44px;
        border: none; 
        border-radius: var(--radius-button);
        cursor: pointer; 
        font-size: var(--font-size-base);
        font-weight: 600; 
        font-family: 'Inter', sans-serif;
        color: var(--color-text-on-accent);
        transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
        box-shadow: var(--btn-shadow-normal);
        will-change: transform, box-shadow, background-color;
        text-transform: none;
    }
    .btn:hover {
        transform: translateY(-3px);
        box-shadow: var(--btn-shadow-hover);
    }
    .btn:not(:disabled):active {
        transform: translateY(-1px) scale(0.98);
        box-shadow: var(--btn-shadow-active);
    }
    .btn:disabled, .btn.is-disabled {
        cursor: not-allowed;
        opacity: 0.6;
        background: var(--color-border-default);
        box-shadow: none;
        transform: none;
    }

    .btn-primary { background: var(--btn-primary-bg); }
    .btn-secondary { background: var(--btn-secondary-bg); }
    .btn-danger { background: var(--btn-danger-bg); }
    .btn-success { background: var(--btn-success-bg); }
    .btn-info { background: var(--btn-info-bg); }
    
    .hidden { display: none !important; }

} /* End @layer components */

@layer utilities {
    .flex-center {
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
    }

    .icon-primary { color: var(--color-primary-default); }
    .icon-success { color: var(--color-success-default); }
    .icon-warning { color: var(--color-warning-default); }
    .icon-danger { color: var(--color-danger-default); }
    .icon-info { color: var(--color-info-default); }
} /* End @layer utilities */

    </style>
</head>
<body>
    <a href="#app-container" class="sr-only">Passer au contenu principal</a>
    
    <div id="dashboard" class="dashboard-container">
        <div class="dashboard-content">
            <header class="dashboard-header">
                <svg class="lyftiv-logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="lyftivLogoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" stop-color="hsl(200, 80%, 85%)" />
                            <stop offset="100%" stop-color="hsl(260, 60%, 85%)" />
                        </linearGradient>
                    </defs>
                    <rect x="0" y="0" width="100" height="100" rx="20" ry="20" fill="url(#lyftivLogoGradient)"/>
                    <path d="M 15 50 C 15 35 30 30 50 30 C 70 30 85 35 85 50 C 85 65 70 70 50 70 C 30 70 15 65 15 50 Z M 25 50 L 75 50 M 25 35 L 25 65 M 75 35 L 75 65" stroke="hsl(220, 60%, 55%)" stroke-width="3.5" fill="none" stroke-linecap="round"/>
                    <circle cx="25" cy="50" r="14" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                    <circle cx="25" cy="50" r="10" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                    <circle cx="25" cy="50" r="6" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                    <circle cx="75" cy="50" r="14" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                    <circle cx="75" cy="50" r="10" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                    <circle cx="75" cy="50" r="6" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                    <rect x="35" y="48.5" width="30" height="3" rx="1.5" ry="1.5" fill="white"/>
                </svg>
                <span class="app-name">Lyftiv</span>
            </header>
    
            <section class="session-selector" aria-labelledby="session-selector-title">
                <h2 id="session-selector-title" class="sr-only">Choisissez votre s√©ance</h2>
                <div class="session-selector-grid" id="sessionSelectorGrid">
                </div>
            </section>
    
            <section class="app-guide" aria-labelledby="app-guide-title">
                <h2 id="app-guide-title">Ma√Ætrisez Lyftiv</h2>
                <div class="app-guide-accordion">
                    <details>
                        <summary><strong>Les Calculateurs : Votre Assistant Personnel</strong></summary>
                        <div>
                            <p><strong>Calculateur de Plaques :</strong> Fini les maths ! Dites-lui le poids que vous visez, il vous dit quelles plaques mettre sur la barre.</p>
                            <p><strong>Calculateur d'Objectifs :</strong> Entrez votre record (1RM), et il vous donne les poids parfaits pour vos objectifs : prendre du muscle (hypertrophie) ou gagner en force.</p>
                        </div>
                    </details>
                    <details>
                        <summary><strong>Le Jargon du Fitness, simplifi√©</strong></summary>
                        <div>
                             <p><strong>Kg/R√©p :</strong> La charge moyenne que vous soulevez √† chaque r√©p√©tition. Un chiffre qui doit augmenter avec le temps !</p>
                             <p><strong>1RM (R√©p√©tition Maximale) :</strong> Une estimation de la charge maximale que vous pouvez soulever une seule fois. C'est la base pour calculer vos objectifs.</p>
                        </div>
                    </details>
                    <details>
                        <summary><strong>Les Fonctions "Pro" √† conna√Ætre</strong></summary>
                        <div>
                            <p><i class="fas fa-link"></i> <strong>Le Superset :</strong> Liez deux exercices pour les encha√Æner sans repos.</p>
                            <p><i class="fas fa-play"></i> <strong>Le Minuteur :</strong> Lancez-le √† la fin d'un exercice pour un temps de repos parfait.</p>
                            <p><i class="fas fa-history"></i> <strong>L'Historique :</strong> Retrouvez toutes vos s√©ances pass√©es pour suivre vos progr√®s.</p>
                        </div>
                    </details>
                </div>
            </section>
        </div>
    </div>
    
    <div id="app-container" class="hidden">
        <main class="main-container">
            <div class="theme-switcher">
                <button id="homeBtn" class="btn" aria-label="Retourner √† l'accueil" title="Accueil">
                    <i class="fas fa-home"></i>
                </button>
                <button id="themeToggleBtn" class="btn" aria-label="Changer de th√®me"></button>
            </div>
            <h2>
                <svg class="lyftiv-logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="lyftivLogoGradientMain" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" stop-color="hsl(200, 80%, 85%)" />
                            <stop offset="100%" stop-color="hsl(260, 60%, 85%)" />
                        </linearGradient>
                    </defs>
                    <rect x="0" y="0" width="100" height="100" rx="20" ry="20" fill="url(#lyftivLogoGradientMain)"/>
                    <path d="M 15 50 C 15 35 30 30 50 30 C 70 30 85 35 85 50 C 85 65 70 70 50 70 C 30 70 15 65 15 50 Z M 25 50 L 75 50 M 25 35 L 25 65 M 75 35 L 75 65" stroke="hsl(220, 60%, 55%)" stroke-width="3.5" fill="none" stroke-linecap="round"/>
                    <circle cx="25" cy="50" r="14" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                    <circle cx="25" cy="50" r="10" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                    <circle cx="25" cy="50" r="6" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                    <circle cx="75" cy="50" r="14" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                    <circle cx="75" cy="50" r="10" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                    <circle cx="75" cy="50" r="6" stroke="hsl(220, 60%, 55%)" stroke-width="2" fill="none"/>
                    <rect x="35" y="48.5" width="30" height="3" rx="1.5" ry="1.5" fill="white"/>
                </svg>
                Lyftiv
            </h2>
            
            <div class="controls">
              <label for="sessionSelect"><strong>S√©ance:</strong></label>
              <select id="sessionSelect" aria-label="S√©lectionner une s√©ance d'entra√Ænement">
                </select>
              <button class="btn btn-outline" id="createNewSessionTypeBtn" aria-label="Cr√©er une nouvelle s√©ance">Nouvelle s√©ance</button>
              <button class="btn btn-danger" id="deleteCurrentSessionBtn" aria-label="Supprimer la s√©ance actuelle" title="Supprimer la s√©ance actuelle (personnalis√©e)">Supprimer la s√©ance</button>
              <button class="btn btn-secondary" id="resetCurrentSessionBtn" aria-label="R√©initialiser les donn√©es de la s√©ance actuelle" title="Vider toutes les donn√©es (poids et reps) de la s√©ance">R√©initialiser</button>
              </div>
            
            <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" id="progressBar" aria-label="Progression de la s√©ance">
              <div class="progress-fill" id="progressFill"></div>
            </div>
            
            <div id="exerciseListContainer" class="exercise-list-container">
                </div>
            
            <section class="controls add-exercise-section" id="addExerciseSection" aria-labelledby="addExerciseTitle">
                <h2 id="addExerciseTitle" class="sr-only">Ajouter un exercice</h2>
                <div class="input-group">
                    <input type="text" id="customExercise" placeholder="Ajouter un exercice" aria-label="Nom de l'exercice personnalis√©" autocomplete="off">
                    <button class="btn btn-success" id="addExerciseBtn" aria-label="Ajouter l'exercice"> Ajouter</button>
                </div>
            </section>
    
            <section class="summary-section" aria-labelledby="summarySectionTitle">
                <h2 id="summarySectionTitle" class="sr-only">R√©sum√© de la s√©ance</h2>
                <div class="summary-card">
                    <span class="card-icon fas fa-bullseye" aria-hidden="true"></span>
                    <h3>Total kg/r√©p</h3> <div class="value" id="totalKgRep" aria-live="polite">0 kg/rep</div> </div>
                <div class="summary-card">
                    <span class="card-icon fas fa-calendar-alt" aria-hidden="true"></span>
                    <h3>Semaine pr√©c√©dente</h3>
                    <input type="text" inputmode="decimal" id="previousWeek" placeholder="kg/rep" aria-label="Performance de la semaine pr√©c√©dente" pattern="^\d+([.,]\d{1,2})?$" autocomplete="off">
                </div>
                <div class="summary-card">
                    <span class="card-icon fas fa-chart-line" aria-hidden="true"></span>
                    <h3>Progression</h3>
                    <div class="value" id="delta" aria-live="polite">0 kg</div>
                </div>
                <div class="summary-card">
                    <span class="card-icon fas fa-clock" aria-hidden="true"></span>
                    <h3>Temps total</h3>
                    <div class="value" id="totalTime" aria-live="polite">00:00:00</div>
                    <div class="timer-controls">
                        <button id="toggleWorkoutTimerBtn" class="btn btn-secondary" aria-label="Mettre en pause ou reprendre le minuteur">
                            <span id="timerPlayPauseIcon" class="fas fa-play" aria-hidden="true"></span>
                            <span id="timerPlayPauseText">D√©marrer</span>
                        </button>
                        <button id="resetWorkoutTimerBtn" class="btn btn-danger" aria-label="R√©initialiser le minuteur">
                            <i class="fas fa-redo" aria-hidden="true"></i>
                            <span>R√©initialiser</span>
                        </button>
                    </div>
                </div>
            </section>
    
            <section class="controls session-notes-section" id="sessionNotesSection" aria-labelledby="sessionNotesTitle">
                <h2 id="sessionNotesTitle" class="sr-only">Notes de s√©ance</h2>
                <label for="sessionNotes"><strong>Notes de s√©ance:</strong></label>
                <textarea id="sessionNotes" placeholder="Ajouter des notes sur la s√©ance..." aria-label="Notes de s√©ance"></textarea>
            </section>
            
            <section class="action-buttons" aria-labelledby="actionButtonsTitle">
                <h2 id="actionButtonsTitle" class="sr-only">Actions principales</h2>
                <button class="btn btn-success" id="finishSessionBtn" aria-label="Terminer et Sauvegarder la s√©ance">Terminer & sauvegarder</button>
                <button class="btn btn-primary" id="viewHistoryBtn" aria-label="Voir l'historique">Historique</button>
                <button class="btn btn-primary" id="plateCalculatorBtn" aria-label="Ouvrir les calculateurs">Calculateurs</button>
            </section>
    
            <section class="action-buttons" style="margin-top: var(--spacing-md);" aria-labelledby="dataManagementTitle">
                <h2 id="dataManagementTitle" class="sr-only">Gestion des donn√©es</h2>
                <button class="btn btn-info" id="exportBtn" aria-label="Exporter les donn√©es">Exporter</button>
                <button class="btn btn-info" id="importBtn" aria-label="Importer les donn√©es">Importer</button>
            </section>
            <input type="file" id="importFile" class="hidden" accept=".json,.csv" aria-label="Fichier d'importation">
        </main> 
    </div>
    
    <div id="notification-container" aria-live="polite" aria-atomic="true"></div>
    
    <div id="pwaInstallPrompt" class="hidden" role="dialog" aria-modal="true" aria-labelledby="pwaInstallTitle">
        <span id="pwaInstallTitle" style="font-weight: 600;">Ajoutez Lyftiv √† votre √©cran d'accueil !</span>
        <button id="installPwaBtn" aria-label="Installer l'application">Installer</button>
        <button id="closePwaPrompt" class="close-btn" aria-label="Fermer le message d'installation">&times;</button>
    </div>

    <div id="historyModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="historyModalTitle">
      <div class="modal-content">
          <button id="closeHistoryModal" class="modal-close-btn" aria-label="Fermer le modal historique">&times;</button>
          <h2 id="historyModalTitle">Historique des s√©ances</h2>
          <div id="historyList" aria-live="polite"></div>
      </div>
    </div>

    <div id="newSessionModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="newSessionModalTitle">
        <div class="modal-content">
            <button id="closeNewSessionModal" class="modal-close-btn" aria-label="Fermer le modal de nouvelle s√©ance">&times;</button>
            <h2 id="newSessionModalTitle">Cr√©er une nouvelle s√©ance</h2>
            <div class="input-group-modal">
                <input type="text" id="newSessionNameInput" placeholder="Nom de la nouvelle s√©ance" aria-label="Nom de la nouvelle s√©ance" aria-describedby="newSessionNameError" autocomplete="off">
                <div id="newSessionNameError" class="error-message"></div>
            </div>
            <div style="display: flex; justify-content: center; gap: var(--spacing-md); margin-top: var(--spacing-lg);">
                <button class="btn btn-outline" id="cancelNewSessionBtn"> Annuler</button>
                <button class="btn btn-success" id="createNewSessionBtn"> Cr√©er</button>
            </div>
        </div>
    </div>

    <div id="loadOptionsModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="loadOptionsModalTitle">
      <div class="modal-content">
          <button id="closeLoadOptionsModal" class="modal-close-btn" aria-label="Fermer le modal d'options de chargement">&times;</button>
          <h2 id="loadOptionsModalTitle">Options de chargement</h2>
          <p>Comment utiliser la s√©ance "<strong id="loadSessionName"></strong>" ?</p>
          <div style="display: flex; justify-content: center; gap: var(--spacing-md); margin-top: var(--spacing-lg);">
              <button class="btn btn-primary" id="openNewSessionBtn">Ouvrir (remplace la s√©ance actuelle)</button>
              <button class="btn btn-secondary" id="appendToCurrentSessionBtn">Ajouter √† la s√©ance actuelle</button>
          </div>
      </div>
    </div>

    <div id="plateCalculatorModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="plateCalcModalTitle">
        <div class="modal-content">
            <button id="closePlateCalculatorModal" class="modal-close-btn" aria-label="Fermer le modal du calculateur">&times;</button>
            <div class="modal-tabs" role="tablist">
                <button class="modal-tab-btn active" id="goalCalcTab" aria-controls="goalCalcContent" role="tab" aria-selected="true">Objectifs d'entra√Ænement</button>
                <button class="modal-tab-btn" id="plateCalcTab" aria-controls="plateCalcContent" role="tab" aria-selected="false">Calculateur de plaques</button>
            </div>
            
            <div id="plateCalcContent" class="modal-tab-content hidden" role="tabpanel" aria-labelledby="plateCalcTab">
                <h2 id="plateCalcModalTitle">Calculateur de plaques</h2>
                <div class="controls">
                    <div class="input-group-modal">
                        <input type="text" inputmode="decimal" id="targetWeightInput" placeholder="Poids cible (kg)" aria-label="Poids cible" pattern="^\d+([.,]\d{1,2})?$" aria-describedby="targetWeightError" autocomplete="off">
                        <div id="targetWeightError" class="error-message"></div>
                    </div>
                    <div class="input-group-modal">
                        <input type="text" inputmode="decimal" id="barbellWeightInput" placeholder="Poids barre (kg)" aria-label="Poids de la barre" pattern="^\d+([.,]\d{1,2})?$" aria-describedby="barbellWeightError" autocomplete="off">
                        <div id="barbellWeightError" class="error-message"></div>
                    </div>
                </div>
                <div id="platesResult" style="text-align: left; margin-top: var(--spacing-lg);"></div>
            </div>

            <div id="goalCalcContent" class="modal-tab-content" role="tabpanel" aria-labelledby="goalCalcTab">
                <h2>Objectifs d'entra√Ænement</h2>
                <div class="controls">
                    <div style="display: flex; justify-content: center; gap: var(--spacing-md); margin-bottom: var(--spacing-md);">
                        <label>
                            <input type="radio" name="oneRmInputMode" value="manual" checked> Saisie Manuelle
                        </label>
                        <label>
                            <input type="radio" name="oneRmInputMode" value="select"> S√©lection d'Exercice
                        </label>
                    </div>

                    <div id="oneRmManualInput" class="input-group-modal">
                        <input type="text" inputmode="decimal" id="oneRmInput" placeholder="Votre 1RM (kg)" aria-label="Votre 1RM" pattern="^\d+([.,]\d{1,2})?$" aria-describedby="oneRmError" autocomplete="off">
                        <div id="oneRmError" class="error-message"></div>
                    </div>

                    <div id="oneRmSelectInput" class="input-group-modal hidden">
                        <select id="oneRmExerciseSelect" aria-label="S√©lectionner un exercice pour le 1RM">
                            <option value="">-- S√©lectionner un exercice --</option>
                        </select>
                    </div>
                </div>
                <div id="goalResultsContainer"></div>
            </div>
        </div>
    </div>
    
    <div id="quickEditModal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="quickEditModalTitle">
      <div class="modal-content">
          <button id="closeQuickEditModal" class="modal-close-btn" aria-label="Fermer le modal d'√©dition rapide">&times;</button>
          <h2 id="quickEditModalTitle">√âdition rapide</h2>
          <p>Appliquer √† toutes les s√©ries de : <strong id="quickEditExerciseName"></strong></p>
          <div class="controls">
              <div class="input-group-modal">
                  <input type="text" inputmode="decimal" id="quickEditWeight" placeholder="Poids (kg)" aria-label="Poids pour √©dition rapide" pattern="^\d+([.,]\d{1,2})?$" aria-describedby="quickEditWeightError" autocomplete="off">
                  <div id="quickEditWeightError" class="error-message"></div>
              </div>
              <div class="input-group-modal">
                  <input type="text" inputmode="decimal" id="quickEditReps" placeholder="Reps" aria-label="R√©p√©titions pour √©dition rapide" pattern="^\d+([.,]\d{1,2})?$" aria-describedby="quickEditRepsError" autocomplete="off">
                  <div id="quickEditRepsError" class="error-message"></div>
              </div>
          </div>
          <button class="btn btn-success" id="applyQuickEditBtn" style="width: 100%; margin-top: var(--spacing-md);"> Appliquer</button>
      </div>
    </div>

    <nav class="bottom-navigation" aria-label="Navigation principale">
        <button class="btn btn-primary" id="bottomAddExerciseBtn" aria-label="Ajouter un exercice">
            <i class="fas fa-plus-circle"></i>
            <span>Exercice</span>
        </button>
        <button class="btn btn-primary" id="bottomNotesBtn" aria-label="Notes de s√©ance">
            <i class="fas fa-clipboard"></i>
            <span>Notes</span>
        </button>
        <button class="btn btn-primary" id="bottomViewHistoryBtn" aria-label="Historique">
            <i class="fas fa-history"></i>
            <span>Historique</span>
        </button>
        <button class="btn btn-primary" id="bottomPlateCalculatorBtn" aria-label="Calculateurs">
            <i class="fas fa-calculator"></i>
            <span>Calculs</span>
        </button>
        <button class="btn btn-primary" id="bottomScrollBtn" aria-label="Faire d√©filer la page">
            <i class="fas fa-arrows-alt-v"></i>
            <span>D√©filer</span>
        </button>
    </nav>

    <script>
    window.addEventListener('load', () => {

        // --- Accessible Modal Utility ---
        let lastActiveElement;

        function openModal(modalElement) {
            if (!modalElement) return;
            
            lastActiveElement = document.activeElement;
            
            document.getElementById('app-container').inert = true;
            document.getElementById('dashboard').inert = true;

            modalElement.classList.remove('hidden');
            modalElement.classList.add('show');
            
            const firstFocusable = modalElement.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
            if (firstFocusable) {
                firstFocusable.focus();
            }
            
            document.addEventListener('keydown', handleModalKeydown);
        }

        function closeModal(modalElement) {
            if (!modalElement || modalElement.classList.contains('hidden')) return;

            modalElement.classList.remove('show');
            
            const onTransitionEnd = () => {
                modalElement.classList.add('hidden');
                document.getElementById('app-container').inert = false;
                document.getElementById('dashboard').inert = false;
                if (lastActiveElement) {
                    lastActiveElement.focus();
                }
                modalElement.removeEventListener('transitionend', onTransitionEnd);
            };
            modalElement.addEventListener('transitionend', onTransitionEnd);
            
            document.removeEventListener('keydown', handleModalKeydown);
        }

        function handleModalKeydown(e) {
            if (e.key === 'Escape') {
                const openedModal = document.querySelector('.modal-overlay.show');
                if (openedModal) {
                    closeModal(openedModal);
                }
            }
            if (e.key === 'Tab') {
                const openedModal = document.querySelector('.modal-overlay.show .modal-content');
                if(openedModal) trapFocus(e, openedModal);
            }
        }

        function trapFocus(e, modalElement) {
            const focusableElements = Array.from(modalElement.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')).filter(el => !el.disabled && el.offsetWidth > 0 && el.offsetHeight > 0);
            if (focusableElements.length === 0) return;
            
            const firstElement = focusableElements[0];
            const lastElement = focusableElements[focusableElements.length - 1];

            if (e.shiftKey) { 
                if (document.activeElement === firstElement) {
                    lastElement.focus();
                    e.preventDefault();
                }
            } else {
                if (document.activeElement === lastElement) {
                    firstElement.focus();
                    e.preventDefault();
                }
            }
        }
        // --- End Accessible Modal Utility ---
        
        const dashboard = document.getElementById('dashboard');
        const appContainer = document.getElementById('app-container');
        const sessionSelectorGrid = document.getElementById('sessionSelectorGrid');

        function populateDashboard() {
            sessionSelectorGrid.innerHTML = '';
            const allSessions = state.sessions;

            allSessions.forEach((session, index) => {
                const card = document.createElement('button');
                card.className = 'session-card';
                card.dataset.sessionIndex = index;
                const icon = session.name.toLowerCase().includes('haut') ? 'üèãÔ∏è‚Äç‚ôÇÔ∏è' : 
                             session.name.toLowerCase().includes('bas') ? 'ü¶µ' : '';
                card.innerHTML = `
                    <span class="session-card-icon">${icon}</span>
                    <h3>${session.name}</h3>
                    <p>${session.exercises.length} exercices</p>
                `;
                card.addEventListener('click', () => startSessionFromDashboard(index));
                sessionSelectorGrid.appendChild(card);
            });

            const createCard = document.createElement('button');
            createCard.className = 'session-card create-new';
            createCard.id = 'dashboard-create-session-btn';
            createCard.innerHTML = `
                <span class="session-card-icon">‚ûï</span>
                <h3>Cr√©er une s√©ance</h3>
                <p>B√¢tissez votre propre entra√Ænement</p>
            `;
            createCard.addEventListener('click', () => {
                dashboard.classList.add('hidden');
                appContainer.classList.remove('hidden');
                sessionStorage.setItem('dashboardShown', 'true');
                showNewSessionModal();
            });
            sessionSelectorGrid.appendChild(createCard);
        }

        function startSessionFromDashboard(sessionIndex) {
            dom.sessionSelect.value = sessionIndex;
            state.currentSessionIndex = +sessionIndex;
            createTable();
            updateDeleteSessionButtonState();

            dashboard.classList.add('hidden');
            appContainer.classList.remove('hidden');
            sessionStorage.setItem('dashboardShown', 'true');
        }
        
        if (sessionStorage.getItem('dashboardShown')) {
            dashboard.classList.add('hidden');
            appContainer.classList.remove('hidden');
        } else {
            appContainer.classList.add('hidden');
            dashboard.classList.remove('hidden');
        }


        function init() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                applyTheme(savedTheme);
            } else {
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');
                applyTheme(prefersDark.matches ? 'dark' : 'light');
                prefersDark.addEventListener('change', (e) => {
                    if (!localStorage.getItem('theme')) {
                        applyTheme(e.matches ? 'dark' : 'light');
                    }
                });
            }
            
            const inProgress = JSON.parse(localStorage.getItem('inProgressWorkout'));
            if (inProgress) {
                state.sessions = Array.isArray(inProgress.customSessions) ? inProgress.customSessions : JSON.parse(JSON.stringify(defaultSessions));
                state.currentSessionIndex = inProgress.sessionIndex || 0;
                if (state.currentSessionIndex >= state.sessions.length) {
                    state.currentSessionIndex = 0;
                }

                if (inProgress.workoutStartTime) {
                    state.workoutStartTime = inProgress.workoutStartTime;
                    state.isWorkoutTimerPaused = inProgress.isWorkoutTimerPaused;
                    state.totalPausedDuration = inProgress.totalPausedDuration || 0;

                    if (!state.isWorkoutTimerPaused) {
                        state.pauseStartTime = inProgress.pauseStartTime;
                        startTotalWorkoutTimer();
                    } else {
                        state.pauseStartTime = inProgress.pauseStartTime || Date.now();
                        updateTotalTimeDisplay();
                        updateTimerToggleButtonUI(true);
                    }
                }
            } else {
                 state.sessions = JSON.parse(JSON.stringify(defaultSessions));
                 localStorage.removeItem('inProgressWorkout');
            }
            
            if (state.isMobileView) {
                dom.sessionNotesSection.classList.add('hide-notes-section');
                state.isNotesSectionVisible = false;
            } else {
                dom.sessionNotesSection.classList.add('show-notes-section');
                state.isNotesSectionVisible = true;
            }

            if (!sessionStorage.getItem('dashboardShown')) {
                populateDashboard();
            }

            updateSessionSelectOptions(); 
            dom.sessionSelect.value = state.currentSessionIndex;
            createTable();
            setupEventListeners();
            loadPersistentIndividualTimers();

            window.addEventListener('resize', () => {
                const newIsMobileView = window.matchMedia("(max-width: 768px)").matches;
                if (newIsMobileView !== state.isMobileView) {
                    state.isMobileView = newIsMobileView;
                    createTable();
                    if (state.isMobileView && !state.isNotesSectionVisible) {
                        dom.sessionNotesSection.classList.add('hide-notes-section');
                    } else {
                        dom.sessionNotesSection.classList.remove('hide-notes-section');
                        dom.sessionNotesSection.classList.add('show-notes-section');
                    }
                }
            });

            state.isInitialized = true;
        }

        const dom = {
            sessionSelect: document.getElementById('sessionSelect'),
            exerciseListContainer: document.getElementById('exerciseListContainer'),
            totalKgRepEl: document.getElementById('totalKgRep'),
            previousWeekInput: document.getElementById('previousWeek'),
            deltaEl: document.getElementById('delta'),
            totalTimeEl: document.getElementById('totalTime'),
            progressFill: document.getElementById('progressFill'),
            historyModal: document.getElementById('historyModal'),
            closeHistoryModal: document.getElementById('closeHistoryModal'),
            notificationContainer: document.getElementById('notification-container'),
            customExerciseInput: document.getElementById('customExercise'),
            addExerciseBtn: document.getElementById('addExerciseBtn'),
            historyList: document.getElementById('historyList'),
            importFileInput: document.getElementById('importFile'),
            themeToggleBtn: document.getElementById('themeToggleBtn'),
            homeBtn: document.getElementById('homeBtn'),
            body: document.body,
            toggleWorkoutTimerBtn: document.getElementById('toggleWorkoutTimerBtn'),
            resetWorkoutTimerBtn: document.getElementById('resetWorkoutTimerBtn'),
            newSessionModal: document.getElementById('newSessionModal'),
            closeNewSessionModal: document.getElementById('closeNewSessionModal'),
            newSessionNameInput: document.getElementById('newSessionNameInput'),
            cancelNewSessionBtn: document.getElementById('cancelNewSessionBtn'),
            createNewSessionBtn: document.getElementById('createNewSessionBtn'),
            createNewSessionTypeBtn: document.getElementById('createNewSessionTypeBtn'),
            deleteCurrentSessionBtn: document.getElementById('deleteCurrentSessionBtn'),
            resetCurrentSessionBtn: document.getElementById('resetCurrentSessionBtn'),
            loadOptionsModal: document.getElementById('loadOptionsModal'),
            closeLoadOptionsModal: document.getElementById('closeLoadOptionsModal'),
            loadSessionNameDisplay: document.getElementById('loadSessionName'),
            openNewSessionBtn: document.getElementById('openNewSessionBtn'),
            appendToCurrentSessionBtn: document.getElementById('appendToCurrentSessionBtn'),
            plateCalculatorModal: document.getElementById('plateCalculatorModal'),
            closePlateCalculatorModal: document.getElementById('closePlateCalculatorModal'),
            plateCalculatorBtn: document.getElementById('plateCalculatorBtn'),
            targetWeightInput: document.getElementById('targetWeightInput'),
            barbellWeightInput: document.getElementById('barbellWeightInput'),
            platesResult: document.getElementById('platesResult'),
            sessionNotesInput: document.getElementById('sessionNotes'),
            addExerciseSection: document.getElementById('addExerciseSection'),
            quickEditModal: document.getElementById('quickEditModal'),
            closeQuickEditModal: document.getElementById('closeQuickEditModal'),
            quickEditExerciseName: document.getElementById('quickEditExerciseName'),
            quickEditWeight: document.getElementById('quickEditWeight'),
            quickEditReps: document.getElementById('quickEditReps'),
            applyQuickEditBtn: document.getElementById('applyQuickEditBtn'),
            plateCalcTab: document.getElementById('plateCalcTab'),
            goalCalcTab: document.getElementById('goalCalcTab'),
            plateCalcContent: document.getElementById('plateCalcContent'),
            goalCalcContent: document.getElementById('goalCalcContent'),
            oneRmInput: document.getElementById('oneRmInput'),
            oneRmManualInput: document.getElementById('oneRmManualInput'),
            oneRmSelectInput: document.getElementById('oneRmSelectInput'),
            oneRmExerciseSelect: document.getElementById('oneRmExerciseSelect'),
            goalResultsContainer: document.getElementById('goalResultsContainer'),
            timerPlayPauseIcon: document.getElementById('timerPlayPauseIcon'),
            timerPlayPauseText: document.getElementById('timerPlayPauseText'),
            bottomAddExerciseBtn: document.getElementById('bottomAddExerciseBtn'),
            bottomScrollBtn: document.getElementById('bottomScrollBtn'),
            bottomViewHistoryBtn: document.getElementById('bottomViewHistoryBtn'),
            bottomPlateCalculatorBtn: document.getElementById('bottomPlateCalculatorBtn'),
            bottomNotesBtn: document.getElementById('bottomNotesBtn'),
            sessionNotesSection: document.getElementById('sessionNotesSection'),
            exportBtn: document.getElementById('exportBtn'),
            importBtn: document.getElementById('importBtn'),
            newSessionNameError: document.getElementById('newSessionNameError'),
            targetWeightError: document.getElementById('targetWeightError'),
            barbellWeightError: document.getElementById('barbellWeightError'),
            oneRmError: document.getElementById('oneRmError'),
            quickEditWeightError: document.getElementById('quickEditWeightError'),
            quickEditRepsError: document.getElementById('quickEditRepsError'),
            progressBar: document.getElementById('progressBar'),
            pwaInstallPrompt: document.getElementById('pwaInstallPrompt'),
            installPwaBtn: document.getElementById('installPwaBtn'),
            closePwaPrompt: document.getElementById('closePwaPrompt')
        };

        let state = {
            sessions: [], 
            currentSessionIndex: 0,
            timers: {},
            workoutStartTime: null,
            totalWorkoutTimeInterval: null,
            isWorkoutTimerPaused: true,
            totalPausedDuration: 0,
            pauseStartTime: 0,
            sessionToLoad: null,
            lastDeletedExercise: null,
            linkingState: { active: false, fromIndex: null }, 
            quickEditIndex: null,
            isMobileView: window.matchMedia("(max-width: 768px)").matches,
            isNotesSectionVisible: false,
            deferredPwaPrompt: null,
            isInitialized: false,
            pressTimer: null
        };
        
        const defaultSessions = [
          {
            name: "Haut du corps (force)",
            exercises: [
              { name: "D√©velopp√© couch√© barre", rest: "2 min", series: [] },
              { name: "Machine √©l√©vations lat√©rales debout", rest: "", series: [] },
              { name: "Tractions", rest: "1.5 min", series: [] },
              { name: "D√©velopp√© inclin√© halt√®res", rest: "", series: [] },
              { name: "Rowing T-barre appuy√©", rest: "1.5 min", series: [] },
              { name: "Pec deck", rest: "", series: [] },
              { name: "Bayesian cable curl", rest: "1.25 min", series: [] },
              { name: "Extension triceps √† la poulie haute", rest: "", series: [] },
              { name: "Tractions scapulaires", rest: "1 min", series: [] }
            ]
          },
          {
            name: "Bas du corps (force)",
            exercises: [
              { name: "Fentes bulgares", rest: "1.5 min", series: [] },
              { name: "Hack squat", rest: "3 min", series: [] },
              { name: "Hip thrust", rest: "2 min", series: [] },
              { name: "Soulev√© de terre roumain", rest: "2 min", series: [] },
              { name: "Mollets debout", rest: "1 min", series: [] }
            ]
          },
          {
            name: "Haut du corps (hypertrophie)",
            exercises: [
              { name: "Dips", rest: "1.5 min", series: [] },
              { name: "Tirage vertical prise large", rest: "", series: [] },
              { name: "D√©velopp√© convergent", rest: "1.25 min", series: [] },
              { name: "Curl pupitre", rest: "1.25 min", series: [] },
              { name: "Extension triceps overhead", rest: "", series: [] },
              { name: "√âl√©vations lat√©rales √† la poulie", rest: "1 min", series: [] },
              { name: "Flexions poignets supination", rest: "1 min", series: [] },
              { name: "Extensions de poignets pronation", rest: "", series: [] },
              { name: "Farmer‚Äôs walk", rest: "1.5 min", series: [] },
              { name: "Planche", rest: "", series: [] },
              { name: "Face pull", rest: "", series: [] }
            ]
          },
          {
            name: "Bas du corps (hypertrophie)",
            exercises: [
              { name: "Pendulum squat", rest: "1.5 min", series: [] },
              { name: "Hip thrust", rest: "1.5 min", series: [] },
              { name: "Leg curl assis", rest: "1.25 min", series: [] },
              { name: "Mollets assis", rest: "1 min", series: [] },
              { name: "Glute ham raise", rest: "", series: [] },
              { name: "Circuit abdos (relev√© de jambe, crunches, planche)", rest: "1.5 min", series: [] }
            ]
          },
          {
            name: "Sp√©cialisation trap√®zes & mobilit√©",
            exercises: [
              { name: "Barbell shrugs", rest: "1 min", series: [] },
              { name: "Face pull", rest: "1 min", series: [] },
              { name: "Cable y-raise", rest: "1 min", series: [] },
              { name: "Dead hang", rest: "1 min", series: [] }
            ]
          },
          {
            name: "Routine de mobilit√©",
            exercises: [
              { name: "Pass-throughs avec √©lastique", rest: "", series: ["2 x 15"] },
              { name: "Wall slides (glissements au mur)", rest: "", series: ["2 x 12"] },
              { name: "Cercles de t√™te lents", rest: "", series: ["1 x 5 dans chaque sens"] },
              { name: "R√©traction du menton", rest: "", series: ["2 x 10"] },
              { name: "90/90 stretch", rest: "", series: ["2 x 30s par c√¥t√©"] },
              { name: "√âtirement du canap√© (couch stretch)", rest: "", series: ["2 x 30s par c√¥t√©"] },
              { name: "Maintien en squat profond", rest: "", series: ["2 x 45-60s"] }
            ]
          }
        ];
        
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            state.deferredPwaPrompt = e;
            if (localStorage.getItem('pwaPromptDismissed') !== 'true') {
                openModal(dom.pwaInstallPrompt);
            }
        });

        dom.installPwaBtn.addEventListener('click', async () => {
            if (state.deferredPwaPrompt) {
                state.deferredPwaPrompt.prompt();
                const { outcome } = await state.deferredPwaPrompt.userChoice;
                if (outcome === 'accepted') {
                    showNotification('Lyftiv a √©t√© ajout√© √† votre √©cran d\'accueil!', 'success', 5000);
                }
                state.deferredPwaPrompt = null;
                closeModal(dom.pwaInstallPrompt);
            }
        });

        dom.closePwaPrompt.addEventListener('click', () => {
            closeModal(dom.pwaInstallPrompt);
            localStorage.setItem('pwaPromptDismissed', 'true');
        });
        
        function validateInputField(inputElement, errorDisplayElement, allowEmpty = false) {
            const value = inputElement.value.trim();
            if (allowEmpty && value === '') {
                inputElement.classList.remove('is-invalid');
                errorDisplayElement.textContent = '';
                return true;
            }
            const regex = /^\d+([.,]\d{1,2})?$/;
            if (!regex.test(value) || parseFloat(value.replace(',', '.')) < 0) {
                inputElement.classList.add('is-invalid');
                errorDisplayElement.textContent = 'Veuillez entrer un nombre positif valide.';
                return false;
            } else {
                inputElement.classList.remove('is-invalid');
                errorDisplayElement.textContent = '';
                return true;
            }
        }

        function handleNumericInput(e) {
            const input = e.target;
            let value = input.value.replace(/,/g, '.');
            const segments = value.split('+').map(s => s.trim());
            const validatedSegments = segments.filter(s => {
                if (s === '') return true;
                const num = parseFloat(s);
                return !isNaN(num) && num >= 0;
            });
            input.value = validatedSegments.join('+');
        }

        function getPlateCombinationOptimal(target, denominations) {
            let currentRemaining = target;
            const platesUsed = {};
            let loadedWeight = 0;
            for (const plateValue of denominations) {
                const numPlates = Math.floor(currentRemaining / plateValue);
                if (numPlates > 0) {
                    platesUsed[plateValue] = numPlates;
                    loadedWeight += numPlates * plateValue;
                    currentRemaining -= (numPlates * plateValue);
                    currentRemaining = parseFloat(currentRemaining.toFixed(2)); 
                }
            }
            return { plates: platesUsed, loadedWeight: loadedWeight, remaining: currentRemaining };
        }

        function getPlateCombinationAlternative(target, fullDenominations) {
            let currentRemaining = target;
            const platesUsed = {};
            const alternativeOrder = [20, 10, 5, 2.5, 1.25, 0.5, 0.25]; 
            const availableAlternativeOrder = fullDenominations.filter(p => alternativeOrder.includes(p));
            availableAlternativeOrder.sort((a, b) => b - a);

            for (const plateValue of availableAlternativeOrder) {
                if (currentRemaining <= 0) break; 
                const numPlates = Math.floor(currentRemaining / plateValue);
                if (numPlates > 0) {
                    platesUsed[plateValue] = (platesUsed[plateValue] || 0) + numPlates;
                    currentRemaining -= numPlates * plateValue;
                    currentRemaining = parseFloat(currentRemaining.toFixed(2)); 
                }
            }
            let loadedWeight = target - currentRemaining; 
            return { plates: platesUsed, loadedWeight: loadedWeight, remaining: currentRemaining };
        }


        function formatPlatesWithPlus(platesObject) {
            let formatted = [];
            const sortedPlateValues = Object.keys(platesObject).map(Number).sort((a, b) => b - a);
            for (const plateValue of sortedPlateValues) {
                if (platesObject[plateValue] > 0) {
                    formatted.push(`<span>${plateValue}kg x${platesObject[plateValue]}</span>`); 
                }
            }
            return formatted.length > 0 ? formatted.join(' + ') : 'Aucun';
        }
        
        function calculatePlates() {
            const targetValid = validateInputField(dom.targetWeightInput, dom.targetWeightError);
            const barbellValid = validateInputField(dom.barbellWeightInput, dom.barbellWeightError); 

            if (!targetValid || !barbellValid) {
                dom.platesResult.innerHTML = `<p class="plate-result-message danger">Veuillez corriger les erreurs dans les poids.</p>`;
                return;
            }

            const targetWeight = parseFloat(dom.targetWeightInput.value.replace(',', '.'));
            const barbellWeight = parseFloat(dom.barbellWeightInput.value.replace(',', '.'));
            
            if (barbellWeight > targetWeight) {
                dom.targetWeightInput.classList.add('is-invalid');
                dom.targetWeightError.textContent = 'Le poids cible doit √™tre sup√©rieur ou √©gal au poids de la barre.';
                dom.platesResult.innerHTML = `<p class="plate-result-message danger">Veuillez corriger les erreurs dans les poids.</p>`;
                return;
            } else {
                dom.targetWeightInput.classList.remove('is-invalid');
                dom.targetWeightError.textContent = '';
            }


            let weightPerSideTarget = (targetWeight - barbellWeight) / 2;
            
            const platesDenominations = [25, 20, 15, 10, 5, 2.5, 1.25, 0.5, 0.25].sort((a, b) => b - a);

            const combinationResult1 = getPlateCombinationOptimal(weightPerSideTarget, platesDenominations);
            const combinationResult2 = getPlateCombinationAlternative(weightPerSideTarget, platesDenominations);
            
            const totalPlates1 = {};
            for (const plate in combinationResult1.plates) {
                totalPlates1[plate] = combinationResult1.plates[plate] * 2;
            }
            const formattedTotalPlates1 = formatPlatesWithPlus(totalPlates1);
            
            const totalPlates2 = {};
            for (const plate in combinationResult2.plates) {
                totalPlates2[plate] = combinationResult2.plates[plate] * 2;
            }
            const formattedTotalPlates2 = formatPlatesWithPlus(totalPlates2);

            const loadedWeightPerSide = combinationResult1.loadedWeight;
            const totalLoadedWeight = loadedWeightPerSide * 2 + barbellWeight;
            const diff = targetWeight - totalLoadedWeight;

            let resultHtml = `<div class="result-summary">
                                <h3>R√©sultats :</h3>
                                <p>Poids charg√© par c√¥t√©: <span>${loadedWeightPerSide.toFixed(2)}kg</span> | Poids total charg√©: <span>${totalLoadedWeight.toFixed(2)}kg</span></p>`;
            
            if (Math.abs(diff) < 0.01) {
                resultHtml += `<p class="plate-result-message success">Poids cible atteint !</p>`;
            } else {
                resultHtml += `<p class="plate-result-message danger">Diff√©rence par rapport √† la cible: ${diff > 0 ? '+' : ''}${diff.toFixed(2)}kg</p>`;
            }
            resultHtml += `</div>`;
            resultHtml += `<h4>1. Total des plaques (2 c√¥t√©s) - Minimisant le nombre:</h4><p>${formattedTotalPlates1}</p>`;
            if(formattedTotalPlates1 !== formattedTotalPlates2 && formattedTotalPlates2 !== 'Aucun') {
                resultHtml += `<h4>2. Total des plaques (2 c√¥t√©s) - Autre d√©composition:</h4><p>${formattedTotalPlates2}</p>`;
            }
            
            dom.platesResult.innerHTML = resultHtml;
        }

        function calculateTrainingGoals() {
            const oneRmValid = validateInputField(dom.oneRmInput, dom.oneRmError);
            if (!oneRmValid) {
                dom.goalResultsContainer.innerHTML = '';
                return;
            }

            const oneRm = parseFloat(dom.oneRmInput.value.replace(',', '.'));

            const goals = [
                { name: 'Hypertrophie', icon: '<i class="fas fa-child-reaching"></i>', minPercent: 0.60, maxPercent: 0.80, a_class: 'hypertrophy', tooltip: '60-80% du 1RM', reps: '6-12 R√©p√©titions' },
                { name: 'Force', icon: '<i class="fas fa-dumbbell"></i>', minPercent: 0.80, maxPercent: 1.00, a_class: 'strength', tooltip: '80-100% du 1RM', reps: '1-5 R√©p√©titions' },
                { name: 'Endurance', icon: '<i class="fas fa-person-running"></i>', minPercent: 0, maxPercent: 0.60, a_class: 'endurance', tooltip: '<60% du 1RM', reps: '15+ R√©p√©titions' },
                { name: 'Power', icon: '<i class="fas fa-bolt"></i>', minPercent: 0.30, maxPercent: 0.70, a_class: 'power', tooltip: '30-70% du 1RM', reps: '3-6 R√©p√©titions (explosif)' }
            ];

            let resultsHtml = '';
            goals.forEach(goal => {
                const minWeight = (oneRm * goal.minPercent).toFixed(1);
                const maxWeight = (oneRm * goal.maxPercent).toFixed(1);
                let rangeText;
                if (goal.minPercent === 0) {
                    rangeText = `< ${maxWeight} kg`;
                } else {
                    rangeText = `${minWeight} - ${maxWeight} kg`;
                }

                resultsHtml += `
                    <div class="goal-card ${goal.a_class}" title="${goal.tooltip}">
                        <h4><span class="icon">${goal.icon}</span> ${goal.name}</h4>
                        <div class="weight-range"><strong>${rangeText}</strong></div>
                        <p class="rep-range">${goal.reps}</p>
                    </div>
                `;
            });

            dom.goalResultsContainer.innerHTML = resultsHtml;
        }
        
        async function handleTableActions(e) {
            const button = e.target.closest('button');
            if (!button) return;
            const rowOrCard = button.closest('.exercise-row') || button.closest('.exercise-card');
            if (!rowOrCard) return;
            const idx = +rowOrCard.dataset.exerciseIndex;
            const timerAction = button.dataset.timerAction;
            const action = button.dataset.action;

            if (action === 'quick-edit') {
                state.quickEditIndex = idx;
                dom.quickEditExerciseName.textContent = state.sessions[state.currentSessionIndex].exercises[idx].name;
                openModal(dom.quickEditModal);
                dom.quickEditWeight.classList.remove('is-invalid');
                dom.quickEditWeightError.textContent = '';
                dom.quickEditReps.classList.remove('is-invalid');
                dom.quickEditRepsError.textContent = '';
            } else if (action === 'link-superset') {
                const scrollY = window.scrollY;
                const exercises = state.sessions[state.currentSessionIndex].exercises;
                const clickedExercise = exercises[idx];

                if (clickedExercise.supersetGroup) {
                    let partnerIndex = -1;
                    if (clickedExercise.supersetWith !== null && clickedExercise.supersetWith !== undefined) {
                        partnerIndex = clickedExercise.supersetWith;
                    } else {
                        const partner = exercises.find(e => e.supersetWith === idx);
                        if (partner) {
                            partnerIndex = exercises.indexOf(partner);
                            partner.supersetWith = null;
                        }
                    }
                    clickedExercise.supersetWith = null;
                    clickedExercise.supersetGroup = false;
                    if (partnerIndex !== -1) {
                        exercises[partnerIndex].supersetGroup = false;
                    }
                    showNotification("Superset d√©li√©.", "info");

                    if (state.linkingState.active) {
                        state.linkingState = { active: false, fromIndex: null };
                    }
                    createTable();
                    window.scrollTo(0, scrollY);
                }
                else {
                    if (!state.linkingState.active) {
                        state.linkingState.active = true;
                        state.linkingState.fromIndex = idx;
                        button.classList.add('linking');
                        showNotification(`S√©lectionnez un autre exercice √† lier avec "${clickedExercise.name}".`, "info");
                    }
                    else {
                        const fromIndex = state.linkingState.fromIndex;
                        if (fromIndex !== idx) {
                            exercises[fromIndex].supersetWith = idx;
                            exercises[fromIndex].supersetGroup = true;
                            clickedExercise.supersetGroup = true;

                            const oldLink = exercises.find((e, i) => e.supersetWith === idx && i !== fromIndex);
                            if (oldLink) {
                                oldLink.supersetWith = null;
                                oldLink.supersetGroup = false;
                            }

                            showNotification("Exercices li√©s en superset!", "success");
                        }
                        state.linkingState = { active: false, fromIndex: null };
                        createTable();
                        window.scrollTo(0, scrollY);
                    }
                }
            } else if (timerAction) {
                handleTimerActions(timerAction, idx, rowOrCard);
            } else if (action === 'remove') {
                const exerciseToRemove = state.sessions[state.currentSessionIndex].exercises[idx];
                const confirmed = await customConfirm(`√ätes-vous s√ªr de vouloir supprimer l'exercice "${exerciseToRemove.name}"?`);
                if (confirmed) {
                    const scrollY = window.scrollY;
                    state.sessions[state.currentSessionIndex].exercises.splice(idx, 1);
                    state.lastDeletedExercise = exerciseToRemove;
                    if (state.timers[idx]) {
                        clearInterval(state.timers[idx].interval);
                        delete state.timers[idx];
                    }
                    createTable();
                    window.scrollTo(0, scrollY);
                    showUndoableNotification(`Exercice "${exerciseToRemove.name}" supprim√©.`, () => {
                        if (state.lastDeletedExercise) {
                            state.sessions[state.currentSessionIndex].exercises.splice(idx, 0, state.lastDeletedExercise);
                            createTable();
                            updateAllTotals();
                            state.lastDeletedExercise = null;
                            showNotification(`Suppression annul√©e. "${exerciseToRemove.name}" restaur√©.`, "info");
                        }
                    }, 7000);
                }
            } else if (action === 'add-series') {
                const scrollY = window.scrollY;
                const exercise = state.sessions[state.currentSessionIndex].exercises[idx];
                exercise.series.push({ weight: '', reps: '' });
                createTable();
                window.scrollTo(0, scrollY);
                showNotification(`Nouvelle s√©rie ajout√©e √† l'exercice "${exercise.name}".`, "info", 2000);
            }
        }
        
        function handleTimerActions(timerAction, idx, element) {
            const timerDisplay = element.querySelector('.timer-display');
            const startBtn = element.querySelector('[data-timer-action="start"]');
            const stopBtn = element.querySelector('[data-timer-action="stop"]');
            const exercise = state.sessions[state.currentSessionIndex].exercises[idx];
            const restString = exercise.rest;
            const duration = parseInt(restString) * (restString.includes('min') ? 60 : 1) || 60;

            if (!state.timers[idx]) {
                state.timers[idx] = {
                    interval: null,
                    remaining: duration,
                    isPaused: false,
                    duration: duration
                };
            }
            
            const runTimer = () => {
                const timerState = state.timers[idx];
                if ('Notification' in window && Notification.permission === 'default') {
                    Notification.requestPermission();
                }

                if (timerState.interval) clearInterval(timerState.interval);
                
                const endTime = Date.now() + timerState.remaining * 1000;
                localStorage.setItem(`timer-${idx}`, JSON.stringify({ endTime: endTime, name: exercise.name, duration: timerState.duration }));

                timerState.interval = setInterval(() => {
                    const now = Date.now();
                    const remainingSeconds = Math.round((endTime - now) / 1000);
                    
                    if (remainingSeconds <= 0) {
                        clearInterval(timerState.interval);
                        timerDisplay.textContent = formatTimerDisplay(0);
                        timerDisplay.classList.remove('timer-active');
                        localStorage.removeItem(`timer-${idx}`);
                        playBeep();
                        if (Notification.permission === "granted") {
                            new Notification('Lyftiv - Repos Termin√© !', { body: `Le temps de repos pour ${exercise.name} est termin√©.` });
                        }
                        startBtn.classList.remove('hidden');
                        stopBtn.classList.add('hidden');
                        state.timers[idx].remaining = state.timers[idx].duration;
                    } else {
                        timerState.remaining = remainingSeconds;
                        timerDisplay.textContent = formatTimerDisplay(remainingSeconds);
                    }
                }, 1000);

                timerDisplay.classList.add('timer-active');
                startBtn.classList.add('hidden');
                stopBtn.classList.remove('hidden');
                stopBtn.innerHTML = '<i class="fas fa-pause"></i>';
                stopBtn.style.background = 'var(--btn-danger-bg)';
            };

            if (timerAction === 'start' || (timerAction === 'stop' && state.timers[idx].isPaused)) {
                state.timers[idx].isPaused = false;
                runTimer();
            } else if (timerAction === 'stop' && !state.timers[idx].isPaused) {
                state.timers[idx].isPaused = true;
                clearInterval(state.timers[idx].interval);
                localStorage.removeItem(`timer-${idx}`);
                timerDisplay.classList.remove('timer-active');
                stopBtn.innerHTML = '<i class="fas fa-play"></i>';
                stopBtn.style.background = 'var(--btn-success-bg)';
            } else if (timerAction === 'reset') {
                clearInterval(state.timers[idx].interval);
                localStorage.removeItem(`timer-${idx}`);
                state.timers[idx] = null;
                timerDisplay.textContent = formatTimerDisplay(duration);
                timerDisplay.classList.remove('timer-active');
                startBtn.classList.remove('hidden');
                stopBtn.classList.add('hidden');
                stopBtn.innerHTML = '<i class="fas fa-pause"></i>';
                stopBtn.style.background = 'var(--btn-danger-bg)';
            }
        }

        async function handleHistoryActions(e) { 
            const button = e.target.closest('button');
            if (!button) return;
            const historyAction = button.dataset.historyAction;
            const historyId = +button.dataset.historyId;
            if (historyAction === 'details') showHistoryDetails(historyId);
            else if (historyAction === 'delete') await deleteHistoryItem(historyId);
            else if (historyAction === 'load') {
                const historicalSession = getHistory().find(s => s.id == historyId);
                if (historicalSession) {
                    showLoadOptionsModal(historicalSession); 
                } else {
                    showNotification("La s√©ance historique demand√©e n'a pas √©t√© trouv√©e.", "error");
                }
            }
        }

        async function deleteHistoryItem(id) {
            const confirmed = await customConfirm("√ätes-vous s√ªr de vouloir supprimer d√©finitivement cette s√©ance de l'historique ?");
            if (confirmed) {
                let history = getHistory().filter(session => session.id != id);
                localStorage.setItem('workoutHistory', JSON.stringify(history));
                displayHistory(); 
                showNotification("S√©ance supprim√©e de l'historique avec succ√®s.", "info");
            }
        }
        
        function updateStateFromTable() {
            if (!state.isInitialized) return;
            
            const currentSession = state.sessions[state.currentSessionIndex];
            if (!currentSession || !currentSession.exercises) return;

            currentSession.exercises.forEach((ex, idx) => {
                if (!Array.isArray(ex.series)) {
                    ex.series = [];
                }
                
                const currentInputs = Array.from(document.querySelectorAll(`[data-ex='${idx}'][data-serie]`));
                const newSeriesData = [];
                
                const seriesMap = new Map();
                currentInputs.forEach(input => {
                    const serieIndex = parseInt(input.dataset.serie, 10);
                    if (!seriesMap.has(serieIndex)) {
                        seriesMap.set(serieIndex, {});
                    }
                    if (input.classList.contains('weight')) {
                        seriesMap.get(serieIndex).weight = input.value;
                    } else if (input.classList.contains('reps')) {
                        seriesMap.get(serieIndex).reps = input.value;
                    }
                });

                Array.from(seriesMap.keys()).sort((a, b) => a - b).forEach(serieIndex => {
                    newSeriesData.push(seriesMap.get(serieIndex));
                });

                ex.series = newSeriesData;
            });
        }

        function resetAppStateToDefault() {
            state.sessions = JSON.parse(JSON.stringify(defaultSessions));
            state.currentSessionIndex = 0;
            localStorage.removeItem('inProgressWorkout');
            localStorage.removeItem('calculatorState');
            Object.values(state.timers).forEach(timer => {
                if (timer && timer.interval) clearInterval(timer.interval);
            });
            state.timers = {};
            
            resetTotalWorkoutTimer(false);
            
            dom.totalKgRepEl.textContent = "0 kg/rep";
            dom.deltaEl.textContent = "0 kg";
            dom.previousWeekInput.value = "";
            dom.sessionNotesInput.value = "";
            updateSessionSelectOptions();
            dom.sessionSelect.value = state.currentSessionIndex;
            updateDeleteSessionButtonState();
        }

        function isAppStateValid() {
            if (!Array.isArray(state.sessions) || state.sessions.length === 0) {
                return false;
            }
            if (typeof state.currentSessionIndex !== 'number' || state.currentSessionIndex < 0 || state.currentSessionIndex >= state.sessions.length) {
                return false;
            }
            const currentSession = state.sessions[state.currentSessionIndex];
            if (!currentSession || typeof currentSession !== 'object' || !Array.isArray(currentSession.exercises)) {
                return false;
            }
            return true;
        }
        
        function createTable() {
            if (!state.isInitialized) return;

            dom.exerciseListContainer.innerHTML = "";
            if (!isAppStateValid()) {
                resetAppStateToDefault();
            }

            const currentSession = state.sessions[state.currentSessionIndex];
            const exercises = (currentSession && Array.isArray(currentSession.exercises)) ? currentSession.exercises : [];
            
            (exercises || []).forEach(ex => {
                if (!ex.rest || String(ex.rest).trim() === "") {
                    ex.rest = "1 min";
                }
            });
            
            (exercises || []).forEach((ex, idx) => {
                if (!ex || typeof ex !== 'object' || !Array.isArray(ex.series)) {
                    return;
                }
                
                while (ex.series.length < 4) {
                    ex.series.push({ weight: '', reps: '' });
                }
            });
            
            if (!state.isMobileView) {
                const table = document.createElement("table");
                table.id = "workoutTable";
                table.className = "desktop-table";
                table.setAttribute('role', 'table');
                table.setAttribute('aria-label', 'Liste des exercices de la s√©ance');

                const thead = document.createElement("thead");
                thead.innerHTML = `
                    <tr role="row">
                        <th class="actions-col" scope="col">Actions</th>
                        <th scope="col">Exercice</th>
                        <th colspan="5" scope="colgroup">S√©ries</th>
                        <th scope="col">Kg/R√©p</th>
                        <th scope="col">1RM</th>
                        <th scope="col">Repos</th>
                        <th scope="col">Minuteur</th>
                        <th scope="col"></th> 
                    </tr>
                `;
                table.appendChild(thead);

                const tbody = document.createElement("tbody");
                tbody.id = "tbody";
                table.appendChild(tbody);
                dom.exerciseListContainer.appendChild(table);

                (exercises || []).forEach((ex, idx) => {
                    if (!ex || typeof ex !== 'object' || !Array.isArray(ex.series)) {
                        return;
                    }

                    const tr = document.createElement("tr");
                    tr.className = "exercise-row";
                    tr.dataset.exerciseIndex = idx;
                    tr.setAttribute('role', 'row');
            
                    if (ex.supersetGroup) {
                        tr.classList.add('superset-group');
                    }

                    let seriesContentHtml = "";
                    (ex.series || []).forEach((currentSeries, i) => {
                        seriesContentHtml += `<td role="cell"><div class="serie-input">
                            <input type="text" inputmode="decimal" pattern="[0-9.,+]*" data-ex="${idx}" data-serie="${i}" class="weight" placeholder="kg" aria-label="Poids pour l'exercice ${ex.name} s√©rie ${i+1}" value="${currentSeries.weight || ''}">
                            <input type="text" inputmode="decimal" pattern="[0-9.,+]*" data-ex="${idx}" data-serie="${i}" class="reps" placeholder="Reps" aria-label="Reps pour l'exercice ${ex.name} s√©rie ${i+1}" value="${currentSeries.reps || ''}">
                            <button class="serie-input-delete" data-ex="${idx}" data-serie="${i}" aria-label="Effacer cette s√©rie">&times;</button>
                        </div></td>`;
                    });

                    const remainingCols = 5 - (ex.series ? ex.series.length : 0);
                    for (let i = 0; i < remainingCols; i++) {
                        seriesContentHtml += `<td role="cell"></td>`;
                    }
                    
                    const restSeconds = parseInt(ex.rest) * (String(ex.rest).includes('min') ? 60 : 1) || 0;
                    const defaultTimerDisplay = formatTimerDisplay(restSeconds);

                    tr.innerHTML = `
                        <td class="actions-col" data-label="Actions" role="cell">
                            <button class="quick-edit-btn tooltip" data-action="quick-edit" aria-label="√âdition rapide pour ${ex.name}">
                                <i class="fas fa-pencil-alt"></i>
                                <span class="tooltiptext">√âdition rapide</span>
                            </button>
                            <button class="link-btn tooltip" data-action="link-superset" aria-label="Lier ${ex.name} pour superset">
                                <i class="fas fa-link"></i>
                                <span class="tooltiptext">Lier Superset</span>
                            </button>
                            <button class="btn-ghost" data-action="add-series" data-exercise-index="${idx}" aria-label="Ajouter une s√©rie √† ${ex.name}">
                                <i class="fas fa-plus"></i>
                                <span class="tooltiptext">Ajouter s√©rie</span>
                            </button>
                        </td>
                        <td class="exercise-col" data-label="Exercice" title="${ex.name}" role="cell">
                            <span>${ex.name}</span>
                        </td>
                        ${seriesContentHtml}
                        <td data-label="Kg/R√©p" id="kgrep-${idx}" role="cell">0</td>
                        <td data-label="1RM" id="onerm-${idx}" role="cell">0</td>
                        <td data-label="Repos" role="cell">${ex.rest || ''}</td>
                        <td role="cell"><div class="timer-container">
                                <div class="timer-display" id="timer-${idx}" aria-live="polite">${defaultTimerDisplay}</div>
                                <button class="timer-btn" data-timer-action="start" aria-label="D√©marrer le minuteur pour ${ex.name}"><i class="fas fa-play"></i></button>
                                <button class="timer-btn hidden" data-timer-action="stop" aria-label="Arr√™ter le minuteur pour ${ex.name}"><i class="fas fa-pause"></i></button>
                                <button class="timer-btn" data-timer-action="reset" aria-label="R√©initialiser le minuteur pour ${ex.name}"><i class="fas fa-redo"></i></button>
                            </div>
                        </td>
                        <td role="cell"><button class="btn-ghost" data-action="remove" aria-label="Supprimer l'exercice ${ex.name}"><i class="fas fa-trash-alt"></i></button></td>`;
                    tbody.appendChild(tr);
                    
                    if (ex.supersetGroup) {
                        const linkBtn = tr.querySelector('.link-btn');
                        if (linkBtn) linkBtn.classList.add('active-superset');
                    }
                });
            } else {
                const mobileCardsContainer = document.createElement("div");
                mobileCardsContainer.className = "mobile-cards";
                mobileCardsContainer.setAttribute('role', 'list');
                dom.exerciseListContainer.appendChild(mobileCardsContainer);

                (exercises || []).forEach((ex, idx) => {
                    if (!ex || typeof ex !== 'object' || !Array.isArray(ex.series)) {
                        return;
                    }

                    const card = document.createElement("div");
                    card.className = "exercise-card";
                    card.dataset.exerciseIndex = idx;
                    card.setAttribute('role', 'listitem');
                    card.setAttribute('aria-label', `Exercice: ${ex.name}`);

                    if (ex.supersetGroup) {
                         card.classList.add('superset-group');
                    }

                    let seriesHtml = '';
                    (ex.series || []).forEach((currentSeries, i) => {
                        seriesHtml += `
                            <div class="series-row">
                                <span>S√©rie ${i + 1}:</span>
                                <div class="series-input-group">
                                    <input type="text" inputmode="decimal" pattern="[0-9.,+]*" data-ex="${idx}" data-serie="${i}" class="weight" placeholder="kg" aria-label="Poids pour l'exercice ${ex.name} s√©rie ${i+1}" value="${currentSeries.weight || ''}">
                                    <input type="text" inputmode="decimal" pattern="[0-9.,+]*" data-ex="${idx}" data-serie="${i}" class="reps" placeholder="Reps" aria-label="Reps pour l'exercice ${ex.name} s√©rie ${i+1}" value="${currentSeries.reps || ''}">
                                    <button class="serie-input-delete" data-ex="${idx}" data-serie="${i}" aria-label="Effacer s√©rie ${i+1} pour ${ex.name}">&times;</button>
                                </div>
                            </div>
                        `;
                    });

                    const restSeconds = parseInt(ex.rest) * (String(ex.rest).includes('min') ? 60 : 1) || 0;
                    const defaultTimerDisplay = formatTimerDisplay(restSeconds);

                    card.innerHTML = `
                        <h3>
                            ${ex.name}
                        </h3>
                            <button class="btn-ghost" data-action="remove" aria-label="Supprimer l'exercice ${ex.name}"><i class="fas fa-trash-alt"></i></button>
                        </h4>
                        <div class="series-group">
                            ${seriesHtml}
                            <button class="btn btn-outline" data-action="add-series" data-exercise-index="${idx}" style="width: 100%; margin-top: var(--spacing-sm);">
                                <i class="fas fa-plus"></i> Ajouter une s√©rie
                            </button>
                        </div>
                        <div class="card-stats">
                            <div class="card-stat-item">
                                <span class="card-stat-label">Kg/R√©p</span> <span class="card-stat-value" id="kgrep-${idx}">0</span> </div>
                            <div class="card-stat-item">
                                <span class="card-stat-label">1RM Moy</span> <span class="card-stat-value" id="onerm-${idx}">0</span>
                            </div>
                            <div class="card-stat-item">
                                <span class="card-stat-label">Repos</span>
                                <span class="card-stat-value">${ex.rest}</span>
                            </div>
                        </div>
                        <div class="card-actions">
                            <button class="btn btn-info" data-action="quick-edit" aria-label="√âdition rapide pour ${ex.name}"><i class="fas fa-pencil-alt"></i> √âditer</button>
                            <button class="btn btn-secondary link-btn" data-action="link-superset" aria-label="Lier ${ex.name} pour superset"><i class="fas fa-link"></i> Superset</button>
                            <div class="timer-container">
                                <div class="timer-display" id="timer-${idx}" aria-live="polite">${defaultTimerDisplay}</div>
                                <button class="timer-btn" data-timer-action="start" aria-label="D√©marrer le minuteur pour ${ex.name}"><i class="fas fa-play"></i></button>
                                <button class="timer-btn hidden" data-timer-action="stop" aria-label="Arr√™ter le minuteur pour ${ex.name}"><i class="fas fa-pause"></i></button>
                                <button class="timer-btn" data-timer-action="reset" aria-label="R√©initialiser le minuteur pour ${ex.name}"><i class="fas fa-redo"></i></button>
                            </div>
                        </div>
                    `;
                    mobileCardsContainer.appendChild(card);
                    
                    if (ex.supersetGroup) {
                        const linkBtn = card.querySelector('.link-btn');
                        if (linkBtn) linkBtn.classList.add('active-superset');
                    }
                });
            }

            loadCurrentState();
            updateAllTotals();
            updateDeleteSessionButtonState();
        }

        function calculate1RM(weight, reps) {
            if (reps <= 0 || weight <= 0) return 0;
            const brzycki1RM = weight / (1.0278 - (0.0278 * reps));
            const mayhew1RM = (100 * weight) / (52.2 + (41.9 * Math.exp(-0.055 * reps)));
            const epley1RM = weight * (1 + (reps / 30));
            const lander1RM = (100 * weight) / (101.3 - 2.67123 * reps);
            const lombardi1RM = weight * Math.pow(reps, 0.10);

            const validFormulas = [brzycki1RM, mayhew1RM, epley1RM, lander1RM, lombardi1RM].filter(val => !isNaN(val) && val > 0);

            if (validFormulas.length === 0) return 0;
            return validFormulas.reduce((sum, val) => sum + val, 0) / validFormulas.length;
        }

        function animateNumberChange(element, startValue, endValue, duration, suffix = '') {
            const range = endValue - startValue;
            const startTime = performance.now();

            function update() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const currentValue = startValue + range * progress;
                element.textContent = `${currentValue.toFixed(0)}${suffix}`;

                if (progress < 1) {
                    requestAnimationFrame(update);
                } else {
                    element.textContent = `${endValue.toFixed(0)}${suffix}`;
                }
            }
            requestAnimationFrame(update);
        }

        function updateAllTotals() {
            if (!state.isInitialized) return;
            
            let totalSessionReps = 0;
            let totalSessionKgRep = 0;
            let completedSeriesOverall = 0;
            let totalTonnageForKgRep = 0;

            if (!isAppStateValid()) {
                resetAppStateToDefault();
                updateAllTotals();
                return;
            }
            const currentSession = state.sessions[state.currentSessionIndex];
            const exercises = (currentSession && Array.isArray(currentSession.exercises)) ? currentSession.exercises : [];
            let totalPossibleSeries = 0;
            let exercisesWith1RM = [];

            (exercises || []).forEach((ex, idx) => {
                if (!ex || typeof ex !== 'object' || !Array.isArray(ex.series)) {
                    return;
                }

                let exerciseTonnage = 0;
                let exerciseTotalReps = 0;
                let exerciseKgRep = 0;
                let oneRMs = [];
                
                totalPossibleSeries += (ex.series || []).length;

                (ex.series || []).forEach((s, i) => {
                    const repsInput = document.querySelector(`[data-ex='${idx}'][data-serie='${i}'].reps`);
                    const weightInput = document.querySelector(`[data-ex='${idx}'][data-serie='${i}'].weight`);
                    
                    const repsValue = repsInput?.value.trim() || '';
                    const weightValue = weightInput?.value.trim() || '';

                    const repsSegments = repsValue.split('+').map(s => parseFloat(s.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0);
                    const weightSegments = weightValue.split('+').map(s => parseFloat(s.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0);

                    let currentSeriesTonnage = 0;
                    let currentSeriesReps = 0;
                    let currentSeriesValid = false;

                    const minLength = Math.min(repsSegments.length, weightSegments.length);
                    for (let k = 0; k < minLength; k++) {
                        const reps = repsSegments[k];
                        const weight = weightSegments[k];
                        
                        currentSeriesTonnage += reps * weight;
                        currentSeriesReps += reps;
                        if (reps > 0 && weight > 0) {
                            oneRMs.push(calculate1RM(weight, reps));
                            currentSeriesValid = true;
                        }
                    }

                    if (weightInput) {
                        if (!isValidAndCompleteNumber(weightInput.value) && weightInput.value.trim() !== '') {
                             weightInput.classList.add('is-invalid');
                        } else {
                            weightInput.classList.remove('is-invalid');
                        }
                    }
                    if (repsInput) {
                         if (!isValidAndCompleteNumber(repsInput.value) && repsInput.value.trim() !== '') {
                            repsInput.classList.add('is-invalid');
                        } else {
                            repsInput.classList.remove('is-invalid');
                        }
                    }

                    if (currentSeriesValid) {
                        repsInput.classList.add('completed');
                        weightInput.classList.add('completed');
                        completedSeriesOverall++;
                    } else {
                        repsInput?.classList.remove('completed');
                        weightInput?.classList.remove('completed');
                    }
                    
                    exerciseTonnage += currentSeriesTonnage;
                    exerciseTotalReps += currentSeriesReps;
                });

                if (exerciseTotalReps > 0) {
                    exerciseKgRep = exerciseTonnage / exerciseTotalReps;
                }

                let weightedAverage1RM = 0;
                if (oneRMs.length > 0) {
                    let totalWeighted1RM = 0;
                    let totalWeightSum = 0;
                    for (let j = 0; j < oneRMs.length; j++) {
                        const positionFromEnd = oneRMs.length - 1 - j;
                        const weightFactor = 1 / (1 + positionFromEnd * 0.2);
                        totalWeighted1RM += oneRMs[j] * weightFactor;
                        totalWeightSum += weightFactor;
                    }
                    weightedAverage1RM = totalWeighted1RM / totalWeightSum;
                }

                const kgRepEl = document.getElementById(`kgrep-${idx}`);
                if (kgRepEl) {
                    kgRepEl.textContent = exerciseKgRep.toFixed(2);
                    kgRepEl.classList.toggle('kg-rep-high', exerciseKgRep > 0);
                }
                const onermEl = document.getElementById(`onerm-${idx}`);
                if (onermEl) {
                    onermEl.textContent = weightedAverage1RM > 0 ? weightedAverage1RM.toFixed(1) : '0';
                    onermEl.classList.toggle('onerm-high', weightedAverage1RM > 0);
                    if (weightedAverage1RM > 0) {
                        exercisesWith1RM.push({ name: ex.name, oneRm: weightedAverage1RM.toFixed(1) });
                    }
                }
                totalTonnageForKgRep += exerciseTonnage;
                totalSessionReps += exerciseTotalReps;
            });

            if (totalSessionReps > 0) {
                totalSessionKgRep = totalTonnageForKgRep / totalSessionReps;
            }

            const currentKgRep = parseFloat(dom.totalKgRepEl.textContent.replace(' kg/rep', '')) || 0;
            const newKgRep = totalSessionKgRep;
            animateNumberChange(dom.totalKgRepEl, currentKgRep, newKgRep, 500, ' kg/rep');

            dom.progressBar.setAttribute('aria-valuenow', (totalPossibleSeries > 0 ? (completedSeriesOverall / totalPossibleSeries) * 100 : 0).toFixed(0));

            const previous = parseFloat(dom.previousWeekInput.value.replace(',', '.')) || 0;
            const delta = newKgRep - previous;
            const startDelta = parseFloat(dom.deltaEl.textContent.replace(' kg', '').replace('+', '')) || 0;
            
            const deltaDuration = 500;
            const deltaStartTime = performance.now();

            function updateDeltaAnimation() {
                const elapsed = performance.now() - deltaStartTime;
                const progress = Math.min(elapsed / deltaDuration, 1);
                const currentValue = startDelta + (delta - startDelta) * progress;
                const displayValue = Math.round(currentValue);

                const displaySign = displayValue > 0 ? '+' : '';
                dom.deltaEl.textContent = `${displaySign}${displayValue} kg`;
                dom.deltaEl.style.color = displayValue > 0 ? 'var(--color-success-default)' : displayValue < 0 ? 'var(--color-danger-default)' : 'inherit';

                if (progress < 1) {
                    requestAnimationFrame(updateDeltaAnimation);
                } else {
                     dom.deltaEl.textContent = `${delta > 0 ? '+' : ''}${delta.toFixed(0)} kg`;
                     dom.deltaEl.style.color = delta > 0 ? 'var(--color-success-default)' : delta < 0 ? 'var(--color-danger-default)' : 'inherit';
                }
            }
            requestAnimationFrame(updateDeltaAnimation);

            dom.progressFill.style.width = `${totalPossibleSeries > 0 ? (completedSeriesOverall / totalPossibleSeries) * 100 : 0}%`;
            saveCurrentState();
            populateOneRMDropdown(exercisesWith1RM);
        }

        function populateOneRMDropdown(exercisesWith1RM) {
            dom.oneRmExerciseSelect.innerHTML = '<option value="">-- S√©lectionner un exercice --</option>';
            if (exercisesWith1RM.length > 0) {
                exercisesWith1RM.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.oneRm;
                    option.textContent = `${item.name} (${item.oneRm} kg)`;
                    dom.oneRmExerciseSelect.appendChild(option);
                });
                dom.oneRmExerciseSelect.disabled = false;
            } else {
                dom.oneRmExerciseSelect.disabled = true;
            }
        }

        function saveCurrentState() {
            const currentSession = state.sessions[state.currentSessionIndex];
            if (!currentSession) return;
            currentSession.exercises.forEach((ex, idx) => {
                ex.series = Array.from(document.querySelectorAll(`[data-ex='${idx}'][data-serie]`)).reduce((acc, input) => {
                    const serieIndex = parseInt(input.dataset.serie, 10);
                    if (!acc[serieIndex]) {
                        acc[serieIndex] = {};
                    }
                    if (input.classList.contains('weight')) {
                        acc[serieIndex].weight = input.value;
                    } else if (input.classList.contains('reps')) {
                        acc[serieIndex].reps = input.value;
                    }
                    return acc;
                }, []).filter(s => s.weight !== undefined || s.reps !== undefined);
            });
            const calculatorState = {
                targetWeight: dom.targetWeightInput.value,
                barbellWeight: dom.barbellWeightInput.value,
                oneRm: dom.oneRmInput.value
            };
            try {
                localStorage.setItem('calculatorState', JSON.stringify(calculatorState));
            } catch (e) {
                console.error("Erreur lors de la sauvegarde de l'√©tat du calculateur :", e);
            }

            let currentTotalPaused = state.totalPausedDuration;
            if (state.isWorkoutTimerPaused && state.pauseStartTime > 0) {
                currentTotalPaused += (Date.now() - state.pauseStartTime);
            }

            const data = {
                previousWeek: dom.previousWeekInput.value,
                sessionIndex: state.currentSessionIndex,
                customSessions: state.sessions,
                workoutStartTime: state.workoutStartTime,
                isWorkoutTimerPaused: state.isWorkoutTimerPaused,
                totalPausedDuration: state.totalPausedDuration,
                pauseStartTime: state.pauseStartTime,
                sessionNotes: dom.sessionNotesInput.value
            };
            try {
                localStorage.setItem('inProgressWorkout', JSON.stringify(data));
            } catch (e) {
                console.error("Erreur lors de la sauvegarde de la s√©ance en cours :", e);
            }
        }

        function loadCurrentState() {
            const data = JSON.parse(localStorage.getItem('inProgressWorkout'));
            if (!data) return;
            const currentSession = state.sessions[state.currentSessionIndex];
            const currentExercises = (currentSession && Array.isArray(currentSession.exercises)) ? currentSession.exercises : [];

            currentExercises.forEach((ex, idx) => {
                if (!Array.isArray(ex.series)) {
                    ex.series = [];
                }
                ex.series.forEach((s, i) => {
                    const repsInput = document.querySelector(`[data-ex='${idx}'][data-serie='${i}'].reps`);
                    const weightInput = document.querySelector(`[data-ex='${idx}'][data-serie='${i}'].weight`);
                    if (repsInput) repsInput.value = s.reps || '';
                    if (weightInput) weightInput.value = s.weight || '';
                });
            });
            dom.previousWeekInput.value = data.previousWeek || "";
            dom.sessionNotesInput.value = data.sessionNotes || "";

            const calculatorState = JSON.parse(localStorage.getItem('calculatorState'));
            if (calculatorState) {
                dom.targetWeightInput.value = calculatorState.targetWeight || '';
                dom.barbellWeightInput.value = calculatorState.barbellWeight || '';
                dom.oneRmInput.value = calculatorState.oneRm || '';
                calculatePlates();
                calculateTrainingGoals();
            }
        }

        function customConfirm(message) {
            return new Promise(resolve => {
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.setAttribute('role', 'dialog');
                modal.setAttribute('aria-modal', 'true');
                modal.setAttribute('aria-labelledby', 'confirmModalTitle');
                modal.innerHTML = `
                    <div class="modal-content" style="text-align: center;">
                        <h2 id="confirmModalTitle" style="font-size: 1.5rem; margin-bottom: var(--spacing-md);">Confirmation</h2>
                        <p style="margin-bottom: var(--spacing-lg);">${message}</p>
                        <div style="display: flex; justify-content: center; gap: var(--spacing-md);">
                            <button class="btn btn-outline confirm-no"> Non</button>
                            <button class="btn btn-success confirm-yes"> Oui</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                openModal(modal);

                const confirmYesBtn = modal.querySelector('.confirm-yes');
                const confirmNoBtn = modal.querySelector('.confirm-no');

                confirmYesBtn.onclick = () => { 
                    closeModal(modal);
                    modal.addEventListener('transitionend', () => modal.remove(), {once: true});
                    resolve(true); 
                };

                confirmNoBtn.onclick = () => { 
                    closeModal(modal);
                    modal.addEventListener('transitionend', () => modal.remove(), {once: true});
                    resolve(false); 
                };
            });
        }
        
        async function finishAndSaveSession() {
            let currentSessionReps = 0;
            let currentSessionTonnage = 0;

            const exercisesData = (state.sessions[state.currentSessionIndex]?.exercises || []).flatMap((ex, idx) => {
                const exerciseSeries = [];
                let exerciseTonnage = 0;
                let exerciseReps = 0;

                ex.series.forEach(s => {
                    const repsValues = String(s.reps).split('+').map(val => parseFloat(val.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0) || [];
                    const weightValues = String(s.weight).split('+').map(val => parseFloat(val.trim().replace(',', '.'))).filter(val => !isNaN(val) && val >= 0) || [];
                    
                    const minLength = Math.min(repsValues.length, weightValues.length);
                    
                    if (minLength > 0) {
                        for (let k = 0; k < minLength; k++) {
                            exerciseSeries.push({ reps: repsValues[k], weight: weightValues[k] });
                            exerciseTonnage += repsValues[k] * weightValues[k];
                            exerciseReps += repsValues[k];
                        }
                    } else if (repsValues.length > 0) {
                        repsValues.forEach(r => {
                            exerciseSeries.push({ reps: r, weight: 0 });
                            exerciseReps += r;
                        });
                    } else if (weightValues.length > 0) {
                        weightValues.forEach(w => {
                            exerciseSeries.push({ reps: 0, weight: w });
                        });
                    }
                });

                if (exerciseSeries.length > 0) {
                    currentSessionTonnage += exerciseTonnage;
                    currentSessionReps += exerciseReps;
                    return [{
                        name: ex.name,
                        rest: ex.rest || "1 min",
                        series: exerciseSeries.filter(s => s.reps > 0 || s.weight > 0),
                        exerciseReps: exerciseReps
                    }];
                }
                return [];
            });

            if (currentSessionReps === 0) {
                showNotification("Aucune donn√©e √† sauvegarder. La s√©ance n'a pas √©t√© enregistr√©e car aucune r√©p√©tition n'a √©t√© effectu√©e.", "info");
                return; 
            }
            pauseTotalWorkoutTimer(); 

            const workoutData = {
                id: Date.now(),
                date: new Date().toISOString(),
                sessionName: dom.sessionSelect.selectedOptions[0].text,
                totalReps: currentSessionReps,
                totalKgRep: currentSessionReps > 0 ? (currentSessionTonnage / currentSessionReps).toFixed(2) : 0,
                duration: dom.totalTimeEl.textContent,
                notes: dom.sessionNotesInput.value,
                exercises: exercisesData
            };
            let history = getHistory();
            history.push(workoutData);
            localStorage.setItem('workoutHistory', JSON.stringify(history));
            showNotification("S√©ance sauvegard√©e dans l'historique avec succ√®s !", "success");
            
            Object.values(state.timers).forEach(timer => {
                if (timer && timer.interval) clearInterval(timer.interval);
            });
            state.timers = {};
            
            resetTotalWorkoutTimer(false);
            localStorage.removeItem('inProgressWorkout');
            createTable();
            
            dom.totalKgRepEl.textContent = "0 kg/rep";
            dom.deltaEl.textContent = "0 kg";
            dom.previousWeekInput.value = "";
            dom.sessionNotesInput.value = "";
        }

        function getHistory() { return JSON.parse(localStorage.getItem('workoutHistory')) || []; }
        
        function displayHistory() {
            dom.historyList.innerHTML = '';
            const sortedHistory = getHistory().sort((a, b) => new Date(b.date) - new Date(a.date));

            if (sortedHistory.length === 0) {
                dom.historyList.innerHTML = '<p style="text-align: center; color: var(--sub-header-color);">Aucune s√©ance enregistr√©e dans l\'historique.</p>';
                return;
            }

            sortedHistory.forEach(session => {
                const item = document.createElement('div');
                item.className = 'history-item';
                item.setAttribute('role', 'listitem');
                item.innerHTML = `
                    <div>
                        ${new Date(session.date).toLocaleDateString('fr-FR')} - 
                        <strong>${session.sessionName}</strong> (${session.totalKgRep} kg/rep) ${session.duration ? ` - ‚è±Ô∏è ${session.duration}` : ''}
                    </div>
                    <div style="display: flex; gap: var(--spacing-xs);">
                        <button class="btn btn-ghost" data-history-action="details" data-history-id="${session.id}" title="Voir les d√©tails de ${session.sessionName}"><i class="fas fa-eye"></i></button>
                        <button class="btn btn-ghost" data-history-action="load" data-history-id="${session.id}" title="Utiliser cette s√©ance comme mod√®le"><i class="fas fa-download"></i></button>
                        <button class="btn btn-ghost" data-history-action="delete" data-history-id="${session.id}" title="Supprimer ${session.sessionName} de l'historique"><i class="fas fa-trash-alt"></i></button>
                    </div>
                    <div class="history-details" id="details-${session.id}" role="region" aria-live="polite"></div>`;
                dom.historyList.appendChild(item);
            });
        }
        
        function showHistoryDetails(id) {
            const detailsDiv = document.getElementById(`details-${id}`);
            const button = detailsDiv.previousElementSibling.querySelector('[data-history-action="details"]');
            
            if (detailsDiv.classList.contains('visible')) {
                detailsDiv.classList.remove('visible');
                detailsDiv.innerHTML = '';
                button.setAttribute('aria-expanded', 'false');
            } else {
                const session = getHistory().find(s => s.id == id);
                if (session) {
                    let detailsHtml = `<h4>D√©tails de la S√©ance :</h4>
                                       <p><strong>Total Kg/R√©p :</strong> ${session.totalKgRep || 0} kg/rep</p>`;
                    if (session.notes) {
                        detailsHtml += `<p><strong>Notes :</strong> ${session.notes}</p>`;
                    }
                    detailsHtml += `<ul>`;
                    session.exercises.forEach(ex => {
                        let exerciseOneRMs = [];
                        let exerciseTonnage = 0;
                        if (ex.series && ex.series.length > 0) {
                            ex.series.forEach(s => {
                                const reps = parseFloat(String(s.reps).replace(',', '.')) || 0;
                                const weight = parseFloat(String(s.weight).replace(',', '.')) || 0;
                                if (reps > 0 && weight > 0) {
                                    exerciseOneRMs.push(calculate1RM(weight, reps));
                                    exerciseTonnage += reps * weight;
                                }
                            });
                        }
                        let weightedAverage1RM = 0;
                        if (exerciseOneRMs.length > 0) {
                            let totalWeighted1RM = 0;
                            let totalWeightSum = 0;
                            for (let j = 0; j < exerciseOneRMs.length; j++) {
                                const positionFromEnd = exerciseOneRMs.length - 1 - j;
                                const weightFactor = 1 / (1 + positionFromEnd * 0.2);
                                totalWeighted1RM += exerciseOneRMs[j] * weightFactor;
                                totalWeightSum += weightFactor;
                            }
                            weightedAverage1RM = totalWeighted1RM / totalWeightSum;
                        }
                        const exerciseKgRep = (ex.exerciseReps > 0) ? (exerciseTonnage / ex.exerciseReps).toFixed(2) : 0;

                        detailsHtml += `<li><strong>${ex.name}</strong> - Kg/R√©p: ${exerciseKgRep} kg/rep, 1RM Moy: ${weightedAverage1RM.toFixed(1)} kg</li>`;
                    });
                    detailsHtml += '</ul>';
                    detailsDiv.innerHTML = detailsHtml;
                    detailsDiv.classList.add('visible');
                    button.setAttribute('aria-expanded', 'true');
                    
                    detailsDiv.scrollIntoView({ behavior: "smooth", block: "nearest" });
                }
            } 
        }
        
        const escapeCsv = (str) => {
            const s = String(str || '');
            if (s.includes(';') || s.includes('"') || s.includes('\n')) {
                return `"${s.replace(/"/g, '""')}"`;
            }
            return s;
        };

        function exportCSV() {
            const history = getHistory();
            if (history.length === 0) {
                showNotification("Aucune donn√©e historique √† exporter. Le fichier CSV est vide.", "info");
                return;
            }

            const headers = [
                "Type", "Date/ID", "Nom", "Duree", "Serie", "Reps", "Poids", "Notes"
            ];
            let csvContent = headers.join(';') + '\n';

            history.forEach((session) => {
                const sessionDate = new Date(session.date).toLocaleString('fr-FR', {
                    year: 'numeric', month: '2-digit', day: '2-digit',
                    hour: '2-digit', minute: '2-digit'
                });

                const sessionRow = [
                    "Session",
                    escapeCsv(sessionDate),
                    escapeCsv(session.sessionName),
                    escapeCsv(session.duration),
                    "", "", "",
                    escapeCsv(session.notes)
                ];
                csvContent += sessionRow.join(';') + '\n';

                session.exercises.forEach(ex => {
                    const exerciseRow = ["Exercice", "", escapeCsv(ex.name), "", "", "", "", ""];
                    csvContent += exerciseRow.join(';') + '\n';

                    if (ex.series && ex.series.length > 0) {
                        ex.series.forEach((serie, i) => {
                            const serieRow = [
                                "Serie", "", "", "", `S√©rie ${i + 1}`,
                                escapeCsv(String(serie.reps).replace('.', ',')),
                                escapeCsv(String(serie.weight).replace('.', ',')),
                                ""
                            ];
                            csvContent += serieRow.join(';') + '\n';
                        });
                    }
                });
            });
            
            const currentSessionName = dom.sessionSelect.selectedOptions[0].text;
            const sanitizedName = currentSessionName.replace(/[\s/\\?%*:|"<>]/g, '_');
            const dateStr = new Date().toISOString().split('T')[0];
            
            const blob = new Blob([new Uint8Array([0xEF, 0xBB, 0xBF]), csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = `${sanitizedName}_${dateStr}.csv`;
            link.click();
            URL.revokeObjectURL(link.href);
            showNotification("Exportation de l'historique CSV r√©ussie !", "success");
        }

        function parseCsvToHistory(csvContent) {
            const lines = csvContent.replace(/\r/g, '').split('\n').filter(line => line.trim() && !line.startsWith('---'));
            if (lines.length < 2) {
                showNotification("Le fichier CSV est vide ou invalide.", "error");
                return [];
            }

            const history = [];
            let currentSession = null;
            let currentExercise = null;

            for (let i = 1; i < lines.length; i++) {
                const cols = lines[i].split(';').map(c => c.trim().replace(/^"|"$/g, ''));
                const type = (cols[0] || '').toLowerCase();

                if (type === 'session') {
                    const dateString = cols[1] || '';
                    const dateParts = dateString.match(/(\d{2})\/(\d{2})\/(\d{4})\s*(\d{2}):(\d{2})/);
                    let parsedDate = dateParts ? new Date(`${dateParts[3]}-${dateParts[2]}-${dateParts[1]}T${dateParts[4]}:${dateParts[5]}:00`) : new Date(dateString);

                    if (isNaN(parsedDate.getTime())) continue;

                    currentSession = {
                        id: parsedDate.getTime() + Math.random(),
                        date: parsedDate.toISOString(),
                        sessionName: cols[2] || 'S√©ance import√©e',
                        duration: cols[3] || '00:00:00',
                        notes: cols[7] || '',
                        exercises: [],
                        totalReps: 0,
                        totalKgRep: 0
                    };
                    history.push(currentSession);
                    currentExercise = null;
                } else if (type === 'exercice' && currentSession) {
                    currentExercise = {
                        name: cols[2] || 'Exercice inconnu',
                        rest: '1 min',
                        series: [],
                        exerciseReps: 0
                    };
                    currentSession.exercises.push(currentExercise);
                } else if (type === 'serie' && currentExercise) {
                    const reps = (cols[5] || '0').replace(',', '.');
                    const weight = (cols[6] || '0').replace(',', '.');
                    if (parseFloat(reps) > 0 || parseFloat(weight) > 0) {
                        currentExercise.series.push({ reps, weight });
                    }
                }
            }

            history.forEach(session => {
                let sessionTonnage = 0;
                session.exercises.forEach(ex => {
                    let exerciseTonnage = 0;
                    ex.series.forEach(serie => {
                        const reps = parseFloat(serie.reps) || 0;
                        const weight = parseFloat(serie.weight) || 0;
                        exerciseTonnage += reps * weight;
                        ex.exerciseReps += reps;
                    });
                    sessionTonnage += exerciseTonnage;
                    session.totalReps += ex.exerciseReps;
                });
                if (session.totalReps > 0) {
                    session.totalKgRep = (sessionTonnage / session.totalReps).toFixed(2);
                }
            });

            return history;
        }
        
        function showNotification(message, type = 'info', duration = 5000) { 
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `<span>${message}</span>`;
            dom.notificationContainer.appendChild(notification);
            void notification.offsetWidth;
            notification.classList.add('show');
            setTimeout(() => {
                notification.classList.remove('show');
                notification.addEventListener('transitionend', () => notification.remove(), { once : true });
            }, duration);
        }

        function showUndoableNotification(message, onUndoCallback, duration = 7000) {
            const notification = document.createElement('div');
            notification.className = `notification info`; 
            notification.innerHTML = `
                <span>${message}</span>
                <button class="btn btn-secondary" id="undoBtn" style="margin-inline-start: 1rem; padding: 0.5rem 1rem; border-radius: 15px;">Annuler</button>
            `;
            dom.notificationContainer.appendChild(notification);
            void notification.offsetWidth; 
            notification.classList.add('show');
            let timer; 
            const closeNotification = () => {
                notification.classList.remove('show');
                notification.addEventListener('transitionend', () => notification.remove(), { once : true });
            };
            const undoButton = notification.querySelector('#undoBtn');
            if (undoButton) {
                undoButton.addEventListener('click', () => {
                    clearTimeout(timer); 
                    onUndoCallback(); 
                    closeNotification(); 
                });
            }
            timer = setTimeout(closeNotification, duration);
        }

        function formatTime(totalMilliseconds) {
            if (totalMilliseconds < 0) totalMilliseconds = 0;
            const totalSeconds = Math.floor(totalMilliseconds / 1000);
            const h = Math.floor(totalSeconds / 3600);
            const m = Math.floor((totalSeconds % 3600) / 60);
            const s = Math.floor(totalSeconds % 60);
            return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
        }
        
        function formatTimerDisplay(seconds) {
             const m = Math.floor(seconds / 60);
             const s = Math.floor(seconds % 60);
             return `${m}:${String(s).padStart(2, '0')}`;
        }

        function updateTotalTimeDisplay() {
            if (!state.workoutStartTime) {
                dom.totalTimeEl.textContent = "00:00:00";
                return;
            }

            const elapsed = state.isWorkoutTimerPaused 
                ? state.pauseStartTime - state.workoutStartTime - state.totalPausedDuration 
                : Date.now() - state.workoutStartTime - state.totalPausedDuration;
                
            dom.totalTimeEl.textContent = formatTime(elapsed);
        }

        function updateTimerToggleButtonUI(isPaused) {
            if (isPaused) {
                dom.timerPlayPauseIcon.className = 'fas fa-play';
                dom.timerPlayPauseText.textContent = state.workoutStartTime ? 'Reprendre' : 'D√©marrer';
            } else {
                dom.timerPlayPauseIcon.className = 'fas fa-pause';
                dom.timerPlayPauseText.textContent = 'Pause';
            }
        }
        
        function startTotalWorkoutTimer() {
            if (state.totalWorkoutTimeInterval) clearInterval(state.totalWorkoutTimeInterval);

            if (!state.workoutStartTime) {
                state.workoutStartTime = Date.now();
                state.totalPausedDuration = 0;
            }
            
            if (state.isWorkoutTimerPaused && state.pauseStartTime > 0) {
                const currentPauseDuration = Date.now() - state.pauseStartTime;
                state.totalPausedDuration += currentPauseDuration;
            }
            
            state.isWorkoutTimerPaused = false;
            state.pauseStartTime = 0;
            updateTimerToggleButtonUI(false);

            state.totalWorkoutTimeInterval = setInterval(updateTotalTimeDisplay, 1000);
            updateTotalTimeDisplay(); 
            saveCurrentState();
        }

        function pauseTotalWorkoutTimer() {
            if (state.workoutStartTime && !state.isWorkoutTimerPaused) {
                if (state.totalWorkoutTimeInterval) clearInterval(state.totalWorkoutTimeInterval);
                state.isWorkoutTimerPaused = true;
                state.pauseStartTime = Date.now();
                updateTimerToggleButtonUI(true);
                updateTotalTimeDisplay(); 
                saveCurrentState();
            }
        }
        
        async function resetTotalWorkoutTimer(withConfirmation = true) {
            let confirmed = false;
            if (withConfirmation) {
                if (!state.workoutStartTime) return;
                confirmed = await customConfirm("Voulez-vous vraiment r√©initialiser le minuteur de la s√©ance ?");
            } else {
                confirmed = true;
            }

            if (confirmed) {
                if (state.totalWorkoutTimeInterval) clearInterval(state.totalWorkoutTimeInterval);
                
                state.workoutStartTime = null;
                state.totalWorkoutTimeInterval = null;
                state.isWorkoutTimerPaused = true;
                state.totalPausedDuration = 0;
                state.pauseStartTime = 0;
                
                dom.totalTimeEl.textContent = "00:00:00";
                updateTimerToggleButtonUI(true); 
                
                const inProgress = JSON.parse(localStorage.getItem('inProgressWorkout')) || {};
                delete inProgress.workoutStartTime;
                delete inProgress.isWorkoutTimerPaused;
                delete inProgress.totalPausedDuration;
                delete inProgress.pauseStartTime;
                localStorage.setItem('inProgressWorkout', JSON.stringify(inProgress));

                if (withConfirmation) {
                    showNotification("Minuteur de la s√©ance r√©initialis√©.", "info");
                }
            }
        }

        function handleVisibilityChange() {
            if (document.hidden) {
                for (const idx in state.timers) {
                    if (state.timers[idx] && state.timers[idx].interval) {
                        clearInterval(state.timers[idx].interval);
                    }
                }
            } else {
                loadPersistentIndividualTimers();
            }
        }

        function applyTheme(theme) {
            document.documentElement.classList.remove('dark-mode-preload');
            if (theme === 'dark') {
                dom.body.classList.add('dark-mode');
                dom.themeToggleBtn.innerHTML = '‚òÄÔ∏è';
                dom.themeToggleBtn.setAttribute('title', 'Passer au th√®me clair');
            } else {
                dom.body.classList.remove('dark-mode');
                dom.themeToggleBtn.innerHTML = 'üåí';
                dom.themeToggleBtn.setAttribute('title', 'Passer au th√®me sombre');
            }
        }

        function updateSessionSelectOptions() {
            dom.sessionSelect.innerHTML = '';
            state.sessions.forEach((session, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = session.name; 
                dom.sessionSelect.appendChild(option);
            });
        }

        function showNewSessionModal() {
            openModal(dom.newSessionModal);
            dom.newSessionNameInput.value = '';
            dom.newSessionNameInput.classList.remove('is-invalid');
            dom.newSessionNameError.textContent = '';
        }

        async function createNewSession() {
            const newName = dom.newSessionNameInput.value.trim();
            if (!newName) {
                dom.newSessionNameInput.classList.add('is-invalid');
                dom.newSessionNameError.textContent = 'Le nom de la s√©ance ne peut pas √™tre vide.';
                return;
            }
            const isDuplicate = state.sessions.some(s => s.name.toLowerCase() === newName.toLowerCase());
            if (isDuplicate) {
                dom.newSessionNameInput.classList.add('is-invalid');
                dom.newSessionNameError.textContent = `Une s√©ance nomm√©e "${newName}" existe d√©j√†. Veuillez choisir un nom diff√©rent.`;
                return;
            }
            dom.newSessionNameInput.classList.remove('is-invalid');
            dom.newSessionNameError.textContent = '';

            const newSession = { name: newName, isDefault: false, exercises: [] };
            state.sessions.push(newSession);
            updateSessionSelectOptions(); 
            const newSessionIndex = state.sessions.length - 1;
            
            closeModal(dom.newSessionModal);
            showNotification(`S√©ance "${newName}" cr√©√©e avec succ√®s !`, "success");
            
            if (!dashboard.classList.contains('hidden')) {
                startSessionFromDashboard(newSessionIndex);
            } else {
                state.currentSessionIndex = newSessionIndex; 
                dom.sessionSelect.value = state.currentSessionIndex;
                localStorage.removeItem('inProgressWorkout');
                resetTotalWorkoutTimer(false);
                createTable(); 
                updateAllTotals(); 
            }
        }

        function updateDeleteSessionButtonState() {
            const currentSession = state.sessions[state.currentSessionIndex];
            if (currentSession) {
                dom.deleteCurrentSessionBtn.removeAttribute('disabled');
                dom.deleteCurrentSessionBtn.classList.remove('btn-outline');
                dom.deleteCurrentSessionBtn.classList.add('btn-danger');
                if (currentSession.isDefault) {
                    dom.deleteCurrentSessionBtn.setAttribute('title', 'R√©initialiser les donn√©es de cette s√©ance par d√©faut');
                } else {
                    dom.deleteCurrentSessionBtn.setAttribute('title', 'Supprimer d√©finitivement cette s√©ance personnalis√©e');
                }
            } else {
                 dom.deleteCurrentSessionBtn.setAttribute('disabled', 'true');
                 dom.deleteCurrentSessionBtn.classList.remove('btn-danger');
                 dom.deleteCurrentSessionBtn.classList.add('btn-outline');
            }
        }

        async function deleteCurrentSession() {
            const currentSession = state.sessions[state.currentSessionIndex];
            if (!currentSession) return;

            if (currentSession.isDefault) {
                const confirmed = await customConfirm(`Voulez-vous vraiment r√©initialiser toutes les donn√©es (poids et reps) pour la s√©ance par d√©faut "${currentSession.name}" ?`);
                if (confirmed) {
                    currentSession.exercises.forEach(ex => {
                        ex.series.forEach(s => {
                            s.weight = '';
                            s.reps = '';
                        });
                    });
                    createTable();
                    updateAllTotals();
                    showNotification(`S√©ance par d√©faut "${currentSession.name}" r√©initialis√©e.`, "info");
                }
            } else {
                const confirmed = await customConfirm(`√ätes-vous s√ªr de vouloir supprimer d√©finitivement la s√©ance personnalis√©e "${currentSession.name}"? Cette action est irr√©versible.`);
                if (confirmed) {
                    state.sessions.splice(state.currentSessionIndex, 1);
                    state.currentSessionIndex = 0;
                    updateSessionSelectOptions();
                    dom.sessionSelect.value = state.currentSessionIndex;
                    localStorage.removeItem('inProgressWorkout');
                    resetTotalWorkoutTimer(false);
                    createTable();
                    updateAllTotals();
                    showNotification(`S√©ance "${currentSession.name}" supprim√©e avec succ√®s.`, "info");
                }
            }
        }

        async function resetCurrentSession() {
            const currentSession = state.sessions[state.currentSessionIndex];
            if (!currentSession) return;

            const confirmed = await customConfirm(`Voulez-vous vraiment r√©initialiser toutes les donn√©es (poids et reps) pour la s√©ance "${currentSession.name}" ?`);
            if (confirmed) {
                currentSession.exercises.forEach(ex => {
                    if (ex.series && Array.isArray(ex.series)) {
                        ex.series.forEach(s => {
                            s.weight = '';
                            s.reps = '';
                        });
                    }
                });
                createTable();
                updateAllTotals();
                showNotification(`S√©ance "${currentSession.name}" r√©initialis√©e.`, "info");
            }
        }

        async function openNewSessionLogic(historicalSession) {
            const confirmed = await customConfirm("Ouvrir cette s√©ance ? La s√©ance en cours sera remplac√©e et toutes les donn√©es non sauvegard√©es seront perdues.");
            if (!confirmed) return;
            Object.values(state.timers).forEach(timer => {
                if (timer && timer.interval) clearInterval(timer.interval);
            });
            state.timers = {};
            resetTotalWorkoutTimer(false);
            localStorage.removeItem('inProgressWorkout');
            
            dom.totalKgRepEl.textContent = "0 kg/rep";
            dom.deltaEl.textContent = "0 kg";
            dom.previousWeekInput.value = "";
            dom.sessionNotesInput.value = ""; 
            let sessionIndexToLoad = state.sessions.findIndex(s => s.name === historicalSession.sessionName);
            if (sessionIndexToLoad === -1) {
                const newTemplateExercises = historicalSession.exercises.map(ex => ({
                    name: ex.name,
                    rest: ex.rest || "1 min",
                    series: ex.series.map(s => ({weight: s.weight, reps: s.reps})) || []
                }));
                const newTemplate = { name: historicalSession.sessionName, exercises: newTemplateExercises };
                state.sessions.push(newTemplate);
                sessionIndexToLoad = state.sessions.length - 1;
                updateSessionSelectOptions(); 
            } else {
                state.sessions[sessionIndexToLoad].exercises = historicalSession.exercises.map(ex => ({
                    name: ex.name,
                    rest: ex.rest || "1 min",
                    series: ex.series.map(s => ({weight: s.weight, reps: s.reps})) || []
                }));
            }
            state.currentSessionIndex = sessionIndexToLoad;
            dom.sessionSelect.value = state.currentSessionIndex; 
            createTable();
            dom.previousWeekInput.value = historicalSession.totalKgRep || "";
            dom.sessionNotesInput.value = historicalSession.notes || ""; 
            showNotification(`S√©ance "${historicalSession.sessionName}" ouverte et charg√©e avec succ√®s.`, "success", 3000);
            closeModal(dom.loadOptionsModal);
            closeModal(dom.historyModal);
        }

        async function appendToCurrentSessionLogic(historicalSession) {
            const confirmed = await customConfirm("Ajouter/mettre √† jour les exercices de cette s√©ance √† la s√©ance en cours ? Cela √©crasera les s√©ries existantes pour les exercices ayant le m√™me nom.");
            if (!confirmed) return;
            const currentSession = state.sessions[state.currentSessionIndex];
            if (!currentSession.exercises) {
                currentSession.exercises = []; 
            }
            let exercisesAdded = 0;
            let exercisesUpdated = 0;
            historicalSession.exercises.forEach(historicalEx => {
                const existingExIndex = currentSession.exercises.findIndex(ex => ex.name === historicalEx.name);
                if (existingExIndex !== -1) {
                    const currentEx = currentSession.exercises[existingExIndex];
                    currentEx.series = historicalEx.series.map(s => ({weight: s.weight, reps: s.reps}));
                    exercisesUpdated++;
                } else {
                    currentSession.exercises.push({
                        name: historicalEx.name,
                        rest: historicalEx.rest || "1 min",
                        series: historicalEx.series.map(s => ({weight: s.weight, reps: s.reps}))
                    });
                    exercisesAdded++;
                }
            });
            createTable(); 
            dom.previousWeekInput.value = historicalSession.totalKgRep || "";
            dom.sessionNotesInput.value = historicalSession.notes || ""; 
            showNotification(`${exercisesAdded} exercices ajout√©s et ${exercisesUpdated} mis √† jour dans la s√©ance en cours.`, "success", 5000);
            closeModal(dom.loadOptionsModal);
            closeModal(dom.historyModal);
        }

        function showLoadOptionsModal(session) {
            state.sessionToLoad = session; 
            dom.loadSessionNameDisplay.textContent = session.sessionName;
            openModal(dom.loadOptionsModal);
        }
           
        function playBeep() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.type = 'sine'; 
                oscillator.frequency.setValueAtTime(500, audioContext.currentTime); 
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.01); 
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5); 
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5); 
            } catch (error) {
                console.warn("Could not play sound.", error);
            }
        }

        function isValidAndCompleteNumber(value) {
            if (value === null || value.trim() === '') return false;
            const segments = value.trim().split('+');
            const regex = /^\d+(\.\d{1,2})?$/;

            for (const segment of segments) {
                if (segment.trim() === '' || !regex.test(segment.trim()) || parseFloat(segment.trim()) < 0) {
                    return false;
                }
            }
            return true;
        }

        function loadPersistentIndividualTimers() {
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('timer-')) {
                    const idx = parseInt(key.replace('timer-', ''), 10);
                    try {
                        const storedTimer = JSON.parse(localStorage.getItem(key));
                        if (storedTimer && storedTimer.endTime > Date.now()) {
                            const remainingSeconds = (storedTimer.endTime - Date.now()) / 1000;
                            if (remainingSeconds > 0) {
                                const element = document.querySelector(`[data-exercise-index="${idx}"]`);
                                if (element) {
                                    const timerDisplay = element.querySelector('.timer-display');
                                    const startBtn = element.querySelector('[data-timer-action="start"]');
                                    const stopBtn = element.querySelector('[data-timer-action="stop"]');

                                    if (state.timers[idx] && state.timers[idx].interval) {
                                        clearInterval(state.timers[idx].interval);
                                    }

                                    state.timers[idx] = {
                                        secondsElapsed: storedTimer.duration - remainingSeconds,
                                        duration: storedTimer.duration,
                                        interval: setInterval(() => {
                                            state.timers[idx].secondsElapsed++;
                                            const currentRemaining = state.timers[idx].duration - state.timers[idx].secondsElapsed;
                                            if (currentRemaining <= 0) {
                                                timerDisplay.textContent = formatTimerDisplay(0);
                                                timerDisplay.classList.remove('timer-active');
                                                clearInterval(state.timers[idx].interval);
                                                localStorage.removeItem(`timer-${idx}`);
                                                playBeep(); 
                                                if(Notification.permission === "granted") {
                                                    new Notification('Lyftiv - Repos Termin√© !', { body: `Le temps de repos pour ${storedTimer.name} est termin√©.`});
                                                }
                                                startBtn.classList.remove('hidden'); 
                                                stopBtn.classList.add('hidden'); 
                                                timerDisplay.textContent = formatTimerDisplay(storedTimer.duration); 
                                            } else {
                                                timerDisplay.textContent = formatTimerDisplay(currentRemaining); 
                                            }
                                        }, 1000)
                                    };
                                    timerDisplay.textContent = formatTimerDisplay(remainingSeconds);
                                    timerDisplay.classList.add('timer-active');
                                    startBtn.classList.add('hidden');
                                    stopBtn.classList.remove('hidden');
                                } else {
                                    localStorage.removeItem(key);
                                }
                            } else {
                                localStorage.removeItem(key);
                            }
                        } else {
                            localStorage.removeItem(key);
                        }
                    } catch (e) {
                        console.error(`Error parsing stored timer data for key ${key}:`, e);
                        localStorage.removeItem(key);
                    }
                }
            }
        }
        
        function handleSeriesUpdate(exerciseIndex, seriesIndex) {
            const exercise = state.sessions[state.currentSessionIndex].exercises[exerciseIndex];
            if (!exercise) return;

            const currentSeries = exercise.series[seriesIndex];
            const nextSeries = exercise.series[seriesIndex + 1];

            const currentWeight = currentSeries.weight?.trim();
            const currentReps = currentSeries.reps?.trim();

            if (currentWeight && currentReps && nextSeries) {
                const nextSeriesWeight = nextSeries.weight?.trim();
                if (!nextSeriesWeight) {
                    nextSeries.weight = currentWeight;
                    const scrollY = window.scrollY;
                    createTable();
                    window.scrollTo(0, scrollY);
                    showNotification(`Poids pr√©-rempli pour la s√©rie suivante.`, "info", 1500);
                }
            }
        }

        function setupEventListeners() {
            document.querySelectorAll('input[inputmode="decimal"]').forEach(input => {
                input.addEventListener('input', e => {
                    e.target.value = e.target.value.replace(/,/g, '.');
                });
            });

            dom.homeBtn.addEventListener('click', () => {
                document.getElementById('dashboard').classList.remove('hidden');
                document.getElementById('app-container').classList.add('hidden');
                sessionStorage.removeItem('dashboardShown'); 
                populateDashboard();
            });

            dom.sessionSelect.addEventListener('change', () => {
              for (const key in state.timers) {
                const t = state.timers[key];
                if (t && t.interval) {
                  clearInterval(t.interval);
                  localStorage.removeItem(`timer-${key}`);
                }
              }
              state.timers = {};
              resetTotalWorkoutTimer(false);
              localStorage.removeItem('inProgressWorkout');
              state.currentSessionIndex = +dom.sessionSelect.value;
              if (dom.totalKgRepEl) dom.totalKgRepEl.textContent = "0 kg/rep";
              if (dom.deltaEl) dom.deltaEl.textContent = "0 kg";
              if (dom.previousWeekInput) dom.previousWeekInput.value = "";
              if (dom.sessionNotesInput) dom.sessionNotesInput.value = "";
              createTable();
              updateAllTotals();
              updateDeleteSessionButtonState();
              showNotification("S√©ance chang√©e.", "info", 2000);
            });
            
            dom.addExerciseBtn.addEventListener('click', () => {
                const name = dom.customExerciseInput.value.trim();
                if (name) {
                    saveCurrentState();
                    const scrollY = window.scrollY;
                    if (!state.sessions[state.currentSessionIndex].exercises) {
                        state.sessions[state.currentSessionIndex].exercises = [];
                    }
                    const fourSeries = [{weight: '', reps: ''}, {weight: '', reps: ''}, {weight: '', reps: ''}, {weight: ''}];
                    state.sessions[state.currentSessionIndex].exercises.push({ name, rest: "1 min", series: fourSeries, isDefault: false });
                    createTable(); 
                    window.scrollTo(0, scrollY);
                    dom.customExerciseInput.value = '';
                    showNotification(`Exercice "${name}" ajout√© avec succ√®s.`, "info");
                } else {
                    showNotification("Veuillez entrer un nom d'exercice √† ajouter.", "error");
                }
            });

            dom.exerciseListContainer.addEventListener('blur', (e) => {
                if (e.target.classList.contains('reps') || e.target.classList.contains('weight')) {
                    handleNumericInput(e);
                    const exIndex = +e.target.dataset.ex;
                    const serieIndex = +e.target.dataset.serie;
                    saveCurrentState(); 
                    handleSeriesUpdate(exIndex, serieIndex);
                }
            }, true);


            dom.exerciseListContainer.addEventListener('input', e => { 
                if (e.target.classList.contains('reps') || e.target.classList.contains('weight')) {
                    if (!state.workoutStartTime) {
                        startTotalWorkoutTimer();
                    }
                    updateAllTotals(); 
                }
            });

            dom.exerciseListContainer.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    const target = e.target;
                    if (target.classList.contains('weight') || target.classList.contains('reps')) {
                        e.preventDefault();
                        target.blur();
                    }
                }
            });

            const pressHandler = (e) => {
                const button = e.target.closest('.serie-input-delete');
                if (!button) return;

                state.pressTimer = setTimeout(() => {
                    if (navigator.vibrate) navigator.vibrate(50);

                    const scrollY = window.scrollY;
                    const exIndex = +button.dataset.ex;
                    const serieIndex = +button.dataset.serie;
                    const exercise = state.sessions[state.currentSessionIndex].exercises[exIndex];

                    if (exercise.series.length > 1) {
                        exercise.series.splice(serieIndex, 1);
                        createTable();
                        window.scrollTo(0, scrollY);
                        updateAllTotals();
                        showNotification(`S√©rie ${serieIndex + 1} supprim√©e.`, "info", 2000);
                    } else {
                        showNotification("Un exercice doit avoir au moins une s√©rie.", "error", 3000);
                    }
                }, 500);
            };

            const releaseHandler = () => {
                clearTimeout(state.pressTimer);
            };

            dom.exerciseListContainer.addEventListener('mousedown', pressHandler);
            dom.exerciseListContainer.addEventListener('mouseup', releaseHandler);
            dom.exerciseListContainer.addEventListener('mouseleave', releaseHandler, true);
            dom.exerciseListContainer.addEventListener('touchstart', pressHandler);
            dom.exerciseListContainer.addEventListener('touchend', releaseHandler);
            dom.exerciseListContainer.addEventListener('touchcancel', releaseHandler, true);

            dom.exerciseListContainer.addEventListener('dblclick', (e) => {
                const button = e.target.closest('.serie-input-delete');
                if (!button) return;

                clearTimeout(state.pressTimer);

                const scrollY = window.scrollY;
                const exIndex = +button.dataset.ex;
                const serieIndex = +button.dataset.serie;
                const exercise = state.sessions[state.currentSessionIndex].exercises[exIndex];

                if (exercise && exercise.series[serieIndex]) {
                    exercise.series[serieIndex].weight = '';
                    exercise.series[serieIndex].reps = '';
                    createTable();
                    window.scrollTo(0, scrollY);
                    updateAllTotals();
                    showNotification(`Donn√©es de la s√©rie ${serieIndex + 1} effac√©es.`, "info", 2000);
                }
            });


            dom.previousWeekInput.addEventListener('input', updateAllTotals); 
            dom.exerciseListContainer.addEventListener('click', handleTableActions); 
            document.getElementById('finishSessionBtn').addEventListener('click', finishAndSaveSession);
            document.getElementById('viewHistoryBtn').addEventListener('click', () => {
                displayHistory(); 
                openModal(dom.historyModal);
            });
            dom.historyModal.addEventListener('click', handleHistoryActions);
            dom.exportBtn.addEventListener('click', exportCSV); 
            dom.importBtn.addEventListener('click', () => dom.importFileInput.click());

            dom.importFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) {
                    showNotification("Aucun fichier s√©lectionn√© pour l'importation.", "info");
                    return;
                }

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const content = e.target.result;
                        let importedData;

                        if (file.name.endsWith('.json')) {
                            importedData = JSON.parse(content);
                        } else if (file.name.endsWith('.csv')) {
                            importedData = parseCsvToHistory(content);
                        } else {
                            showNotification("Format de fichier non pris en charge. Veuillez utiliser un fichier .json ou .csv.", "error");
                            return;
                        }

                        let currentHistory = getHistory();
                        let newEntriesCount = 0;
                        let updatedEntriesCount = 0;
                        
                        importedData.forEach(importedSession => {
                            const existingIndex = currentHistory.findIndex(s => s.id === importedSession.id);
                            if (existingIndex !== -1) {
                                currentHistory[existingIndex] = importedSession;
                                updatedEntriesCount++;
                            } else {
                                currentHistory.push(importedSession);
                                newEntriesCount++;
                            }
                        });

                        localStorage.setItem('workoutHistory', JSON.stringify(currentHistory));
                        displayHistory();
                        showNotification(`${newEntriesCount} s√©ances import√©es et ${updatedEntriesCount} mises √† jour avec succ√®s.`, "success");

                    } catch (error) {
                        console.error("Erreur lors de l'importation du fichier:", error);
                        showNotification("Une erreur est survenue lors du traitement du fichier. Veuillez v√©rifier son format.", "error");
                    } finally {
                        event.target.value = '';
                    }
                };
                reader.readAsText(file, 'UTF-8');
            });
            
            dom.closeHistoryModal.addEventListener('click', () => closeModal(dom.historyModal));
            dom.themeToggleBtn.addEventListener('click', () => {
                const newTheme = dom.body.classList.contains('dark-mode') ? 'light' : 'dark';
                applyTheme(newTheme);
                localStorage.setItem('theme', newTheme);
            });
            
            dom.toggleWorkoutTimerBtn.addEventListener('click', () => {
                if (state.isWorkoutTimerPaused) {
                    startTotalWorkoutTimer();
                } else {
                    pauseTotalWorkoutTimer();
                }
            });

            dom.resetWorkoutTimerBtn.addEventListener('click', () => resetTotalWorkoutTimer(true));
            dom.createNewSessionTypeBtn.addEventListener('click', showNewSessionModal);
            dom.deleteCurrentSessionBtn.addEventListener('click', deleteCurrentSession);
            dom.resetCurrentSessionBtn.addEventListener('click', resetCurrentSession);
            dom.closeNewSessionModal.addEventListener('click', () => closeModal(dom.newSessionModal));
            dom.cancelNewSessionBtn.addEventListener('click', () => closeModal(dom.newSessionModal));
            dom.createNewSessionBtn.addEventListener('click', createNewSession);
            dom.closeLoadOptionsModal.addEventListener('click', () => closeModal(dom.loadOptionsModal));
            dom.openNewSessionBtn.addEventListener('click', async () => { 
                if (state.sessionToLoad) await openNewSessionLogic(state.sessionToLoad);
            });
            dom.appendToCurrentSessionBtn.addEventListener('click', async () => { 
                if (state.sessionToLoad) await appendToCurrentSessionLogic(state.sessionToLoad);
            });

            if (dom.plateCalculatorBtn) {
                dom.plateCalculatorBtn.addEventListener('click', () => openModal(dom.plateCalculatorModal));
            }

            dom.closePlateCalculatorModal.addEventListener('click', () => closeModal(dom.plateCalculatorModal));
            if (dom.targetWeightInput) dom.targetWeightInput.addEventListener('input', calculatePlates);
            if (dom.barbellWeightInput) dom.barbellWeightInput.addEventListener('input', calculatePlates);
            
            document.querySelectorAll('input[name="oneRmInputMode"]').forEach(radio => {
                radio.addEventListener('change', (event) => {
                    if (event.target.value === 'manual') {
                        dom.oneRmManualInput.classList.remove('hidden');
                        dom.oneRmSelectInput.classList.add('hidden');
                        dom.oneRmInput.focus();
                        dom.oneRmExerciseSelect.value = '';
                    } else {
                        dom.oneRmManualInput.classList.add('hidden');
                        dom.oneRmSelectInput.classList.remove('hidden');
                        dom.oneRmExerciseSelect.focus();
                        dom.oneRmInput.value = '';
                        calculateTrainingGoals();
                    }
                });
            });

            if (dom.oneRmExerciseSelect) {
                dom.oneRmExerciseSelect.addEventListener('change', () => {
                    dom.oneRmInput.value = dom.oneRmExerciseSelect.value;
                    calculateTrainingGoals();
                });
            }

            if (dom.oneRmInput) {
                dom.oneRmInput.addEventListener('input', calculateTrainingGoals);
            }

            if (dom.plateCalcTab) {
                dom.plateCalcTab.addEventListener('click', () => {
                    dom.plateCalcTab.classList.add('active');
                    dom.plateCalcTab.setAttribute('aria-selected', 'true');
                    dom.goalCalcTab.classList.remove('active');
                    dom.goalCalcTab.setAttribute('aria-selected', 'false');
                    dom.plateCalcContent.classList.remove('hidden');
                    dom.goalCalcContent.classList.add('hidden');
                    const firstInput = dom.plateCalcContent.querySelector('input, button');
                    if (firstInput) firstInput.focus();
                });
            }

            if (dom.goalCalcTab) {
                dom.goalCalcTab.addEventListener('click', () => {
                    dom.goalCalcTab.classList.add('active');
                    dom.goalCalcTab.setAttribute('aria-selected', 'true');
                    dom.plateCalcTab.classList.remove('active');
                    dom.plateCalcTab.setAttribute('aria-selected', 'false');
                    dom.goalCalcContent.classList.remove('hidden');
                    dom.plateCalcContent.classList.add('hidden');
                    const firstInput = dom.goalCalcContent.querySelector('input, button');
                    if (firstInput) firstInput.focus();
                });
            }
            
            dom.closeQuickEditModal.addEventListener('click', () => closeModal(dom.quickEditModal));
            dom.applyQuickEditBtn.addEventListener('click', () => {
                const weightValid = validateInputField(dom.quickEditWeight, dom.quickEditWeightError, true);
                const repsValid = validateInputField(dom.quickEditReps, dom.quickEditRepsError, true);

                if (!weightValid || !repsValid) {
                    showNotification("Veuillez corriger les erreurs pour appliquer l'√©dition rapide.", "error");
                    return;
                }

                if (state.quickEditIndex !== null) {
                    const weight = dom.quickEditWeight.value;
                    const reps = dom.quickEditReps.value;
                    const exerciseToUpdate = state.sessions[state.currentSessionIndex].exercises[state.quickEditIndex];
                    exerciseToUpdate.series.forEach((s, i) => {
                        exerciseToUpdate.series[i].weight = weight;
                        exerciseToUpdate.series[i].reps = reps;
                    });
                    
                    createTable();
                    updateAllTotals();
                    closeModal(dom.quickEditModal);
                    showNotification("S√©ries mises √† jour rapidement !", "success");
                }
            });

            document.addEventListener('keydown', e => {
                if (e.ctrlKey || e.metaKey) { 
                    if (e.key === 's') { e.preventDefault(); finishAndSaveSession(); } 
                    if (e.key === 'e') { e.preventDefault(); exportCSV(); } 
                }
            });

            dom.bottomAddExerciseBtn.addEventListener('click', () => {
                dom.addExerciseSection.scrollIntoView({ behavior: 'smooth' });
                if (!state.isMobileView) {
                    setTimeout(() => {
                        dom.customExerciseInput.focus();
                    }, 300);
                }
            });
            dom.bottomNotesBtn.addEventListener('click', () => {
                state.isNotesSectionVisible = !state.isNotesSectionVisible;
                if (state.isNotesSectionVisible) {
                    dom.sessionNotesSection.classList.add('show-notes-section');
                    dom.sessionNotesSection.classList.remove('hide-notes-section');
                    if (!state.isMobileView) dom.sessionNotesInput.focus();
                    dom.sessionNotesSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                } else {
                    dom.sessionNotesSection.classList.remove('show-notes-section');
                    dom.sessionNotesSection.classList.add('hide-notes-section');
                }
            });
            dom.bottomScrollBtn.addEventListener('click', () => {
                const currentScrollY = window.scrollY;
                const windowHeight = window.innerHeight;
                const documentHeight = document.documentElement.scrollHeight;
            
                const distanceToTop = currentScrollY;
                const distanceToBottom = documentHeight - windowHeight - currentScrollY;
            
                if (distanceToBottom > distanceToTop) {
                    window.scrollTo({ top: documentHeight, behavior: 'smooth' });
                } else {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            });
            dom.bottomViewHistoryBtn.addEventListener('click', () => {
                displayHistory(); 
                openModal(dom.historyModal);
            });
            dom.bottomPlateCalculatorBtn.addEventListener('click', () => {
                openModal(dom.plateCalculatorModal);
            });
            
            document.addEventListener('visibilitychange', handleVisibilityChange);
        }

        init();
    });
    </script>
</body>
</html>
